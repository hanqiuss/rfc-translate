<div class="content" style="float: left; margin: 0px 30%; width: 579px; font-size: 10pt;">
   <div style="height: 13px;">
      <div onmouseover="this.style.cursor='pointer';" onclick="showElem('legend');" onmouseout="hideElem('legend')" style="height: 6px; position: absolute; cursor: pointer;" class="pre noprint docinfo bgblue" title="Click for colour legend.">                                                                        </div>
      <div id="legend" class="docinfo noprint pre legend" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; " onmouseover="showElem('legend');" onmouseout="hideElem('legend');">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="../html/" title="Document search and retrieval page">Docs</a>] [<a href="/rfc/rfc4122.txt" title="Plaintext version of this document">txt</a>|<a href="/pdf/rfc4122" title="PDF version of this document">pdf</a>] [<a href="./draft-mealling-uuid-urn" title="draft-mealling-uuid-urn">draft-mealling-...</a>] [<a href="https://datatracker.ietf.org/doc/rfc4122" title="IESG Datatracker information for this document">Tracker</a>] [<a href="/rfcdiff?difftype=--hwdiff&amp;url2=rfc4122" title="Inline diff (wdiff)">Diff1</a>] [<a href="/rfcdiff?url2=rfc4122" title="Side-by-side diff">Diff2</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=4122">Errata</a>]</span><br>
<span class="pre noprint docinfo">                                                                        </span><br>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br>
<pre style="height: 780px; white-space: pre-wrap;">Network Working Group                                           P. Leach
Request for Comments: 4122                                     Microsoft
Category: Standards Track                                    M. Mealling
                                                Refactored Networks, LLC
                                                                 R. Salz
                                              DataPower Technology, Inc.
                                                               July 2005
 

                   通用唯一标识器 (UUID) URN 命名空间
 
本备忘录的状态
 
   本文档为 Internet 社区指定了 Internet 标准跟踪协议,并请求讨论和改进建议。 有关
   此协议的标准化状态和状态,请参阅当前版本的"互联网官方协议标准"(STD 1)。 此备忘录的
   分发是无限制的。
 
版权声明
 
   版权所有(C) 互联网协会(2005年)。
 
摘要
 
   此规范为 UUID(通用唯一标识器)定义了统一资源名称命名空间,也称为 GUID(全局唯一标
   识)。 UUID 长 128 位,可以保证跨空间和跨时间的唯一性。 UUID 最初用于 Apollo 
   网络计算系统,后来在开放软件基金会 (OSF) 分布式计算环境 (DCE) 中,然后在 
   Microsoft Windows 平台中使用。
 
   此规范派生自具有 OSF(现在称为开放组)的某种权限的 DCE 规范。  来自早期版本的 DCE 
   规范的信息已纳入本文档。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
目录
 
   1. 介绍  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  2
   2. 起因  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3
   3. 命名空间注册模板  . . . . . . . .   . . . . . . . . . . . . . . .  3
   4. 规范  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5
      4.1. 格式 . . . . . . . . . . . . . . . . . . . . . . . . . . .  5
           4.1.1. 变种    . . . . . . . . . . . . . . . . . . . . . .  6
           4.1.2. 布局和字节顺序          . . . . . . . . . . . . . . .  6
           4.1.3. 版本    . . . . . . . . . . . . . . . . . . . . . .  7
           4.1.4. 时间戳    . . . . . . . . . . . . . . . . . . . . .  8
           4.1.5. 时钟序列         . . . . . . . . . . . . . . . . . .  8
           4.1.6. 节点  . . . . . . . . . . . . . . . . . . . . . . .  9
           4.1.7. nil UUID . . . . . . . . . . . . . . . . . . . . .  9
      4.2. 用于创建基于时间的 UUID 的算法                 . . . . . . . .  9
           4.2.1. 基本算法         . . . . . . . . . . . . . . . . . . 10
           4.2.2. 生成详细信息          . . . . . . . . . . . . . . . . 12
      4.3. 创建基于名称的 UUID 的算法                  . . . . . . . . . 13
      4.4. 从真正随机或伪随机数创建 UUID 的算法  . . . . . . . . . . . . . 14
      4.5. 未认证主机的节点标识                      . . . . . . . . . . 15
   5. 社区注意事项               . . . . . . . . . . . . . . . . . . . 15
   6. 安全注意事项               . . . . . . . . . . . . . . . . . . . 16
   7. 致谢              . . . . . . . . . . . . . . . . . . . . . . . 16
   8. 参考规范               . . . . . . . . . . . . . . . . . . . . . 16
   A. 附录 A - 示例实现                     . . . . . . . . . . . . . . 18
   B. 附录 B - utest 的样本输出               . . . . . . . . . . . . . 29
   C. 附录 C - 部分名称空间               . . . . . . . . . . . . . . . 30
 
1.  介绍
 
   此规范为 UUID(通用唯一标识器)定义了统一资源名称命名空间,也称为 GUID(全局唯一标
   识)。 UUID 长 128 位,无需中央注册过程。
 
   此处的信息旨在成为希望使用 UUID 作为 URN 实施服务的人员的简明指南。 本文档中的
   任何内容均不应解释为覆盖定义 UUID 的 DCE 标准。
 
   ITU-T 建议和 ISO/IEC 标准 [3] 源自本文档的早期版本。 两套规格均已对齐,在技术上
   完全兼容。 此外,ITU-T电信标准化局正在提供全球注册功能;  有关详细信息,请参阅
   <a href="http://www.itu.int/ITU-T/asn1/uuid.html">http://www.itu.int/ITU-T/asn1/uuid.html</a></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
2.  起因
 
   使用 UUID 的主要原因之一是不需要集中机构来管理它们(尽管一种格式使用 IEEE 802 节点
   标识符,但其他格式不使用)。 因此,按需生成可以完全自动化,并用于各种目的。 此处描述的
   UUID 生成算法支持高达每秒 1000 万台(如有必要)的非常高的分配速率,以便它们甚至可以
   用作事务 ID。
 
   UUID 是固定大小(128 位),与其他替代方法相比相当小。 这非常适合对各种排序、排序和
   哈希,在数据库中存储,进行简单的分配,并且通常易于编程。
 
   由于 UUID 是唯一且持久的,因此它们会创建出色的统一资源名称。 在没有注册过程的情况下
   生成新的 UUID 的独特能力使 UUID 成为具有最低造币成本的 URN 之一。
 
3.  命名空间注册模板
 
   命名空间 ID:  UUID
   注册信息:
      注册日期: 2003-10-01
 
   已声明的命名空间注册人:
      JTC 1/SC6 (ASN.1 Rapporteur Group)
 
   语法结构声明:
      UUID 是一个标识符,相对于所有 UUID 的空间,在空间和时间上都是唯一的。 由于 UUID
      是固定大小且包含时间字段,因此值可以滚动(大约在 A.D. 3400 附近,具体取决于所使
      用的特定算法)。 UUID 可用于多种目的,从标记生存期极短的对象到可靠地识别网络中
      非常持久的对象。
 
      UUID 的内部表示形式是内存中特定的位序列,如第 4 节所述。 要将 UUID 准确地表示
      为 URN,必须将位序列转换为字符串表示形式。
 
      每个字段都被视为整数,其值打印为具有最显著数字的零填充十六进制数字字符串。 十六
      进制值 "a" 到 "f" 作为小写字符输出,并且对输入不区分大小写。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
      UUID 字符串表示形式的正式定义由以下 ABNF [7]提供:
 
      UUID                   = time-low "-" time-mid "-"
                               time-high-and-version "-"
                               clock-seq-and-reserved
                               clock-seq-low "-" node
      time-low               = 4hexOctet
      time-mid               = 2hexOctet
      time-high-and-version  = 2hexOctet
      clock-seq-and-reserved = hexOctet
      clock-seq-low          = hexOctet
      node                   = 6hexOctet
      hexOctet               = hexDigit hexDigit
      hexDigit =
            "0" / "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9" /
            "a" / "b" / "c" / "d" / "e" / "f" /
            "A" / "B" / "C" / "D" / "E" / "F"
 
   下面是 UUID 作为 URN 的字符串表示形式的示例:
 
   urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6
 
   相关辅助文件:
      [1][2]
   标识符唯一性注意事项:
      本文档指定了三种算法来生成 UUID:第一种算法利用 802个 MAC 地址的唯一值来保证
      唯一性,第二种算法使用伪随机数生成器,第三种算法使用加密哈希和应用程序-提供的文本
      字符串。因此,根据此处的机制生成的 UUID 将不同于已分配或将分配的所有其他 UUID。
 
   标识符持久性注意事项:
      从全球意义上讲, UUID 本身就很难解决。这一点,加上 UUID 在其空间上下文中在时间上
      是唯一的事实,可确保 UUID 尽可能持久。
 
   标识符分配过程:
      生成 UUID 不需要联系注册机构。一种算法要求每个生成器在空间上具有唯一值。此值
      通常是 IEEE 802 MAC 地址,通常在联网的主机上已有可用。可以从从 IEEE 注册机构
      获取的地址块分配地址。 如果没有此类地址,或者隐私问题使其使用不可取, 第 4.5 节
      指定两种备选方案。 另一种方法是使用版本 3 或版本 4 UUID 所示。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
      


 
   标识符解析过程:
      由于 UUID 无法全局解析,因此这不适用。
 
   词汇等价规则:
      将 UUID 的每个字段视为无符号整数,如第 4.1.2 节中的表所示。 然后,比较一对 
      UUID,按显著性顺序和数据类型对每个 UUID 的相应字段进行比较。仅当所有相应的
      字段都相等时,两个 UUID 才相等。
 
      作为实现说明,可以通过执行适当的字节顺序规范化,然后将两个 UUID 视为 128 位
      无符号整数,在许多系统上执行相等比较。
 
      本文档中定义的 UUID 也可以按字典顺序排序。 对于一对 UUID,如果 UUID 中最重要
      的字段对于第一个 UUID 较大,则第一个 UUID 紧随其后。 如果 UUID 中的最重要的
      字段大于第二个 UUID,则第二个字段位于第一个字段之前。
 
   符合 URN 语法:
      UUID 的字符串表示形式与 URN 语法完全兼容。 将 UUID 的面向位、内存中表示形式
      转换为 URN 时,必须注意严格遵守字符串表示部分中提到的字节顺序问题。
 
   验证机制:
      除了确定 UUID 的时间戳部分是否位于将来,因此尚未分配之外,没有机制可以确定 UUID
      是否"有效"。
 
   范围：
      UUID 是全局范围的。
 
4. 规格
 
4.1. 格式
 
   UUID 格式为 16 个八位字节;下面指定的八位变量字段的某些位确定更精细的结构。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.1.1. 变体
 
   变体字段确定 UUID 的布局。 也就是说,UUID 中所有其他位的解释取决于变体字段中位的
   设置。 因此,可以更准确地称为类型字段;我们保留原始兼容性术语。 变体字段由 UUID 的
   八位字节 8 的可变数组成。
 
   下表列出了变体字段的内容,其中字母 "x" 表示 "don't-care" 值。
 
   Msb0  Msb1  Msb2  Description
 
    0     x     x    保留,NCS 向后兼容性。
 
    1     0     x    本文档中指定的变体。
 
    1     1     0    保留,微软公司向后兼容性
 
    1     1     1    保留以供将来定义。
 
   任何形式的互操作性(与此处定义的变体以外的变体)都不能保证,在实践中也不太可能成为
   问题。
 
4.1.2. 布局和字节顺序
 
   为了尽量减少对八位内位分配的混淆,UUID 记录定义仅根据八位字节的整数字段进行定义。
   首先,字段将呈现其中最重要的字段。
 
   字段                     数据类型      位置    提示
                                        #
 
   time_low               unsigned 32   0-3    时间戳的低位
                          bit integer          
 
   time_mid               unsigned 16   4-5    时间戳的中间位
                          bit integer          
 
   time_hi_and_version    unsigned 16   6-7    使用版本号多路复用的时间戳的
                          bit integer          高位字段
   
   clock-seq-and-reserved  unsigned 8    8     时钟序列的高位与变体多路复用
                          bit integer

   clock_seq_low          unsigned 8     9     时钟序列的低位
                          bit integer

   node                   unsigned 48   10-15  空间唯一节点标识符
                          bit integer      </pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 











 
   在没有明确的应用程序或表示协议规范相反的情况下,UUID 被编码为 128 位对象,如下所示:
 
   字段编码为 16 个八位字节,上面定义了字段的大小和顺序,并且每个字段首先使用"大端法"
   编码(称为网络字节顺序)。 请注意,字段名称(尤其是多路复用字段)遵循历史实践。
 
   0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          time_low                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       time_mid                |         time_hi_and_version   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |clk_seq_hi_res |  clk_seq_low  |         node (0-1)            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         node (2-5)                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 
4.1.3. 版本
 
   版本号位于时间戳的 4 位中(time_hi_and_version 字段的 4 到 7 位)。
 
   下表列出了此 UUID 变体的当前定义版本。
 
   Msb0  Msb1  Msb2  Msb3   Version  Description
 
    0     0     0     1        1     本文档中指定的基于时间的版本。
 
    0     0     1     0        2     DCE 安全版本,具有嵌入式 POSIX UID。

    0     0     1     1        3     使用 MD5 哈希的基于名称的版本。

    0     1     0     0        4     随机或伪随机生成的版本。

    0     1     0     1        5     使用 SHA-1 哈希的基于名称的版本。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 













 
   这里的"版本"更准确地说是"子类型";同样,我们保留了兼容性的术语。
 
4.1.4. 时间戳
 
   时间戳是 60 位值。 对于 UUID 版本 1,这由协调世界时间 (UTC) 表示为自 1582 年
   10 月 15 日 00:00:00.00(基督教历公历改革日期)以来的 100 纳秒间隔计数。
 
   对于没有 UTC 可用但具有本地时间的系统,它们可以使用该系统而不是 UTC,只要它们在整个
   系统中始终如一地使用 UTC。 但是,不建议这样做,因为从本地时间生成 UTC 只需要时区
   偏移量。
 
   对于 UUID 版本 3 或 5,时间戳是一个 60 位值,由第 4.3 节中所述的名称构造。
 
   对于 UUID 版本 4,时间戳是随机或伪随机生成的 60 位值,如第 4.4 节所述。
 





4.1.5. 时钟序列
 
   对于 UUID 版本 1,时钟序列用于帮助避免在时间向后设置时钟或节点 ID 更改时可能出现
   的重复。
 
   如果时钟是向后设置的,或者可能已向后设置(例如,当系统关闭电源时),并且 UUID 生成器
   无法确保没有生成时间戳大于时钟设置的 UUID 值 ,则时钟序列必须改变。 如果时钟
   序列的上一个值是已知的,它可以只是增加;否则,应将其设置为随机或高质量的伪随机值。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   同样,如果节点 ID 发生更改(例如,因为网卡已在计算机之间移动),将时钟序列设置为随机数
   可最大程度地降低由于计算机时钟设置略有不同而导致的重复的可能性。 如果已知与已更改的
   节点 ID 关联的时钟序列值,则时钟序列可能只是递增的,但不太可能。
 
   时钟序列必须最初(即,在系统的生存期内一次)初始化为随机数,以尽量减少系统之间的关联。
   这提供了针对节点标识符的最大保护,这些节点标识符可能会快速移动或从系统切换到系统。
   初始值不得与节点标识符关联。
 
   对于 UUID 版本 3 或 5,时钟序列是一个 14 位值,该值由第 4.3 节中所述的名称构造。
 
   对于 UUID 版本 4,时钟序列是随机或伪随机生成的 14 位值,如第 4.4 节所述。
 





4.1.6. 节点
 
   对于 UUID 版本 1,节点字段由 IEEE 802 MAC 地址(通常是主机地址)组成。 对于具有
   多个 IEEE 802 地址的系统,可以使用任何可用地址。 最低地址八位字节(八位字节数 10)
   包含全局/本地位和单播/多播位,并且是在 802.3 LAN 上传输的地址的第一个八位字节。
 
   对于没有 IEEE 地址的系统,可以使用随机或伪随机生成的值;参见第 4.5 节。 多播位必须
   在此类地址中设置,以便它们永远不会与从网卡获取的地址冲突。
 
   对于 UUID 版本 3 或 5,节点字段是一个 48 位值,该值由第 4.3 节中所述的名称构造。
 
   对于 UUID 版本 4,节点字段是随机或伪随机生成的 48 位值,如第 4.4 节所述。
 
4.1.7. Nil UUID
 
   nil UUID 是特殊形式的 UUID,指定将所有 128 位设置为零。
 
4.2. 创建基于时间的 UUID 的算法
 
   以下各节将讨论创建版本 1 UUID 的算法的各个方面。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.1. 基本算法
 
   以下算法简单、正确且效率低下:
 
   o 获取系统范围全局锁
 
   o 从系统范围的共享稳定存储(例如,文件)中读取 UUID 生成器状态:用于生成最后一个 
     UUID 的时间戳、时钟序列和节点 ID 的值。
 
   o 获取当前时间作为自 1582 年 10 月 15 日 00:00:00.00 以来的 100 纳秒间隔的
     60 位计数。
 
   o 获取当前节点 ID。
 
   o 如果状态不可用(例如,不存在或已损坏),或者保存的节点 ID 与当前节点 ID 不同,则
     生成随机时钟序列值。
 
   o 如果状态可用,但保存的时间戳晚于当前时间戳,则递增时钟序列值。
 
   o 将状态(当前时间戳、时钟序列和节点 ID)保存回稳定存储。
 
   o 释放全局锁。
 
   o 根据第 4.2.2 节中的步骤,从当前时间戳、时钟序列和节点 ID 值格式化 UUID。
 
   如果 UUD 不需要频繁生成,则上述算法可能完全足够。 但是,对于更高的性能要求,基本算法
   的问题包括:
 
   o 每次从稳定存储读取状态的效率很低。
 
   o 系统时钟的分辨率不能为 100 纳秒。
 
   o 每次将状态写入稳定存储是低效的。
 
   o 跨进程边界共享状态可能效率低下。
 
   通过对读取和写入状态和读取时钟的函数进行局部改进,可以以模块化方式解决每个问题。
   我们将在以下各节中依次讨论它们。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.1.1.  Reading Stable Storage
 
   The state only needs to be read from stable storage once at boot   time, if it is read into a system-wide shared volatile store (and   updated whenever the stable store is updated).
 
   If an implementation does not have any stable store available, then   it can always say that the values were unavailable.  This is the   least desirable implementation because it will increase the frequency   of creation of new clock sequence numbers, which increases the   probability of duplicates.
 
   If the node ID can never change (e.g., the net card is inseparable   from the system), or if any change also reinitializes the clock   sequence to a random value, then instead of keeping it in stable   store, the current node ID may be returned.
 
4.2.1.2.  System Clock Resolution
 
   The timestamp is generated from the system time, whose resolution may   be less than the resolution of the UUID timestamp.
 
   If UUIDs do not need to be frequently generated, the timestamp can   simply be the system time multiplied by the number of 100-nanosecond   intervals per system time interval.
 
   If a system overruns the generator by requesting too many UUIDs   within a single system time interval, the UUID service MUST either   return an error, or stall the UUID generator until the system clock   catches up.
 
   A high resolution timestamp can be simulated by keeping a count of   the number of UUIDs that have been generated with the same value of   the system time, and using it to construct the low order bits of the   timestamp.  The count will range between zero and the number of   100-nanosecond intervals per system time interval.
 
   Note: If the processors overrun the UUID generation frequently,   additional node identifiers can be allocated to the system, which   will permit higher speed allocation by making multiple UUIDs   potentially available for each time stamp value.
 
4.2.1.3.  Writing Stable Storage
 
   The state does not always need to be written to stable store every   time a UUID is generated.  The timestamp in the stable store can be   periodically set to a value larger than any yet used in a UUID.  As   long as the generated UUIDs have timestamps less than that value, and</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   the clock sequence and node ID remain unchanged, only the shared   volatile copy of the state needs to be updated.  Furthermore, if the   timestamp value in stable store is in the future by less than the   typical time it takes the system to reboot, a crash will not cause a   reinitialization of the clock sequence.
 
4.2.1.4.  Sharing State Across Processes
 
   If it is too expensive to access shared state each time a UUID is   generated, then the system-wide generator can be implemented to   allocate a block of time stamps each time it is called; a per-   process generator can allocate from that block until it is exhausted.
 
4.2.2.  Generation Details
 
   Version 1 UUIDs are generated according to the following algorithm:
 
   o  Determine the values for the UTC-based timestamp and clock      sequence to be used in the UUID, as described in Section 4.2.1.
 
   o  For the purposes of this algorithm, consider the timestamp to be a      60-bit unsigned integer and the clock sequence to be a 14-bit      unsigned integer.  Sequentially number the bits in a field,      starting with zero for the least significant bit.
 
   o  Set the time_low field equal to the least significant 32 bits      (bits zero through 31) of the timestamp in the same order of      significance.
 
   o  Set the time_mid field equal to bits 32 through 47 from the      timestamp in the same order of significance.
 
   o  Set the 12 least significant bits (bits zero through 11) of the      time_hi_and_version field equal to bits 48 through 59 from the      timestamp in the same order of significance.
 
   o  Set the four most significant bits (bits 12 through 15) of the      time_hi_and_version field to the 4-bit version number      corresponding to the UUID version being created, as shown in the      table above.
 
   o  Set the clock_seq_low field to the eight least significant bits      (bits zero through 7) of the clock sequence in the same order of      significance.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   o  Set the 6 least significant bits (bits zero through 5) of the      clock_seq_hi_and_reserved field to the 6 most significant bits      (bits 8 through 13) of the clock sequence in the same order of      significance.
 
   o  Set the two most significant bits (bits 6 and 7) of the      clock_seq_hi_and_reserved to zero and one, respectively.
 
   o  Set the node field to the 48-bit IEEE address in the same order of      significance as the address.
 
4.3.  Algorithm for Creating a Name-Based UUID
 
   The version 3 or 5 UUID is meant for generating UUIDs from "names"   that are drawn from, and unique within, some "name space".  The   concept of name and name space should be broadly construed, and not   limited to textual names.  For example, some name spaces are the   domain name system, URLs, ISO Object IDs (OIDs), X.500 Distinguished   Names (DNs), and reserved words in a programming language.  The   mechanisms or conventions used for allocating names and ensuring   their uniqueness within their name spaces are beyond the scope of   this specification.
 
   The requirements for these types of UUIDs are as follows:
 
   o  The UUIDs generated at different times from the same name in the      same namespace MUST be equal.
 
   o  The UUIDs generated from two different names in the same namespace      should be different (with very high probability).
 
   o  The UUIDs generated from the same name in two different namespaces      should be different with (very high probability).
 
   o  If two UUIDs that were generated from names are equal, then they      were generated from the same name in the same namespace (with very      high probability).
 
   The algorithm for generating a UUID from a name and a name space are   as follows:
 
   o  Allocate a UUID to use as a "name space ID" for all UUIDs      generated from names in that name space; see Appendix C for some      pre-defined values.
 
   o  Choose either MD5 [4] or SHA-1 [8] as the hash algorithm; If      backward compatibility is not an issue, SHA-1 is preferred.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   o  Convert the name to a canonical sequence of octets (as defined by      the standards or conventions of its name space); put the name      space ID in network byte order.
 
   o  Compute the hash of the name space ID concatenated with the name.
 
   o  Set octets zero through 3 of the time_low field to octets zero      through 3 of the hash.
 
   o  Set octets zero and one of the time_mid field to octets 4 and 5 of      the hash.
 
   o  Set octets zero and one of the time_hi_and_version field to octets      6 and 7 of the hash.
 
   o  Set the four most significant bits (bits 12 through 15) of the      time_hi_and_version field to the appropriate 4-bit version number      from Section 4.1.3.
 
   o  Set the clock_seq_hi_and_reserved field to octet 8 of the hash.
 
   o  Set the two most significant bits (bits 6 and 7) of the      clock_seq_hi_and_reserved to zero and one, respectively.
 
   o  Set the clock_seq_low field to octet 9 of the hash.
 
   o  Set octets zero through five of the node field to octets 10      through 15 of the hash.
 
   o  Convert the resulting UUID to local byte order.
 
4.4.  Algorithms for Creating a UUID from Truly Random or
      Pseudo-Random Numbers
 
   The version 4 UUID is meant for generating UUIDs from truly-random or   pseudo-random numbers.
 
   The algorithm is as follows:
 
   o  Set the two most significant bits (bits 6 and 7) of the      clock_seq_hi_and_reserved to zero and one, respectively.
 
   o  Set the four most significant bits (bits 12 through 15) of the      time_hi_and_version field to the 4-bit version number from      Section 4.1.3.
 
   o  Set all the other bits to randomly (or pseudo-randomly) chosen      values.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   See Section 4.5 for a discussion on random numbers.
 
4.5.  Node IDs that Do Not Identify the Host
 
   This section describes how to generate a version 1 UUID if an IEEE   802 address is not available, or its use is not desired.
 
   One approach is to contact the IEEE and get a separate block of   addresses.  At the time of writing, the application could be found at   <http: standards.ieee.org="" regauth="" oui="" pilot-ind.html="">, and the cost   was US$550.
 
   A better solution is to obtain a 47-bit cryptographic quality random   number and use it as the low 47 bits of the node ID, with the least   significant bit of the first octet of the node ID set to one.  This   bit is the unicast/multicast bit, which will never be set in IEEE 802   addresses obtained from network cards.  Hence, there can never be a   conflict between UUIDs generated by machines with and without network   cards.  (Recall that the IEEE 802 spec talks about transmission   order, which is the opposite of the in-memory representation that is   discussed in this document.)
 
   For compatibility with earlier specifications, note that this   document uses the unicast/multicast bit, instead of the arguably more   correct local/global bit.
 
   Advice on generating cryptographic-quality random numbers can be   found in RFC1750 [5].
 
   In addition, items such as the computer's name and the name of the   operating system, while not strictly speaking random, will help   differentiate the results from those obtained by other systems.
 
   The exact algorithm to generate a node ID using these data is system   specific, because both the data available and the functions to obtain   them are often very system specific.  A generic approach, however, is   to accumulate as many sources as possible into a buffer, use a   message digest such as MD5 [4] or SHA-1 [8], take an arbitrary 6   bytes from the hash value, and set the multicast bit as described   above.
 
5.  Community Considerations
 
   The use of UUIDs is extremely pervasive in computing.  They comprise   the core identifier infrastructure for many operating systems   (Microsoft Windows) and applications (the Mozilla browser) and in   many cases, become exposed to the Web in many non-standard ways.</http:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   This specification attempts to standardize that practice as openly as   possible and in a way that attempts to benefit the entire Internet.
 
6.  Security Considerations
 
   Do not assume that UUIDs are hard to guess; they should not be used   as security capabilities (identifiers whose mere possession grants   access), for example.  A predictable random number source will   exacerbate the situation.
 
   Do not assume that it is easy to determine if a UUID has been   slightly transposed in order to redirect a reference to another   object.  Humans do not have the ability to easily check the integrity   of a UUID by simply glancing at it.
 
   Distributed applications generating UUIDs at a variety of hosts must   be willing to rely on the random number source at all hosts.  If this   is not feasible, the namespace variant should be used.
 
7.  Acknowledgments
 
   This document draws heavily on the OSF DCE specification for UUIDs.   Ted Ts'o provided helpful comments, especially on the byte ordering   section which we mostly plagiarized from a proposed wording he   supplied (all errors in that section are our responsibility,   however).
 
   We are also grateful to the careful reading and bit-twiddling of Ralf   S. Engelschall, John Larmouth, and Paul Thorpe.  Professor Larmouth   was also invaluable in achieving coordination with ISO/IEC.
 
8.  Normative References
 
   [1]  Zahn, L., Dineen, T., and P. Leach, "Network Computing        Architecture", ISBN 0-13-611674-4, January 1990.
 
   [2]  "DCE: Remote Procedure Call", Open Group CAE Specification C309,        ISBN 1-85912-041-5, August 1994.
 
   [3]  ISO/IEC 9834-8:2004 Information Technology, "Procedures for the        operation of OSI Registration Authorities: Generation and        registration of Universally Unique Identifiers (UUIDs) and their        use as ASN.1 Object Identifier components" ITU-T Rec. X.667,        2004.
 
   [4]  Rivest, R., "The MD5 Message-Digest Algorithm ", RFC 1321, April        1992.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [5]  Eastlake, D., 3rd, Schiller, J., and S. Crocker, "Randomness        Requirements for Security", BCP 106, RFC 4086, June 2005.
 
   [6]  Moats, R., "URN Syntax", RFC 2141, May 1997.
 
   [7]  Crocker, D. and P. Overell, "Augmented BNF for Syntax        Specifications: ABNF", RFC 2234, November 1997.
 
   [8]  National Institute of Standards and Technology, "Secure Hash        Standard", FIPS PUB 180-1, April 1995,
        <http: www.itl.nist.gov="" fipspubs="" fip180-1.htm="">.</http:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
Appendix A.  Appendix A - Sample Implementation
 
   This implementation consists of 5 files: uuid.h, uuid.c, sysdep.h,   sysdep.c and utest.c.  The uuid.* files are the system independent   implementation of the UUID generation algorithms described above,   with all the optimizations described above except efficient state   sharing across processes included.  The code has been tested on Linux   (Red Hat 4.0) with GCC (2.7.2), and Windows NT 4.0 with VC++ 5.0.   The code assumes 64-bit integer support, which makes it much clearer.
 
   All the following source files should have the following copyright   notice included:
 
copyrt.h
 
/*
** Copyright (c) 1990- 1993, 1996 Open Software Foundation, Inc.
** Copyright (c) 1989 by Hewlett-Packard Company, Palo Alto, Ca. &amp;
** Digital Equipment Corporation, Maynard, Mass.
** Copyright (c) 1998 Microsoft.
** To anyone who acknowledges that this file is provided "AS IS"
** without any express or implied warranty: permission to use, copy,
** modify, and distribute this file for any purpose is hereby
** granted without fee, provided that the above copyright notices and
** this notice appears in all source code copies, and that none of
** the names of Open Software Foundation, Inc., Hewlett-Packard
** Company, Microsoft, or Digital Equipment Corporation be used in
** advertising or publicity pertaining to distribution of the software
** without specific, written prior permission. Neither Open Software
** Foundation, Inc., Hewlett-Packard Company, Microsoft, nor Digital
** Equipment Corporation makes any representations about the
** suitability of this software for any purpose.
*/
 

uuid.h
 
#include "copyrt.h"
#undef uuid_t
typedef struct {
    unsigned32  time_low;
    unsigned16  time_mid;
    unsigned16  time_hi_and_version;
    unsigned8   clock_seq_hi_and_reserved;
    unsigned8   clock_seq_low;
    byte        node[6];
} uuid_t;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
/* uuid_create -- generate a UUID */
int uuid_create(uuid_t * uuid);
 
/* uuid_create_md5_from_name -- create a version 3 (MD5) UUID using a
   "name" from a "name space" */
void uuid_create_md5_from_name(
    uuid_t *uuid,         /* resulting UUID */
    uuid_t nsid,          /* UUID of the namespace */
    void *name,           /* the name from which to generate a UUID */
    int namelen           /* the length of the name */
);
 
/* uuid_create_sha1_from_name -- create a version 5 (SHA-1) UUID
   using a "name" from a "name space" */
void uuid_create_sha1_from_name(
 
    uuid_t *uuid,         /* resulting UUID */
    uuid_t nsid,          /* UUID of the namespace */
    void *name,           /* the name from which to generate a UUID */    int namelen           /* the length of the name */
);
 
/* uuid_compare --  Compare two UUID's "lexically" and return
        -1   u1 is lexically before u2
         0   u1 is equal to u2
         1   u1 is lexically after u2
   Note that lexical ordering is not temporal ordering!
*/
int uuid_compare(uuid_t *u1, uuid_t *u2);
 

uuid.c
 
#include "copyrt.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "sysdep.h"
#include "uuid.h"
 
/* various forward declarations */
static int read_state(unsigned16 *clockseq, uuid_time_t *timestamp,
    uuid_node_t *node);
static void write_state(unsigned16 clockseq, uuid_time_t timestamp,
    uuid_node_t node);
static void format_uuid_v1(uuid_t *uuid, unsigned16 clockseq,
    uuid_time_t timestamp, uuid_node_t node);</time.h></stdlib.h></stdio.h></string.h></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
static void format_uuid_v3or5(uuid_t *uuid, unsigned char hash[16],
    int v);
static void get_current_time(uuid_time_t *timestamp);
static unsigned16 true_random(void);
 
/* uuid_create -- generator a UUID */
int uuid_create(uuid_t *uuid)
{
     uuid_time_t timestamp, last_time;
     unsigned16 clockseq;
     uuid_node_t node;
     uuid_node_t last_node;
     int f;
 
     /* acquire system-wide lock so we're alone */
     LOCK;
     /* get time, node ID, saved state from non-volatile storage */     get_current_time(×tamp);
     get_ieee_node_identifier(&amp;node);
     f = read_state(&amp;clockseq, &amp;last_time, &amp;last_node);
 
     /* if no NV state, or if clock went backwards, or node ID        changed (e.g., new network card) change clockseq */
     if (!f || memcmp(&amp;node, &amp;last_node, sizeof node))
         clockseq = true_random();
     else if (timestamp &lt; last_time)
         clockseq++;
 
     /* save the state for next time */
     write_state(clockseq, timestamp, node);
 
     UNLOCK;
 
     /* stuff fields into the UUID */
     format_uuid_v1(uuid, clockseq, timestamp, node);     return 1;
}
 
/* format_uuid_v1 -- make a UUID from the timestamp, clockseq,
                     and node ID */
void format_uuid_v1(uuid_t* uuid, unsigned16 clock_seq,
                    uuid_time_t timestamp, uuid_node_t node)
{
    /* Construct a version 1 uuid with the information we've gathered
       plus a few constants. */
    uuid-&gt;time_low = (unsigned long)(timestamp &amp; 0xFFFFFFFF);
    uuid-&gt;time_mid = (unsigned short)((timestamp &gt;&gt; 32) &amp; 0xFFFF);
    uuid-&gt;time_hi_and_version =</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
        (unsigned short)((timestamp &gt;&gt; 48) &amp; 0x0FFF);
    uuid-&gt;time_hi_and_version |= (1 &lt;&lt; 12);
    uuid-&gt;clock_seq_low = clock_seq &amp; 0xFF;
    uuid-&gt;clock_seq_hi_and_reserved = (clock_seq &amp; 0x3F00) &gt;&gt; 8;    uuid-&gt;clock_seq_hi_and_reserved |= 0x80;
    memcpy(&amp;uuid-&gt;node, &amp;node, sizeof uuid-&gt;node);
}
 
/* data type for UUID generator persistent state */
typedef struct {
    uuid_time_t  ts;       /* saved timestamp */
    uuid_node_t  node;     /* saved node ID */
    unsigned16   cs;       /* saved clock sequence */
} uuid_state;
 
static uuid_state st;
 
/* read_state -- read UUID generator state from non-volatile store */
int read_state(unsigned16 *clockseq, uuid_time_t *timestamp,
               uuid_node_t *node)
{
    static int inited = 0;
    FILE *fp;
 
    /* only need to read state once per boot */
    if (!inited) {
        fp = fopen("state", "rb");
        if (fp == NULL)
            return 0;
        fread(&amp;st, sizeof st, 1, fp);
        fclose(fp);
        inited = 1;
    }
    *clockseq = st.cs;
    *timestamp = st.ts;
    *node = st.node;
    return 1;
}
 
/* write_state -- save UUID generator state back to non-volatile
   storage */
void write_state(unsigned16 clockseq, uuid_time_t timestamp,
                 uuid_node_t node)
{
    static int inited = 0;
    static uuid_time_t next_save;
    FILE* fp;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
    if (!inited) {
        next_save = timestamp;
        inited = 1;
    }
 
    /* always save state to volatile shared state */
    st.cs = clockseq;
    st.ts = timestamp;
    st.node = node;
    if (timestamp &gt;= next_save) {
        fp = fopen("state", "wb");
        fwrite(&amp;st, sizeof st, 1, fp);
        fclose(fp);
        /* schedule next save for 10 seconds from now */
        next_save = timestamp + (10 * 10 * 1000 * 1000);
    }
}
 
/* get-current_time -- get time as 60-bit 100ns ticks since UUID epoch.
   Compensate for the fact that real clock resolution is
   less than 100ns. */
void get_current_time(uuid_time_t *timestamp)
{
    static int inited = 0;
    static uuid_time_t time_last;
    static unsigned16 uuids_this_tick;
    uuid_time_t time_now;
 
    if (!inited) {
        get_system_time(&amp;time_now);
        uuids_this_tick = UUIDS_PER_TICK;
        inited = 1;
    }
 
    for ( ; ; ) {
        get_system_time(&amp;time_now);
 
        /* if clock reading changed since last UUID generated, */        if (time_last != time_now) {
            /* reset count of uuids gen'd with this clock reading */            uuids_this_tick = 0;
            time_last = time_now;
            break;
        }
        if (uuids_this_tick &lt; UUIDS_PER_TICK) {
            uuids_this_tick++;
            break;
        }</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
        /* going too fast for our clock; spin */
    }
    /* add the count of uuids to low order bits of the clock reading */    *timestamp = time_now + uuids_this_tick;
}
 
/* true_random -- generate a crypto-quality random number.
   **This sample doesn't do that.** */
static unsigned16 true_random(void)
{
    static int inited = 0;
    uuid_time_t time_now;
 
    if (!inited) {
        get_system_time(&amp;time_now);
        time_now = time_now / UUIDS_PER_TICK;
        srand((unsigned int)
               (((time_now &gt;&gt; 32) ^ time_now) &amp; 0xffffffff));
        inited = 1;
    }
 
    return rand();
}
 
/* uuid_create_md5_from_name -- create a version 3 (MD5) UUID using a
   "name" from a "name space" */
void uuid_create_md5_from_name(uuid_t *uuid, uuid_t nsid, void *name,
                               int namelen)
{
    MD5_CTX c;
    unsigned char hash[16];
    uuid_t net_nsid;
 
    /* put name space ID in network byte order so it hashes the same       no matter what endian machine we're on */
    net_nsid = nsid;
    net_nsid.time_low = htonl(net_nsid.time_low);
    net_nsid.time_mid = htons(net_nsid.time_mid);
    net_nsid.time_hi_and_version = htons(net_nsid.time_hi_and_version);
 
    MD5Init(&amp;c);
    MD5Update(&amp;c, &amp;net_nsid, sizeof net_nsid);
    MD5Update(&amp;c, name, namelen);
    MD5Final(hash, &amp;c);
 
    /* the hash is in network byte order at this point */
    format_uuid_v3or5(uuid, hash, 3);
}</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
void uuid_create_sha1_from_name(uuid_t *uuid, uuid_t nsid, void *name,
                                int namelen)
{
    SHA_CTX c;
    unsigned char hash[20];
    uuid_t net_nsid;
 
    /* put name space ID in network byte order so it hashes the same       no matter what endian machine we're on */
    net_nsid = nsid;
    net_nsid.time_low = htonl(net_nsid.time_low);
    net_nsid.time_mid = htons(net_nsid.time_mid);
    net_nsid.time_hi_and_version = htons(net_nsid.time_hi_and_version);
 
    SHA1_Init(&amp;c);
    SHA1_Update(&amp;c, &amp;net_nsid, sizeof net_nsid);
    SHA1_Update(&amp;c, name, namelen);
    SHA1_Final(hash, &amp;c);
 
    /* the hash is in network byte order at this point */
    format_uuid_v3or5(uuid, hash, 5);
}
 
/* format_uuid_v3or5 -- make a UUID from a (pseudo)random 128-bit
   number */
void format_uuid_v3or5(uuid_t *uuid, unsigned char hash[16], int v)
{
    /* convert UUID to local byte order */
    memcpy(uuid, hash, sizeof *uuid);
    uuid-&gt;time_low = ntohl(uuid-&gt;time_low);
    uuid-&gt;time_mid = ntohs(uuid-&gt;time_mid);
    uuid-&gt;time_hi_and_version = ntohs(uuid-&gt;time_hi_and_version);
 
    /* put in the variant and version bits */
    uuid-&gt;time_hi_and_version &amp;= 0x0FFF;
    uuid-&gt;time_hi_and_version |= (v &lt;&lt; 12);
    uuid-&gt;clock_seq_hi_and_reserved &amp;= 0x3F;
    uuid-&gt;clock_seq_hi_and_reserved |= 0x80;
}
 
/* uuid_compare --  Compare two UUID's "lexically" and return */
#define CHECK(f1, f2) if (f1 != f2) return f1 &lt; f2 ? -1 : 1;
int uuid_compare(uuid_t *u1, uuid_t *u2)
{
    int i;
 
    CHECK(u1-&gt;time_low, u2-&gt;time_low);
    CHECK(u1-&gt;time_mid, u2-&gt;time_mid);</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
    CHECK(u1-&gt;time_hi_and_version, u2-&gt;time_hi_and_version);    CHECK(u1-&gt;clock_seq_hi_and_reserved, u2-&gt;clock_seq_hi_and_reserved);    CHECK(u1-&gt;clock_seq_low, u2-&gt;clock_seq_low)
    for (i = 0; i &lt; 6; i++) {
        if (u1-&gt;node[i] &lt; u2-&gt;node[i])
            return -1;
        if (u1-&gt;node[i] &gt; u2-&gt;node[i])
            return 1;
    }
    return 0;
}
#undef CHECK
 

sysdep.h
 
#include "copyrt.h"
/* remove the following define if you aren't running WIN32 */
#define WININC 0
 
#ifdef WININC
#include <windows.h>
#else
#include <sys types.h="">
#include <sys time.h="">
#include <sys sysinfo.h="">
#endif
 
#include "global.h"
/* change to point to where MD5 .h's live; RFC 1321 has sample
   implementation */
#include "md5.h"
 
/* set the following to the number of 100ns ticks of the actual
   resolution of your system's clock */
#define UUIDS_PER_TICK 1024
 
/* Set the following to a calls to get and release a global lock */
#define LOCK
#define UNLOCK
 
typedef unsigned long   unsigned32;
typedef unsigned short  unsigned16;
typedef unsigned char   unsigned8;
typedef unsigned char   byte;
 
/* Set this to what your compiler uses for 64-bit data type */
#ifdef WININC</sys></sys></sys></windows.h></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
#define unsigned64_t unsigned __int64
#define I64(C) C
#else
#define unsigned64_t unsigned long long
#define I64(C) C##LL
#endif
 
typedef unsigned64_t uuid_time_t;
typedef struct {
    char nodeID[6];
} uuid_node_t;
 
void get_ieee_node_identifier(uuid_node_t *node);
void get_system_time(uuid_time_t *uuid_time);
void get_random_info(char seed[16]);
 

sysdep.c
 
#include "copyrt.h"
#include <stdio.h>
#include "sysdep.h"
 
/* system dependent call to get IEEE node ID.
   This sample implementation generates a random node ID. */
void get_ieee_node_identifier(uuid_node_t *node)
{
    static inited = 0;
    static uuid_node_t saved_node;
    char seed[16];
    FILE *fp;
 
    if (!inited) {
        fp = fopen("nodeid", "rb");
        if (fp) {
            fread(&amp;saved_node, sizeof saved_node, 1, fp);
            fclose(fp);
        }
        else {
            get_random_info(seed);
            seed[0] |= 0x01;
            memcpy(&amp;saved_node, seed, sizeof saved_node);
            fp = fopen("nodeid", "wb");
            if (fp) {
                fwrite(&amp;saved_node, sizeof saved_node, 1, fp);
                fclose(fp);
            }
        }</stdio.h></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
        inited = 1;
    }
 
    *node = saved_node;
}
 
/* system dependent call to get the current system time. Returned as
   100ns ticks since UUID epoch, but resolution may be less than
   100ns. */
#ifdef _WINDOWS_
 
void get_system_time(uuid_time_t *uuid_time)
{
    ULARGE_INTEGER time;
 
    /* NT keeps time in FILETIME format which is 100ns ticks since       Jan 1, 1601. UUIDs use time in 100ns ticks since Oct 15, 1582.       The difference is 17 Days in Oct + 30 (Nov) + 31 (Dec)
       + 18 years and 5 leap days. */
    GetSystemTimeAsFileTime((FILETIME *)&amp;time);
    time.QuadPart +=
 
          (unsigned __int64) (1000*1000*10)       // seconds
        * (unsigned __int64) (60 * 60 * 24)       // days
        * (unsigned __int64) (17+30+31+365*18+5); // # of days    *uuid_time = time.QuadPart;
}
 
/* Sample code, not for use in production; see RFC 1750 */
void get_random_info(char seed[16])
{
    MD5_CTX c;
    struct {
        MEMORYSTATUS m;
        SYSTEM_INFO s;
        FILETIME t;
        LARGE_INTEGER pc;
        DWORD tc;
        DWORD l;
        char hostname[MAX_COMPUTERNAME_LENGTH + 1];
    } r;
 
    MD5Init(&amp;c);
    GlobalMemoryStatus(&amp;r.m);
    GetSystemInfo(&amp;r.s);
    GetSystemTimeAsFileTime(&amp;r.t);
    QueryPerformanceCounter(&amp;r.pc);
    r.tc = GetTickCount();</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
    r.l = MAX_COMPUTERNAME_LENGTH + 1;
    GetComputerName(r.hostname, &amp;r.l);
    MD5Update(&amp;c, &amp;r, sizeof r);
    MD5Final(seed, &amp;c);
}
 
#else
 
void get_system_time(uuid_time_t *uuid_time)
{
    struct timeval tp;
 
    gettimeofday(&amp;tp, (struct timezone *)0);
 
    /* Offset between UUID formatted times and Unix formatted times.       UUID UTC base time is October 15, 1582.
       Unix base time is January 1, 1970.*/
    *uuid_time = ((unsigned64)tp.tv_sec * 10000000)
        + ((unsigned64)tp.tv_usec * 10)
        + I64(0x01B21DD213814000);
}
 
/* Sample code, not for use in production; see RFC 1750 */
void get_random_info(char seed[16])
{
    MD5_CTX c;
    struct {
        struct sysinfo s;
        struct timeval t;
        char hostname[257];
    } r;
 
    MD5Init(&amp;c);
    sysinfo(&amp;r.s);
    gettimeofday(&amp;r.t, (struct timezone *)0);
    gethostname(r.hostname, 256);
    MD5Update(&amp;c, &amp;r, sizeof r);
    MD5Final(seed, &amp;c);
}
 
#endif
 
utest.c
 
#include "copyrt.h"
#include "sysdep.h"
#include <stdio.h>
#include "uuid.h"</stdio.h></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
uuid_t NameSpace_DNS = { /* 6ba7b810-9dad-11d1-80b4-00c04fd430c8 */
    0x6ba7b810,
    0x9dad,
    0x11d1,
    0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8
};
 
/* puid -- print a UUID */
void puid(uuid_t u)
{
    int i;
 
    printf("%8.8x-%4.4x-%4.4x-%2.2x%2.2x-", u.time_low, u.time_mid,    u.time_hi_and_version, u.clock_seq_hi_and_reserved,    u.clock_seq_low);
    for (i = 0; i &lt; 6; i++)
        printf("%2.2x", u.node[i]);
    printf("\n");
}
 
/* Simple driver for UUID generator */
void main(int argc, char **argv)
{
    uuid_t u;
    int f;
 
    uuid_create(&amp;u);
    printf("uuid_create(): "); puid(u);
 
    f = uuid_compare(&amp;u, &amp;u);
    printf("uuid_compare(u,u): %d\n", f);     /* should be 0 */    f = uuid_compare(&amp;u, &amp;NameSpace_DNS);
    printf("uuid_compare(u, NameSpace_DNS): %d\n", f); /* s.b. 1 */    f = uuid_compare(&amp;NameSpace_DNS, &amp;u);
    printf("uuid_compare(NameSpace_DNS, u): %d\n", f); /* s.b. -1 */    uuid_create_md5_from_name(&amp;u, NameSpace_DNS, "www.widgets.com", 15);    printf("uuid_create_md5_from_name(): "); puid(u);}
 
Appendix B.  Appendix B - Sample Output of utest
 
     uuid_create(): 7d444840-9dc0-11d1-b245-5ffdce74fad2     uuid_compare(u,u): 0
     uuid_compare(u, NameSpace_DNS): 1
     uuid_compare(NameSpace_DNS, u): -1
     uuid_create_md5_from_name(): e902893a-9d22-3c7e-a7b8-d6e313b71d9f</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
Appendix C.  Appendix C - Some Name Space IDs
 
   This appendix lists the name space IDs for some potentially   interesting name spaces, as initialized C structures and in the   string representation defined above.
 
   /* Name string is a fully-qualified domain name */
   uuid_t NameSpace_DNS = { /* 6ba7b810-9dad-11d1-80b4-00c04fd430c8 */       0x6ba7b810,
       0x9dad,
       0x11d1,
       0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8
   };
 
   /* Name string is a URL */
   uuid_t NameSpace_URL = { /* 6ba7b811-9dad-11d1-80b4-00c04fd430c8 */       0x6ba7b811,
       0x9dad,
       0x11d1,
       0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8
   };
 
   /* Name string is an ISO OID */
   uuid_t NameSpace_OID = { /* 6ba7b812-9dad-11d1-80b4-00c04fd430c8 */       0x6ba7b812,
       0x9dad,
       0x11d1,
       0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8
   };
 
   /* Name string is an X.500 DN (in DER or a text output format) */   uuid_t NameSpace_X500 = { /* 6ba7b814-9dad-11d1-80b4-00c04fd430c8 */       0x6ba7b814,
       0x9dad,
       0x11d1,
       0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8
   };</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
Authors' Addresses
 
   Paul J. Leach
   Microsoft
   1 Microsoft Way
   Redmond, WA  98052
   US
 
   Phone: +1 425-882-8080
   EMail: paulle@microsoft.com
 

   Michael Mealling
   Refactored Networks, LLC
   1635 Old Hwy 41
   Suite 112, Box 138
   Kennesaw, GA 30152
   US
 
   Phone: +1-678-581-9656
   EMail: michael@refactored-networks.com
   URI: http://www.refactored-networks.com
 

   Rich Salz
   DataPower Technology, Inc.
   1 Alewife Center
   Cambridge, MA  02142
   US
 
   Phone: +1 617-864-0455
   EMail: rsalz@datapower.com
   URI:   http://www.datapower.com</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
Full Copyright Statement
 
   Copyright (C) The Internet Society (2005).
 
   This document is subject to the rights, licenses and restrictions   contained in BCP 78, and except as set forth therein, the authors   retain all their rights.
 
   This document and the information contained herein are provided on an   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
 
Intellectual Property
 
   The IETF takes no position regarding the validity or scope of any   Intellectual Property Rights or other rights that might be claimed to   pertain to the implementation or use of the technology described in   this document or the extent to which any license under such rights   might or might not be available; nor does it represent that it has   made any independent effort to identify any such rights.  Information   on the procedures with respect to rights in RFC documents can be   found in BCP 78 and BCP 79.
 
   Copies of IPR disclosures made to the IETF Secretariat and any   assurances of licenses to be made available, or the result of an   attempt made to obtain a general license or permission for the use of   such proprietary rights by implementers or users of this   specification can be obtained from the IETF on-line IPR repository at   http://www.ietf.org/ipr.
 
   The IETF invites any interested party to bring to its attention any   copyrights, patents or patent applications, or other proprietary   rights that may cover technology that may be required to implement   this standard.  Please address the information to the IETF at ietf-   ipr@ietf.org.
 
Acknowledgement
 
   Funding for the RFC Editor function is currently provided by the   Internet Society.
 

 

 

 
Leach, et al.               Standards Track                    [Page 32]</pre><br>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.129c, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>
