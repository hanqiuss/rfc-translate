<div class="content" style="float: left; margin: 0px 30%; width: 579px; font-size: 10pt;">
   <div style="height: 13px;">
      <div onmouseover="this.style.cursor='pointer';" onclick="showElem('legend');" onmouseout="hideElem('legend')" style="height: 6px; position: absolute; cursor: pointer;" class="pre noprint docinfo bgblue" title="Click for colour legend.">                                                                        </div>
      <div id="legend" class="docinfo noprint pre legend" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; " onmouseover="showElem('legend');" onmouseout="hideElem('legend');">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="../html/" title="Document search and retrieval page">Docs</a>] [<a href="/rfc/rfc6749.txt" title="Plaintext version of this document">txt</a>|<a href="/pdf/rfc6749" title="PDF version of this document">pdf</a>] [<a href="./draft-ietf-oauth-v2" title="draft-ietf-oauth-v2">draft-ietf-oaut...</a>] [<a href="https://datatracker.ietf.org/doc/rfc6749" title="IESG Datatracker information for this document">Tracker</a>] [<a href="/rfcdiff?difftype=--hwdiff&amp;url2=rfc6749" title="Inline diff (wdiff)">Diff1</a>] [<a href="/rfcdiff?url2=rfc6749" title="Side-by-side diff">Diff2</a>] [<a href="https://datatracker.ietf.org/ipr/search/?rfc=6749&amp;submit=rfc" title="IPR disclosures related to this document">IPR</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=6749">Errata</a>]</span><br>
<span class="pre noprint docinfo">                                                                        </span><br>
<span class="pre noprint docinfo">Updated by: <a href="./rfc8252">8252</a>                                       PROPOSED STANDARD</span><br>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br>
<pre style="height: 780px; white-space: pre-wrap;">Internet Engineering Task Force (IETF)                     D. Hardt, Ed.
Request for Comments: 6749                                     Microsoft
Obsoletes: 5849                                             October 2012
Category: Standards Track
ISSN: 2070-1721
 

                           OAuth 2.0 授权框架
 
摘要
 
   OAuth 2.0 授权框架允许第三方应用程序代表资源所有者通过协调资源所有者和 HTTP 
   服务之间的审批交互,或者允许第三方申请,以取得自己代表的访问权限。 此规范替换并
   淘汰了 RFC 5849 中描述的 OAuth 1.0 协议。
 
本备忘录的状态
 
   这是一个互联网标准跟踪文档。
 
   本文档是互联网工程任务组 (IETF) 的产品。 它代表了IETF社区的共识。 它已接受公众
   审查,并经互联网工程指导小组批准出版。 有关互联网标准的更多信息,请访问 RFC 5741
   第 2 节。
 
   有关本文档的当前状态、任何勘误表以及如何提供有关文档的反馈的信息,请查阅以下信息:
   http://www.rfc-editor.org/info/rfc6749.
 
Copyright Notice
 
   Copyright (c) 2012 IETF Trust and the persons identified as the   document authors.  All rights reserved.
 
   This document is subject to BCP 78 and the IETF Trust's Legal   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of   publication of this document.  Please review these documents   carefully, as they describe your rights and restrictions with respect   to this document.  Code Components extracted from this document must   include Simplified BSD License text as described in Section 4.e of   the Trust Legal Provisions and are provided without warranty as   described in the Simplified BSD License.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> <pre style="font-size:8.7pt;">目录
 
   1. 介绍         ....................................................4
      1.1. 角色  ......................................................6
      1.2. 协议流        ..............................................7
      1.3. 授权授予             ........................................8
           1.3.1. 授权码             ..................................8
           1.3.2. Implicit ............................................8
           1.3.3. 资源所有者密码凭据                     .................9
           1.3.4. 客户端凭据           ..................................9
      1.4. 访问令牌      ..............................................10
      1.5. 刷新令牌       .............................................10
      1.6. TLS 版本     ...............................................12
      1.7. HTTP 重定向        .........................................12
      1.8. 互操作性          ..........................................12
      1.9. 符号约定                ....................................13
   2. 客户端注册            ............................................13
      2.1. 客户端类型     ..............................................14
      2.2. 客户端标识符        .........................................15
      2.3. 客户端身份验证          .....................................16
           2.3.1. 客户端密码       ....................................16
           2.3.2. 其他身份验证方法               .......................17
      2.4. 未注册的客户端         ......................................17
   3. 授权终端            .............................................18
      3.1. 授权终端                ....................................18
           3.1.1. 响应类型       ......................................19
           3.1.2. 重定向终端            ...............................19
      3.2. 令牌终结点      ............................................21
           3.2.1. 客户端身份验证          ..............................22
      3.3. 访问令牌作用域       ........................................23
   4. 获得授权                 ........................................23
      4.1. 授权代码授予               ..................................24
           4.1.1. 授权请求               ..............................25
           4.1.2. 授权响应                .............................26
           4.1.3. 访问令牌请求          ...............................29
           4.1.4. 访问令牌响应           ..............................30
      4.2. 隐式授予        ............................................31
           4.2.1. 授权请求               ..............................33
           4.2.2. 访问令牌响应           ..............................35
      4.3. 资源所有者密码凭据授予                      .................37
           4.3.1. 授权请求和响应                      .................39
           4.3.2. 访问令牌请求          ...............................39
           4.3.3. 访问令牌响应           ..............................40
      4.4. 客户端凭据授予            ..................................40
           4.4.1. 授权请求和响应                      .................41
           4.4.2. 访问令牌请求          ...............................41
           4.4.3. 访问令牌响应           ..............................42
      4.5. 扩展            ..........................................42
</pre>
</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;">  <pre style="font-size:8.7pt;"> 
   5. 颁发访问令牌              ........................................43
      5.1. 成功响应             .......................................43
      5.2. 错误响应        ............................................45
   6. 刷新访问令牌                 .....................................47
   7. 访问受保护资源                  ..................................48
      7.1. 访问令牌类型         ........................................49
      7.2. 错误响应        ............................................49
   8. 扩展          ..................................................50
      8.1. 定义访问令牌类型               ...............................50
      8.2. 定义新的终结点参数                  ..........................50
      8.3. 定义新的授权类型                          ....................51
      8.4. 定义新的授权终结点响应类型                              ........51
      8.5. 定义附加错误代码                   ...........................51
   9. 原生应用             ............................................52
   10. 安全注意事项              .......................................53
      10.1. 客户端身份验证          ....................................53
      10.2. 客户端模拟             .....................................54
      10.3. 访问令牌       ............................................55
      10.4. 刷新令牌        ...........................................55
      10.5. 授权码               ......................................56
      10.6. 授权码重定向 URI 操作                              ..........56
      10.7. 资源所有者密码凭据                     ......................57
      10.8. 请求保密                 ..................................58
      10.9. 确保节点真实性                   ...........................58
      10.10. 凭据-猜测攻击                  ............................58
      10.11. 网络钓鱼攻击       ........................................58
      10.12. 跨站点请求伪造               ..............................59
      10.13. 点击劫持      ............................................60
      10.14. 代码注入和输入验证                     .....................60
      10.15. 开放式重定向       ........................................60
      10.16. 滥用访问令牌在隐式流中模拟资源所有者 ..........................61
   11. IANA 注意事项 ...........................................62
      11.1. OAuth 访问令牌类型注册表             ........................62
           11.1.1. 注册模板               .............................62
      11.2. OAuth 参数注册表            ................................63
           11.2.1. 注册模板               .............................63
           11.2.2. 初始注册表内容              .........................64
      11.3. OAuth 授权终端响应类型注册表 .....66
           11.3.1. 注册模板               .............................66
           11.3.2. 初始注册表内容              .........................67
      11.4. OAuth 扩展错误注册表              ..........................67
           11.4.1. 注册模板               .............................68
   12. 参考文献    ....................................................68
      12.1. 规范参考              .....................................68
      12.2. 信息参考                ...................................70
</pre></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   附录 A. 增强的 Backus-Naur 表格 (ABNF) 语法 ..............71
     A.1.  "client_id" Syntax ........................................71
     A.2.  "client_secret" Syntax ....................................71
     A.3.  "response_type" Syntax ....................................71
     A.4.  "scope" Syntax ............................................72
     A.5.  "state" Syntax ............................................72
     A.6.  "redirect_uri" Syntax .....................................72
     A.7.  "error" Syntax ............................................72
     A.8.  "error_description" Syntax ................................72
     A.9.  "error_uri" Syntax ........................................72
     A.10. "grant_type" Syntax .......................................73
     A.11. "code" Syntax .............................................73
     A.12. "access_token" Syntax .....................................73
     A.13. "token_type" Syntax .......................................73
     A.14. "expires_in" Syntax .......................................73
     A.15. "username" Syntax .........................................73
     A.16. "password" Syntax .........................................73
     A.17. "refresh_token" Syntax ....................................74
     A.18. Endpoint Parameter Syntax .................................74
   Appendix B. Use of application/x-www-form-urlencoded Media Type ...74
   Appendix C. Acknowledgements ......................................75
 
1.  简介
 
   在传统的客户端-服务器身份验证模型中,客户端通过使用资源所有者的凭据与服务器进行身份
   验证,从而请求服务器上受访问限制的资源(受保护资源)。 为了向第三方应用程序提供对受限
   资源的访问,资源所有者与第三方共享其凭据。 这会产生几个问题和限制:
 
   o  需要第三方应用程序存储资源所有者的凭据以供将来使用,通常是明文中的密码。
 
   o  服务器需要支持密码身份验证,尽管密码固有的安全漏洞。
 
   o  第三方应用程序获得对资源所有者受保护资源的过度广泛访问,使资源所有者无法限制持续
      时间或访问有限的资源子集。
 
   o  资源所有者不能撤销对单个第三方的访问权限,而不撤销对所有第三方的访问权限,并且必
      须通过更改第三方的密码来撤销访问。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 


 
   o  任何第三方应用程序的泄露都会导致最终用户的密码和受该密码保护的所有数据泄露。
 


   OAuth 通过引入授权层并将客户端的角色与资源所有者的角色分开来解决这些问题。 在
   OAuth 中,客户端请求访问由资源所有者控制并由资源服务器托管的资源,并且发出一组与
   资源所有者不同的凭据集。
 


   客户端不是使用资源所有者的凭据访问受保护的资源,而是获取访问令牌 -- 表示特定作用
   域、生存期和其他访问属性的字符串。 访问令牌由授权服务器在资源所有者批准后颁发给
   第三方客户端。 客户端使用访问令牌访问资源服务器托管的受保护资源。
 
   

   例如,最终用户(资源所有者)可以授予打印服务(客户端)对存储在照片共享服务(资源服务器)
   中的受保护照片的打印服务(客户端)访问权限,而无需与打印服务共享她的用户名和密码。 
   相反,她直接使用照片共享服务(授权服务器)信任的服务器进行身份验证,该服务器颁发打印
   服务委派特定凭据(访问令牌)。
 


   此规范设计用于 HTTP ([RFC2616])。 在 HTTP 以外的任何协议上使用 OAuth 都已不
   在范围之内。
 
   作为信息性文档发布的 OAuth 1.0 协议 ([RFC5849]) 是小型社区努力的结果。 此标准
   跟踪规范基于 OAuth 1.0 部署体验,以及从更广泛的 IETF 社区收集的其他用例和可扩展
   性要求。 OAuth 2.0 协议与 OAuth 1.0 不向后兼容。 两个版本可能在网络上共存,
   并且实现可以选择支持这两个版本。 但是,此规范的意图是,新实现支持本文档中指定的
   OAuth 2.0,并且 OAuth 1.0 仅用于支持现有部署。 OAuth 2.0 协议与 OAuth 1.0 
   协议共享的实现详细信息非常少。 熟悉 OAuth 1.0 的实现者应接近本文档,而不对其
   结构和详细信息进行任何假设。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
1.1.  角色
 
   OAuth 定义了四个角色:
 
   资源所有者
      能够授予受保护资源的访问权限的实体。当资源所有者是人员时,它称为最终用户。
 
   资源服务器
      承载受保护资源的服务器,能够接受并使用访问令牌响应受保护的资源请求。
 
   客户端
      代表资源所有者及其授权发出受保护资源请求的应用程序。 术语"客户端"并不意味着任何
      特定的实现特征(例如,应用程序是在服务器、桌面或其他设备上执行)。
 
   授权服务器
      成功验证资源所有者并获得授权后,服务器向客户端颁发访问令牌。
 
   授权服务器和资源服务器之间的交互超出了此规范的范围。 授权服务器可能与资源服务器或
   单独的实体相同。单个授权服务器可能会颁发多个资源服务器接受的访问令牌。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
1.2.  协议流
 <pre style="font-family:新宋体;">     +--------+                               +---------------+
     |        |--(A)- Authorization Request -&gt;|               |
     |        |                               |   资源所有者  |
     |        |&lt;-(B)-- Authorization Grant ---|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(C)-- Authorization Grant --&gt;|               |
     | 客户端 |                               |   授权服务器  |
     |        |&lt;-(D)----- Access Token -------|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------&gt;|               |
     |        |                               |   资源服务器  |
     |        |&lt;-(F)--- Protected Resource ---|               |
     +--------+                               +---------------+
 </pre>
                     Figure 1: 抽象协议流
 
   图 1 所示的抽象 OAuth 2.0 流描述了四个角色之间的交互,包括以下步骤:
 
   (A) 客户端请求资源所有者的授权。 授权请求可以直接向资源所有者发出(如图所示),或者
       最好通过授权服务器作为中介间接发出。
 
   (B) 客户端收到授权Grant,该授权是表示资源所有者授权的凭据,使用本规范中定义的四种
       Grant 类型之一或使用扩展Grant类型表示。 授权Grant类型取决于客户端用于请求
       授权的方法以及授权服务器支持的类型。
 
   (C) 客户端通过与授权服务器进行身份验证并提交授权授予来请求访问令牌。
 
   (D) 授权服务器对客户端进行身份验证并验证授权授予,如果有效,则颁发访问令牌。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   (E) 客户端从资源服务器请求受保护的资源,并通过显示访问令牌进行身份验证。
 
   (F) 资源服务器验证访问令牌,如果有效,则为请求提供服务。
 
   客户端从资源所有者处获取授权Grant的首选方法是使用授权服务器作为中介,如第 4.1 节
   图 3 所示。
 




1.3.  授权 Grant
 
   授权Grant是表示客户端用于获取访问令牌的资源所有者的授权(访问其受保护资源)的凭据。
   此规范定义了四种授予类型(授权码、隐式、资源所有者密码凭据和客户端凭据)以及用于
   定义其他类型的扩展机制。
 



1.3.1.  授权码
 
   授权码是通过使用授权服务器作为客户端和资源所有者之间的中介获取的。 客户端不是直接从
   资源所有者请求授权,而是将资源所有者定向到授权服务器(通过 [RFC2616] 中定义的用户
   代理),后者又通过授权将资源所有者引导回客户端的 Code 。
 
   在使用授权码将资源所有者引导回客户端之前,授权服务器会对资源所有者进行身份验证并获得
   授权。由于资源所有者仅通过授权服务器进行身份验证,因此资源所有者的凭据永远不会与客户
   端共享。

   授权代码提供了一些重要的安全优势,例如验证客户端以及将访问令牌直接传输到客户端的
   能力,而无需通过资源所有者的用户代理传递访问令牌,并且可能将其暴露给其他人,包括资源
   所有者。
 




1.3.2.  隐式Grant
 
   隐式Grant是一种简化的授权代码流,针对使用 JavaScript 等脚本语言在浏览器中实现的
   客户端进行了优化。在隐式流中,不向客户端颁发授权代码,而是直接发出访问令牌(作为资源
   所有者授权的结果)。授予类型是隐式的,因为不颁发中间凭据(如用于获取访问令牌的授权
   码)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 






   在隐式授予流期间颁发访问令牌时,授权服务器不会对客户端进行身份验证。在某些情况下,
   可以通过用于将访问令牌传递到客户端的重定向 URI 验证客户端标识。访问令牌可能会公开
   给资源所有者或其他有权访问资源所有者的用户代理的应用程序。
 
   隐式授予可提高某些客户端(如作为浏览器内应用程序实现的客户端)的响应能力和效率,因为
   它减少了获取访问令牌所需的往返次数。但是,应权衡使用隐式授予的安全影响,例如
   第 10.3 节和第 10.16 节中所述的,尤其是在授权码授予类型可用时。
 






1.3.3.  资源所有者密码凭据
 
   资源所有者密码凭据(即用户名和密码)可以直接用作授权Grant以获取访问令牌。仅当资源
   所有者和客户端之间存在高度信任(例如,客户端是设备操作系统或高特权应用程序的一部分)
   以及其他授权Grant类型(如授权码)不可用时,才应使用凭据。
 
   即使此Grant类型需要客户端直接访问资源所有者凭据,资源所有者凭据也用于单个请求,并
   交换为访问令牌。通过使用长期存在的访问令牌或刷新令牌交换凭据,此Grant类型可以消除
   客户端存储资源所有者凭据以供将来使用的需要。
 







1.3.4.  客户端凭据
 
   当授权范围仅限于客户端控制下的受保护资源或以前与授权服务器。 客户端凭据通常用作
   授权Grant,通常当客户端代表其自身(客户端也是资源所有者)或基于以前与授权一起安排
   的授权请求访问受保护资源服务器。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
1.4.  访问令牌
 
   访问令牌是用于访问受保护资源的凭据。访问令牌是表示向客户端颁发的授权的字符串。
   字符串通常对客户端不透明。令牌表示特定访问范围和持续时间,由资源所有者授予并由资源
   服务器和授权服务器强制执行。
 
   令牌可以表示用于检索授权信息的标识符,也可以以可验证的方式自包含授权信息(即由某些
   数据和签名组成的令牌字符串)。 为了客户端使用令牌,可能需要其他超出此规范范围的身份
   验证凭据。
 
   访问令牌提供抽象层,将不同的授权构造(例如用户名和密码)替换为资源服务器理解的单个
   令牌。 此抽象允许颁发访问令牌比用于获取这些令牌的授权授予更严格,并去除资源服务器
   了解各种身份验证方法的需要。
 
   访问令牌可以具有不同的格式、结构和利用率方法(例如,加密属性),具体取决于资源服务器
   安全要求。 访问令牌属性和用于访问受保护资源的方法超出了此规范的范围,并且由配套规范
   (如 [RFC6750])定义。
 










1.5.  刷新令牌
 
   刷新令牌是用于获取访问令牌的凭据。 刷新令牌由授权服务器颁发给客户端,用于在当前访问
   令牌无效或过期时获取新的访问令牌,或获取具有相同或更窄范围的其他访问令牌(访问令牌
   可能具有更少的生存期,且权限少于资源所有者授权的权限)。 颁发刷新令牌是授权服务器
   自行决定的。 如果授权服务器发出刷新令牌,则在颁发访问令牌时(即图 1 中的步骤 (D))
   时包含刷新令牌。
 
   刷新令牌是表示资源所有者授予客户端的授权的字符串。 字符串通常对客户端不透明。 令牌
   表示用于检索授权信息的标识符。 与访问令牌不同,刷新令牌仅用于授权服务器,从不发送到
   资源服务器。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 



 <pre style="font-family:新宋体;"> 
  +--------+                                           +---------------+
  |        |--(A)------- Authorization Grant ---------&gt;|               |
  |        |                                           |               |
  |        |&lt;-(B)----------- Access Token -------------|               |
  |        |               &amp; Refresh Token             |               |
  |        |                                           |               |
  |        |                            +----------+   |               |
  |        |--(C)---- Access Token ----&gt;|          |   |               |
  |        |                            |          |   |               |
  |        |&lt;-(D)- Protected Resource --|          |   |   授权服务器  |
  | Client |                            |资源服务器|   |               |
  |        |--(E)---- Access Token ----&gt;|          |   |               |
  |        |                            |          |   |               |
  |        |&lt;-(F)- Invalid Token Error -|          |   |               |
  |        |                            +----------+   |               |
  |        |                                           |               |
  |        |--(G)----------- Refresh Token -----------&gt;|               |
  |        |                                           |               |
  |        |&lt;-(H)----------- Access Token -------------|               |
  +--------+           &amp; Optional Refresh Token        +---------------+
 </pre>
               Figure 2: 刷新过期访问令牌
 
   图 2 所示的流包括以下步骤:
 
   (A)  客户端通过使用授权服务器进行身份验证并提交授权授予来请求访问令牌。
 
   (B)  授权服务器对客户端进行身份验证并验证授权授予,如果有效,则颁发访问令牌和刷新
        令牌。
 
   (C)  客户端通过出示访问令牌向资源服务器发出受保护的资源请求。
 
   (D)  资源服务器验证访问令牌,如果有效,则为请求提供服务。
 
   (E)  步骤 (C) 和 (D) 重复,直到访问令牌过期。 如果客户端知道访问令牌已过期,它将
        跳转以执行 (G); 否则,它会发出另一个受保护的资源请求。
 
   (F)  由于访问令牌无效,资源服务器将返回无效的令牌错误。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   (G)  客户端通过使用授权服务器进行身份验证和呈现刷新令牌来请求新的访问令牌。客户端
        身份验证要求基于客户端类型和授权服务器策略。
 
   (H)  授权服务器对客户端进行身份验证并验证刷新令牌,如果有效,则颁发新的访问令牌
        (以及(可选)新的刷新令牌。
 
   步骤 (C)、(D)、(E)和 (F) 不属于本规范的范围,如第 7 节所述。
 
1.6.  TLS 版本
 
   每当此规范使用传输层安全 (TLS) 时,TLS 的适当版本(或版本)会随时间而变化,具体取决
   于广泛的部署和已知的安全漏洞。 在撰写本文时,TLS 版本 1.2 [RFC5246] 是最新版本,
   但部署基础非常有限,可能无法随时实现。 TLS 版本 1.0 [RFC2246] 是部署最广泛的
   版本,将提供最广泛的互操作性。
 
   实现可能还支持满足其安全要求的其他传输层安全机制。
 
1.7.  HTTP 重定向
 
   此规范广泛使用 HTTP 重定向,其中客户端或授权服务器将资源所有者的用户代理定向到
   另一个目标。 虽然此规范中的示例显示了 HTTP 302 状态代码的使用,但允许通过用户代理
   实现此重定向的任何其他方法,并被视为实现详细信息。
 
1.8.  互操作性
 
   OAuth 2.0 提供了一个具有明确定义的安全属性的丰富授权框架。 但是,作为具有许多可选
   组件的丰富且高度可扩展的框架,此规范本身可能会生成各种不可互操作的实现。
 
   此外,此规范还保留一些必需的组件部分或完全未定义(例如,客户端注册、授权服务器功能、
   终端发现)。 如果没有这些组件,则必须针对特定的授权服务器和资源服务器手动和专门
   配置客户端,以便互操作。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 



 
   该框架的设计明确期望,未来的工作将定义实现完全 Web 级互操作性所需的规范配置文件和
   扩展。
 
1.9.  符号规范
 
   此规范中的关键词 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" 解释如
   [RFC2119] 中所述。
 
   此规范使用增强的 Backus-Naur 形式 (ABNF) 表示法 [RFC5234]。 此外,规则 URI
   引用包含在"统一资源标识符 (URI: 通用语法][RFC3986]。
 
   某些与安全相关的术语应理解在 [RFC4949] 中定义的意义上。 这些术语包括但不限于,
   "attack", "authentication", "authorization", "certificate",
   "confidentiality", "credential", "encryption", "identity", "sign",
   "signature", "trust", "validate", and "verify".
 
   除非另有说明,否则所有协议参数名称和值都是区分大小写。
 
2.  客户端注册
 
   在启动协议之前,客户端向授权服务器注册。 客户端注册授权服务器的方式超出了此规范的
   范围,但通常涉及最终用户与 HTML 注册表单的交互。
 
   客户端注册不需要客户端和授权服务器之间的直接交互。 当授权服务器支持时,注册可以依赖
   其他方法来建立信任和获取所需的客户端属性(例如,重定向 URI、客户端类型)。 例如,注册
   可以使用自颁发或第三方颁发的断言完成,也可以由使用受信任的通道执行客户端发现的授权
   服务器完成。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   注册客户端时,客户端开发人员 SHALL:
 
   o  指定第 2.1 节中描述的客户端类型,
 
   o  提供其客户端重定向 URI,如第 3.1.2 节所述,以及
 
   o  包括授权服务器所需的任何其他信息(例如,应用程序名称、网站、描述、徽标图像、法律
      条款的接受)。
 
2.1.  客户端类型
 
   OAuth 定义了两种客户端类型,基于它们使用授权服务器进行安全身份验证的能力(即维护其
   客户端凭据的机密性的能力):
 
   保密
      能够维护其凭据机密性的客户端(例如,在安全服务器上实现的客户端,对客户端凭据的访问
      受限),或者能够使用其他方法保护客户端身份验证。
 
   公共
      无法维护其凭据机密性的客户端(例如,在资源所有者使用的设备上执行的客户端,如已安装
      的本机应用程序或基于 Web 浏览器的应用程序),并且无法保护客户端通过任何其他方式
      进行身份验证。
 
   客户端类型指定基于授权服务器的安全身份验证定义及其可接受的客户端凭据公开级别。 授权
   服务器不应对客户端类型进行假设。
 
   客户端可以实现为一组分布式组件,每个组件具有不同的客户端类型和安全上下文(例如,具有
   基于服务器的机密组件和基于公共浏览器的组件的分布式客户端)。 如果授权服务器不为此类
   客户端提供支持,或者没有提供有关其注册的指导,则客户端 SHOULD 将每个组件注册为单独
   的客户端。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   此规范是围绕以下客户端配置文件设计的:
 
   Web 应用程序
      Web 应用程序是在 Web 服务器上运行的机密客户端。 资源所有者通过在资源所有者
      使用的设备上的用户代理中呈现的 HTML 用户界面访问客户端。 客户端凭据以及颁发给
      客户端的任何访问令牌都存储在 Web 服务器上,并且不会公开资源所有者或由资源所有者
      访问。
 
   基于用户代理的应用程序
      基于用户代理的应用程序是公共客户端,其中客户端代码从 Web 服务器下载,并在资源
      所有者使用的设备上的用户代理(例如 Web 浏览器)内执行。 协议数据和凭据可供资源
      所有者轻松访问(并且经常可见)。 由于此类应用程序驻留在用户代理中,因此在请求
      授权时,它们可以无缝地使用用户代理功能。
 
   本机应用程序
      本机应用程序是在资源所有者使用的设备上安装和执行的公共客户端。资源所有者可以
      访问协议数据和凭据。假定可以提取应用程序中包含的任何客户端身份验证凭据。 
      另一方面,动态颁发的凭据(如访问令牌或刷新令牌)可以获得可接受的保护级别。 
      至少,这些凭据不受应用程序可能与之交互的恶意服务器的保护。 在某些平台上,这些
      凭据可能不受驻留在同一设备上的其他应用程序的影响。








 
2.2.  客户端标识符
 
   授权服务器向注册客户端发出客户端标识符 -- 表示客户端提供的注册信息的唯一字符串。
   客户端标识符不是机密。它向资源所有者公开,不能单独用于客户端身份验证。 客户端标识符
   对授权服务器是唯一的。
 
   此规范未定义客户端标识符字符串大小。客户端应避免对标识符大小进行假设。授权服务器
   应记录它发出的任何标识符的大小。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
2.3.  客户端身份验证
 
   如果客户端类型是机密的,则客户端和授权服务器将建立适合授权服务器安全要求的客户端身份
   验证方法。 授权服务器可以接受满足其安全要求的任何形式的客户端身份验证。
 
   机密客户端通常颁发(或建立)一组客户端凭据,用于与授权服务器进行身份验证(例如,密码、
   公钥/私钥对)。
 
   授权服务器可以与公共客户端建立客户端身份验证方法。 但是,授权服务器 MUST NOT 依赖
   公共客户端身份验证来标识客户端。
 
   客户端 MUST NOT 在每个请求中使用多个身份验证方法。
 
2.3.1.  客户端密码
 
   拥有客户端密码的客户端可以使用 [RFC2617] 中定义的 HTTP 基本身份验证方案对授权
   服务器进行身份验证。 客户端标识符使用每个附录 B 的
   "application/x-www-form-urlencoded"编码算法进行编码,编码值用作用户名;客户端
   密码使用相同的算法进行编码,并用作密码。 授权服务器必须支持 HTTP 基本身份验证方案,
   以便对已发出客户端密码的客户端进行身份验证。
 
   例如(额外的换行符仅出于显示目的):
 
     Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3
 
   或者,授权服务器可能支持使用以下参数在请求正文中包括客户端凭据:
 
   client_id
         REQUIRED.  在 2.2 节描述的注册过程中发给客户端的客户端标识符。
 
   client_secret
         REQUIRED. 客户端密钥。如果客户端密钥为空字符串,则客户端可能会省略该参数。
        </pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   不建议使用两个参数在请求正文中包括客户端凭据,并且应仅限于无法直接使用 HTTP 基本
   身份验证方案(或其他基于密码的 HTTP 身份验证方案)的客户端。 参数只能在请求正文中
   传输,并且不得包含在请求 URI 中。
 
   例如,使用正文参数刷新访问令牌的请求(仅出于显示目的使用额外的换行符):
 
     POST /token HTTP/1.1
     Host: server.example.com
     Content-Type: application/x-www-form-urlencoded
 
     grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
     &amp;client_id=s6BhdRkqt3&amp;client_secret=7Fjfp0ZBr1KtDRbnfVdmIw
 
   使用密码身份验证发送请求时,授权服务器必须要求使用 TLS,如第 1.6 节所述。
 
   由于此客户端身份验证方法涉及密码,因此授权服务器必须保护利用它的任何终结点免受暴力
   攻击。
 






2.3.2.  其他身份验证方法
 
   授权服务器可能支持任何符合其安全要求的适当 HTTP 身份验证方案。 使用其他身份验证
   方法时,授权服务器必须定义客户端标识符(注册记录)和身份验证方案之间的映射。
 


2.4.  未注册客户
 
   此规范不排除使用未注册的客户端。  但是,此类客户端的使用超出了此规范的范围,并且需要
   额外的安全分析和审查其互操作性影响。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
3.  协议终端
 
   授权过程使用两个授权服务器终端(HTTP 资源):
 
   o  授权终端 - 客户端用于通过用户代理重定向从资源所有者获得授权。
 
   o  令牌终端 - 客户端用于交换访问令牌的授权授予,通常使用客户端身份验证。
 
   以及一个客户端终端:
 
   o  重定向终端 - 授权服务器用于通过资源所有者用户代理将包含授权凭据的响应返回给
      客户端。
 
   并非所有授权授予类型都使用两个终结点。扩展授予类型可以根据需要定义其他终结点。
 
3.1.  授权终端
 
   授权终端用于与资源所有者交互并获得授权授予。授权服务器必须首先验证资源所有者的
   身份。授权服务器对资源所有者进行身份验证的方式(例如,用户名和密码登录、会话 
   Cookie)超出了本规范的范围。
 
   客户端获取授权终端位置的方法超出了此规范的范围,但该位置通常在服务文档中提供。
 
   终端 URI 可能包括一个"application/x-www-form-urlencoded"格式化(每个附录 B)
   查询组件 ([RFC3986] 第 3.4 节),在添加其他查询参数时必须保留该组件。 终结点 URI
   不得包含片段组件。
 
   由于对授权终结点的请求会导致用户身份验证和文本凭据的传输(在 HTTP 响应中),因此授权
   服务器必须在向授权人发送请求时要求使用 TLS,如第 1.6 节所述或终结点。
 
   授权服务器必须支持对授权终端使用 HTTP [GET] 方法 [RFC2616],并且可能也支持使
   用"POST" 方法。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   发送没有值的参数必须被视为从请求中省略的参数。 授权服务器必须忽略无法识别的请求
   参数。 请求和响应参数不能包含多次。
 
3.1.1.  响应类型
 
   授权终端由授权码授予类型和隐式授予类型流使用。 客户端使用以下参数通知授权服务器
   所需的授予类型:
 
   response_type
         REQUIRED.  该值必须是第 4.1.1 节所述请求授权代码的"代码"之一,第 4.2.1
         节所述请求访问令牌(隐式授予)或第 8.4 节所述的已注册扩展值。
 
   扩展响应类型可能包含空格分隔 (%x20) 的值列表,其中值的顺序并不重要(例如,响应类型
   "a b" 与"b a"相同)。 此类复合响应类型的含义由其各自的规范定义。
 
   如果授权请求缺少"response_type"参数,或者不了解响应类型,则授权服务器必须返回错误
   响应,如第 4.1.2.1 节所述。
 








3.1.2.  重定向节点
 
   完成与资源所有者的交互后,授权服务器将资源所有者的用户代理引导回客户端。 授权服务器
   将用户代理重定向到客户端的重定向节点,该节点以前在客户端注册过程中或发出授权请求时与
   授权服务器建立。
 
   重定向节点 URI 必须是由 [RFC3986] 第 4.3 节定义的绝对 URI。 节点 URI 可能
   包括一个"application/x-www-form-urlencoded"格式化(每个附录 B)查询组件
   ([RFC3986] 第 3.4 节),在添加其他查询参数时必须保留该组件。 终结点 URI 不得包含
   片段组件。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
3.1.2.1.  节点请求机密性
 
   重定向节点应要求使用 TLS,如第 1.6 节所述,当请求的响应类型为"code"或"token"时,
   或者重定向请求将导致通过开放网络传输敏感凭据时。 此规范不强制使用 TLS,因为在编写
   本文时,要求客户端部署 TLS 是许多客户端开发人员的一大障碍。 如果 TLS 不可用,授权
   服务器应在重定向之前警告资源所有者不安全的节点(例如,在授权请求期间显示消息)。
 
   缺乏 TLS 会对客户端及其授权访问的受保护资源的安全性产生严重影响。 当授权过程被
   客户端用作委派的最终用户身份验证形式(例如,第三方登录服务)时,使用传 TLS 尤为重要。
 










3.1.2.2.  注册要求
 
   授权服务器必须要求以下客户端注册其重定向节点:
 
   o  公共客户端。
 
   o  使用隐式授予类型的机密客户端。
 
   授权服务器应要求所有客户端在使用授权节点之前注册其重定向节点。
 
   授权服务器应要求客户端提供完整的重定向 URI(客户端可以使用"状态"请求参数来实现每个
   请求的自定义)。 如果无法注册完整的重定向 URI,则授权服务器应要求注册 URI 方案、
   权限和路径(允许客户端仅动态更改重定向 URI 的查询组件)请求授权时)。
 
   授权服务器可能允许客户端注册多个重定向节点。
 
   缺少重定向 URI 注册要求可以使攻击者使用授权节点作为打开的重定向器,如第 10.15 
   节所述。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
3.1.2.3.  动态配置
 
   如果已注册多个重定向 URI,或仅注册了重定向 URI 的一部分,或者没有注册重定向 URI,
   则客户端必须使用"redirect_uri" 请求在授权请求中包括重定向 URI参数。
 
   当重定向 URI 包含在授权请求中时,授权服务器必须比较和匹配接收的值与 [RFC3986] 
   第 6 节中定义的至少一个已注册的重定向 URI(或 URI 组件)进行比较和匹配,如果有任何
   重定向 URI已注册。 如果客户端注册包含完全重定向 URI,则授权服务器必须使用
   [RFC3986] 第 6.2.1 节中定义的简单字符串比较比较两个 URI。
 




3.1.2.4.  无效节点
 
   如果授权请求由于缺少、无效或不匹配的重定向 URI 而未能通过验证,则授权服务器应将错误
   通知资源所有者,并且不得自动将用户代理重定向到无效重定向 URI。
 


3.1.2.5.  节点内容
 
   将请求重定向到客户端的终结点通常会导致由用户代理处理的 HTML 文档响应。 如果 HTML
   响应直接作为重定向请求的结果提供,则 HTML 文档中包含的任何脚本都将以对重定向 URI 
   及其包含的凭据的完全访问权限执行。
 
   客户端不应在重定向节点响应中包含任何第三方脚本(例如,第三方分析、社交插件、广告网
   络)。 相反,它应该从 URI 中提取凭据,并将用户代理再次重定向到另一个终结点,而不会
   公开凭据(在 URI 或其他地方)。 如果包含第三方脚本,则客户端必须确保首先执行其自己的
   脚本(用于从 URI 中提取和删除凭据)。
 
3.2.  令牌节点
 
   客户端使用令牌节点通过呈现其授权授予或刷新令牌来获取访问令牌。 令牌终结点用于除隐式授予类型以外的每个授权授予(因为访问令牌是直接颁发的)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   客户端获取令牌节点位置的方法超出了此规范的范围,但该位置通常在服务文档中提供。
 
   节点 URI 可能包括一个 "application/x-www-form-urlencoded" 格式查询组件
   ([RFC3986] Section&nbsp;3.4),在添加其他查询参数时必须保留该组件。 节点
   URI 不得包含片段组件。
 
   由于对令牌节点的请求会导致文本凭据的传输(在 HTTP 请求和响应中),因此授权服务器必须
   在向令牌节点发送请求时使用第 1.6 节中所述的 TLS。
 
   发出访问令牌请求时,客户端必须使用 HTTP[POST] 方法。
 
   发送没有值的参数必须被视为从请求中省略的参数。 授权服务器必须忽略无法识别的请求
   参数。请求和响应参数不能包含多次。
 






3.2.1.  客户端身份验证
 
   机密客户端或其他客户端颁发的客户端凭据在向令牌节点发出请求时,必须按照第 2.3 节
   所述使用授权服务器进行身份验证。 客户端身份验证用于:
 
   o  强制将刷新令牌和授权码绑定到它们颁发给的客户端。 当授权代码通过不安全的通道传输
      到重定向终结点时,或者重定向 URI 尚未完整注册时,客户端身份验证至关重要。
 
   o  通过禁用客户端或更改其凭据从受攻击的客户端恢复,从而防止攻击者滥用被盗的刷新
      令牌。更改一组客户端凭据比吊销整个刷新令牌集要快得多。
 
   o  实现身份验证管理最佳实践,这需要定期轮换凭据。 轮换整个刷新令牌集可能具有挑战性,
      而单个客户端凭据集的轮换则要容易得多。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   客户端在将请求发送到令牌节点时可以使用"client_id"请求参数来标识自身。 在
   "authorization_code""grant_type"请求到令牌节点时,未经身份验证的客户端必须
   发送其"client_id",以防止自己无意中接受用于具有不同"client_id"的客户端的代码。
   这保护客户端免受身份验证代码的替换。 (它不为受保护的资源提供额外的安全性。）


 
3.3.  访问令牌范围
 
   授权和令牌终结点允许客户端使用"scope" 请求参数指定访问请求的范围。 反过来,授权
   服务器使用"scope"响应参数通知客户端颁发的访问令牌的范围。
 
   范围参数的值表示为空格分隔的区分大小写字符串的列表。 字符串由授权服务器定义。 如果
   值包含多个空间分隔的字符串,则其顺序并不重要,并且每个字符串都会向请求的范围添加额外
   的访问范围。
 
     scope       = scope-token *( SP scope-token )
     scope-token = 1*( %x21 / %x23-5B / %x5D-7E )
 
   授权服务器可以完全或部分地忽略客户端请求的范围,具体取决于授权服务器策略或资源所有者
   的说明。 如果颁发的访问令牌范围与客户端请求的访问令牌范围不同,则授权服务器必须包含
   "scope" 响应参数,以通知客户端授予的实际作用域。
 
   如果客户端在请求授权时省略了作用域参数,则授权服务器必须使用预定义的默认值处理请求,
   或者使指示无效作用域的请求失败。 授权服务器应记录其范围要求和默认值(如果已定义)。
 










4.  获得授权
 
   要请求访问令牌,客户端将从资源所有者获取授权。 授权以授权Grant的形式表示,客户端
   使用授权请求访问令牌。 OAuth 定义了四种授予类型:授权码、隐式、资源所有者密码
   凭据和客户端凭据。 它还提供了用于定义其他授予类型的扩展机制。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.1.  授权码 Grant
 
   授权码授予类型用于获取访问令牌和刷新令牌,并针对机密客户端进行了优化。由于这是一个
   基于重定向的流,客户端必须能够与资源所有者的用户代理(通常是 Web 浏览器)进行交互,
   并能够接收来自授权服务器的传入请求(通过重定向)。
 
     +----------+
     | Resource |
     |   Owner  |
     |          |
     +----------+
          ^
          |
         (B)
     +----|-----+          Client Identifier      +---------------+
     |         -+----(A)-- &amp; Redirection URI ----&gt;|               |
     |  User-   |                                 | Authorization |
     |  Agent  -+----(B)-- User authenticates ---&gt;|     Server    |
     |          |                                 |               |
     |         -+----(C)-- Authorization Code ---&lt;|               |
     +-|----|---+                                 +---------------+
       |    |                                         ^      v
      (A)  (C)                                        |      |
       |    |                                         |      |
       ^    v                                         |      |
     +---------+                                      |      |
     |         |&gt;---(D)-- Authorization Code ---------'      |
     |  Client |          &amp; Redirection URI                  |
     |         |                                             |
     |         |&lt;---(E)----- Access Token -------------------'
     +---------+       (w/ Optional Refresh Token)
 
   注意:说明步骤 (A)、(B) 和 (C) 的行在通过用户代理时被分成两个部分。
 
                     Figure 3: 授权码流程</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   图 3 所示的流程包括以下步骤:
 
   (A)  客户端通过将资源所有者的用户代理定向到授权节点来启动流。 客户端包括其客户端
        标识符、请求的范围、本地状态和重定向 URI,授权服务器将在授予(或拒绝)访问后将
        用户代理发送回该 URI。
 
   (B)  授权服务器(通过用户代理)对资源所有者进行身份验证,并确定资源所有者是授予还是
        拒绝客户端的访问请求。
 
   (C)  假设资源所有者授予访问权限,授权服务器使用前面提供的重定向 URI(在请求中或在
        客户端注册期间)将用户代理重定向回客户端。 重定向 URI 包括授权代码和客户端
        之前提供的任何本地状态。
 
   (D)  客户端通过包括上一步中接收的授权码,从授权服务器的令牌结点请求访问令牌。
        发出请求时,客户端会通过授权服务器进行身份验证。 客户端包括用于获取验证授权码
        的重定向 URI。
 
   (E)  授权服务器对客户端进行身份验证,验证授权代码,并确保收到的重定向 URI 与步骤
        (C) 中用于重定向客户端的 URI 匹配。 如果有效,授权服务器将返回访问令牌,也
        可以返回刷新令牌。
 








4.1.1.  授权请求
 
   客户端通过将以下参数添加到授权终结点 URI 的查询组件来构造请求 URI,使用
   "application/x-www-form-urlencoded" 格式:
 
   response_type
         REQUIRED.  值必须设置为 "code".
 
   client_id
         REQUIRED.  第 2.2 节中描述的客户端标识符。
 
   redirect_uri
         OPTIONAL.  As described in Section 3.1.2.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   scope
         OPTIONAL.  The scope of the access request as described by
         Section 3.3.
 
   state
         RECOMMENDED.  客户端用于维护请求和回调之间的状态的不透明值。 将用户代理
         重定向回客户端时,授权服务器包含此值。 该参数应用于防止第 10.12 节所述的
         跨站点请求伪造。
 
   客户端使用 HTTP 重定向响应或通过用户代理提供给它的其他方法将资源所有者定向到构造
   的 URI。
 
   例如,客户端指示用户代理使用 TLS 发出以下 HTTP 请求(仅出于显示目的使用额外的换行
   符):
 
    GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz
        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
    Host: server.example.com
 
   授权服务器验证请求以确保所有必需的参数都存在且有效。 如果请求有效,授权服务器会对
   资源所有者进行身份验证,并获取授权决策(通过询问资源所有者或通过其他方式建立批准)。
 
   确定决策后,授权服务器使用 HTTP 重定向响应或通过用户代理的其他方法将用户代理定向到
   提供的客户端重定向 URI。
 







4.1.2.  授权响应
 
   如果资源所有者授予访问请求,授权服务器将发出授权代码,并通过使用
   "application/x-www-form-urlencoded"格式向重定向 URI 的查询组件添加以下参数
   并将其传递到客户端。:
 
   code
         REQUIRED.  授权服务器生成的授权代码。 授权代码必须在发布后不久过期,以降低
         泄漏风险。 建议最长授权代码生存期为 10 分钟。 客户端不得多次使用授权代码。
         如果多次使用授权代码,则授权服务器必须拒绝请求,并且应撤销(如果可能)以前基于
         该授权代码颁发的所有令牌。 授权代码绑定到客户端标识符和重定向 URI。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 





 
   state
         REQUIRED 如果客户端授权请求中存在"state"参数。 从客户端接收的确切值。
 
   例如,授权服务器通过发送以下 HTTP 响应重定向用户代理:
 
     HTTP/1.1 302 Found
     Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA
               &amp;state=xyz
 
   客户端必须忽略无法识别的响应参数。 此规范未定义授权代码字符串大小。 客户端应避免对
   代码值大小进行假设。 授权服务器应记录它发出的任何值的大小。
 
4.1.2.1.  错误响应
 
   如果请求由于缺少、无效或不匹配的重定向 URI 而失败,或者客户端标识符丢失或无效,则
   授权服务器应将错误通知资源所有者,并且不得自动将用户代理重定向到无效URI。
 
   如果资源所有者拒绝访问请求,或者请求由于缺少或无效重定向 URI 以外的原因而失败,则
   授权服务器通过使用 "application/x-www-form-urlencoded" 格式:
 
   error
         REQUIRED.  以下单个 ASCII [USASCII] 错误代码:
 
         invalid_request
               请求缺少必需的参数,包含无效的参数值,多次包含参数,或者格式不正确。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
         unauthorized_client
               客户端无权使用此方法请求授权码。
 
         access_denied
               资源所有者或授权服务器拒绝请求。
 
         unsupported_response_type
               授权服务器不支持使用此方法获取授权码。
 
         invalid_scope
               请求的scope无效、未知或格式不正确。
 
         server_error
               授权服务器遇到一个意外情况,无法完成请求。(需要此错误代码,因为无法
               通过重定向将 500 内部服务器错误 状态代码返回到客户端。
 
         temporarily_unavailable
               由于服务器的临时过载或维护,授权服务器当前无法处理请求。 (需要此错误
               代码,因为无法通过重定向将 503 服务不可用 状态代码返回到客户端。
 
         "error"参数的值不得包含设置 %x20-21 / %x23-5B / %x5D-7E 以外的字符。
 
   error_description
         OPTIONAL.  人可读的 ASCII [USASCII] 文本提供附加信息,用于帮助客户端
         开发人员了解发生的错误。
         "error_description"参数的值不得包含设置 %x20-21 / %x23-5B 
         / %x5D-7E 以外的字符。
 
   error_uri
         OPTIONAL.  一个 URI,用于标识包含错误信息的人类可读网页,用于向客户端开发
         人员提供有关该错误的其他信息。        
         "error_uri"参数的值不得包含设置 %x20-21 / %x23-5B / %x5D-7E
         以外的字符。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   state
         REQUIRED 如果客户端授权请求中存在"state"参数。 从客户端接收的确切值。
 
   例如,授权服务器通过发送以下 HTTP 响应重定向用户代理:
 
   HTTP/1.1 302 Found
   Location: https://client.example.com/cb?error=access_denied&amp;state=xyz
 
4.1.3.  访问令牌请求
 
   客户端通过使用"application/x-www-form-urlencoded"格式发送以下参数,并在 HTTP
   请求实体正文中使用 UTF-8 字符编码,从而向令牌节点发出请求:
 
   grant_type
         REQUIRED.  Value MUST be set to "authorization_code".
 
   code
         REQUIRED.  从授权服务器接收的授权码。
 
   redirect_uri
         REQUIRED, 如果"redirect_uri"参数包含在授权请求中(如第 4.1.1 节所述),
         其值必须相同。
 
   client_id
         REQUIRED, 如果客户端未按照第 3.2.1 节所述使用授权服务器进行身份验证。
 
   如果客户端类型是机密的,或者客户端已发出客户端凭据(或分配了其他身份验证要求),则
   客户端必须按照第 3.2.1 节所述使用授权服务器进行身份验证。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   例如,客户端使用 TLS 发出以下 HTTP 请求(仅出于显示目的使用额外的换行符):
 
     POST /token HTTP/1.1
     Host: server.example.com
     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
     Content-Type: application/x-www-form-urlencoded
 
     grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA
     &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
 
   授权服务器 MUST:
 
   o  要求对机密客户端或任何已颁发客户端凭据(或其他身份验证要求)的客户端进行身份验证,
 
   o  如果包含客户端身份验证,则对客户端进行身份验证,
 
   o  确保授权代码已颁发给经过身份验证的机密客户端,或者如果客户端是公共的,请确保代码
      已颁发给请求中的"client_id",
 
   o  验证授权代码是否有效,以及
 
   o  确保"redirect_uri"参数存在,如果"redirect_uri"参数包含在初始授权请求中,如
      第 4.1.1 节中所述,并且如果包含,则确保其值相同。
 




4.1.4.  访问令牌响应
 
   如果访问令牌请求有效且经过授权,则授权服务器将颁发访问令牌和可选刷新令牌,如第5.1节
   所述。 如果请求客户端身份验证失败或无效,授权服务器将返回错误响应,如第5.2节所述。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   成功响应示例:
 
     HTTP/1.1 200 OK
     Content-Type: application/json;charset=UTF-8
     Cache-Control: no-store
     Pragma: no-cache
 
     {
       "access_token":"2YotnFZFEjr1zCsicMWpAA",
       "token_type":"example",
       "expires_in":3600,
       "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
       "example_parameter":"example_value"
     }
 
4.2.  隐式Grant
 
   隐式授予类型用于获取访问令牌(它不支持刷新令牌的颁发),并且针对已知操作特定重定向
   URI的公共客户端进行了优化。 这些客户端通常使用 JavaScript 等脚本语言在浏览器
   中实现。
 
   由于这是一个基于重定向的流,客户端必须能够与资源所有者的用户代理(通常是 Web 
   浏览器)进行交互,并能够接收来自授权服务器的传入请求(通过重定向)。
 
   与授权代码授予类型不同,客户端对授权和访问令牌发出单独的请求,客户端作为授权请求的
   结果接收访问令牌。
 
   隐式授予类型不包括客户端身份验证,并且依赖于资源所有者的存在和重定向 URI 的注册。
   由于访问令牌被编码到重定向 URI 中,因此可能会向资源所有者和驻留在同一设备上的其他
   应用程序公开。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
     +----------+
     | Resource |
     |  Owner   |
     |          |
     +----------+
          ^
          |
         (B)
     +----|-----+          Client Identifier     +---------------+
     |         -+----(A)-- &amp; Redirection URI ---&gt;|               |
     |  User-   |                                | Authorization |
     |  Agent  -|----(B)-- User authenticates --&gt;|     Server    |
     |          |                                |               |
     |          |&lt;---(C)--- Redirection URI ----&lt;|               |
     |          |          with Access Token     +---------------+
     |          |            in Fragment
     |          |                                +---------------+
     |          |----(D)--- Redirection URI ----&gt;|   Web-Hosted  |
     |          |          without Fragment      |     Client    |
     |          |                                |    Resource   |
     |     (F)  |&lt;---(E)------- Script ---------&lt;|               |
     |          |                                +---------------+
     +-|--------+
       |    |
      (A)  (G) Access Token
       |    |
       ^    v
     +---------+
     |         |
     |  Client |
     |         |
     +---------+
 
   注意:说明步骤 (A) 和 (B) 的行在通过用户代理时被分成两个部分。
 
                       Figure 4: 隐式授权流程</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   图 4 所示的流包括以下步骤:
 
   (A)  客户端通过将资源所有者的用户代理定向到授权节点来启动流。 客户端包括其客户端
        标识符、请求的范围、本地状态和重定向 URI,授权服务器将在授予(或拒绝)访问后
        将用户代理发送回该 URI。
 
   (B)  授权服务器(通过用户代理)对资源所有者进行身份验证,并确定资源所有者是授予还是
        拒绝客户端的访问请求。
 
   (C)  假设资源所有者授予访问权限,则授权服务器使用前面提供的重定向 URI 将用户代理
        重定向回客户端。 重定向 URI 包括 URI 片段中的访问令牌。
 
   (D)  用户代理遵循重定向指令,向 Web 托管的客户端资源发出请求
        (不包括每个 [RFC2616] 的片段)。 用户代理在本地保留片段信息。
 
   (E)  Web 托管的客户端资源返回一个网页(通常是具有嵌入式脚本的 HTML 文档),该网页
        能够访问完整的重定向 URI,包括用户代理保留的片段,并提取访问令牌(和其他
        参数)。
 
   (F)  用户代理在本地执行 Web 托管客户端资源提供的脚本,该客户端资源提取访问令牌。
 
   (G)  用户代理将访问令牌传递给客户端。
 
   有关使用隐式授予的背景,请参阅第 1.3.2 和 9 节。有关使用隐式授予时的重要安全注意事项,请参阅第 10.3 和 10.16 节。
 









4.2.1.  授权请求
 
   客户端通过将以下参数添加到授权节点 URI 的查询组件来构造请求 URI,使用
   "application/x-www-form-urlencoded" 格式:
 
   response_type
         REQUIRED.  Value MUST be set to "token".
 
   client_id
         REQUIRED.  The client identifier as described in Section 2.2.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   redirect_uri
         OPTIONAL.  As described in Section 3.1.2.
 
   scope
         OPTIONAL.  The scope of the access request as described by
         Section 3.3.
 
   state
         RECOMMENDED.  客户端用于维护请求和回调之间的状态的不透明值。 将用户代理
                       重定向回客户端时,授权服务器包含此值。 该参数应用于防止
                       第 10.12 节所述的跨站点请求伪造。
 
   客户端使用 HTTP 重定向响应或通过用户代理提供给它的其他方法将资源所有者定向到构造
   的 URI。
 
   例如,客户端指示用户代理使用 TLS 发出以下 HTTP 请求(仅出于显示目的使用额外的
   换行符):
 
    GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz
        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
    Host: server.example.com
 
   授权服务器验证请求以确保所有必需的参数都存在且有效。 授权服务器必须验证它将重定向
   访问令牌的重定向 URI 是否与客户端注册的重定向 URI 匹配,如第 3.1.2 节所述。
 
   如果请求有效,授权服务器会对资源所有者进行身份验证,并获取授权决策(通过询问资源
   所有者或通过其他方式建立批准)。
 
   确定决策后,授权服务器使用 HTTP 重定向响应或通过用户代理的其他方法将用户代理定向到
   客户端提供的重定向 URI。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.2.  访问令牌响应
 
   如果资源所有者授予访问请求,则授权服务器将颁发访问令牌,并通过使用"application/
   x-www-form-urlencoded"向重定向 URI 的片段组件添加以下参数并将其传递到客户端:
 
   access_token
         必填  授权服务器颁发的访问令牌。
 
   token_type
         必填  第 7.1 节中描述的令牌类型。 值不区分大小写。
 
   expires_in
         推荐  访问令牌的生存期(以秒为单位)。 例如,值 "3600" 表示访问令牌将在生成
              响应后一小时内过期。如果省略,授权服务器应通过其他方式提供过期时间或
              记录默认值。
 
   scope
         如果与客户端请求的范围相同,则此参数为可选;否则必填
 
   state
         如果客户端授权请求中存在"state"参数,则必填。 从客户端接收的确切值。
 
   授权服务器不得颁发刷新令牌。
 
   例如,授权服务器通过发送以下 HTTP 响应重定向用户代理(额外的换行符仅出于显示目的):
 
     HTTP/1.1 302 Found
     Location: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA
               &amp;state=xyz&amp;token_type=example&amp;expires_in=3600
 
   开发人员应该注意,某些用户代理不支持在 HTTP "Location" 响应标头字段中包含片段
   组件。 此类客户端将需要使用其他方法来重定向客户端,而不是 3xx 重定向响应 , 例如,
   返回一个 HTML 页面,其中包含一个"continue"按钮,其中包含链接到重定向 URI 的
   操作。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   客户端必须忽略无法识别的响应参数。 此规范未定义访问令牌字符串大小。 客户端应避免对
   值大小（长度）进行假设。 授权服务器应记录它发出的任何值的大小
 
4.2.2.1.  错误响应
 
   如果请求由于缺少、无效或不匹配的重定向 URI 而失败,或者客户端标识符丢失或无效,则
   授权服务器应将错误通知资源所有者,并且不得自动将用户代理重定向到无效的重定向 URI。
 
   如果资源所有者拒绝访问请求,或者请求由于缺少或无效重定向 URI 以外的原因而失败,则
   授权服务器通过使用 "application/x-www-form-urlencoded" 格式:
 
   error
         必填。 以下单个 ASCII [USASCII] 错误代码:
 
         invalid_request
               请求缺少必需的参数,包含无效的参数值,多次包含参数,或者格式不正确。
 
         unauthorized_client
               客户端无权使用此方法请求访问令牌。
 
         access_denied
               资源所有者或授权服务器拒绝请求。
 
         unsupported_response_type
               授权服务器不支持使用此方法获取访问令牌。
 
         invalid_scope
               请求的范围无效、未知或格式不正确。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
         server_error
               授权服务器遇到一个意外情况,无法完成请求。
 
         temporarily_unavailable
               由于服务器的临时过载或维护,授权服务器当前无法处理请求。
 
         "error"参数的值不得包含设置 %x20-21 / %x23-5B / %x5D-7E 以外的字符。
 
   error_description
         可选。 人可读的 ASCII [USASCII] 文本提供附加信息,用于帮助客户端开发人员
         了解发生的错误。
         "error_description"参数的值不得包含设置 %x20-21 / %x23-5B 
         / %x5D-7E  以外的字符。
 
   error_uri
         可选。  一个 URI,用于标识包含错误信息的人类可读网页,用于向客户端开发人员
         提供有关该错误的其他信息。       
         "error_uri"参数的值必须符合 URI 引用语法,因此不得包含设置 %x21 / 
         %23-5B / %x5D-7E 以外的字符。
 
   state
         如果客户端授权请求中存在"状态"参数,则必填。 从客户端接收的确切值。
 
   例如,授权服务器通过发送以下 HTTP 响应重定向用户代理:
 
   HTTP/1.1 302 Found
   Location: https://client.example.com/cb#error=access_denied&amp;state=xyz
 
4.3.  资源所有者密码凭据 Grant
 
   资源所有者密码凭据 Grant 类型适用于资源所有者与客户端(如设备操作系统或高特权应用
   程序)具有信任关系的情况。 授权服务器在启用此授予类型时应特别注意,并且仅在其他方式
   不可行时才允许它。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   
 
   此Grant类型适用于能够获取资源所有者凭据的客户端(用户名和密码,通常使用交互式
   窗体)。它还用于使用直接身份验证方案(如 HTTP 基本身份验证或摘要式身份验证)将存储的
   凭据转换为访问令牌来将现有客户端迁移到 OAuth。
 
     +----------+
     | Resource |
     |  Owner   |
     |          |
     +----------+
          v
          |    Resource Owner
         (A) Password Credentials
          |
          v
     +---------+                                  +---------------+
     |         |&gt;--(B)---- Resource Owner -------&gt;|               |
     |         |         Password Credentials     | Authorization |
     | Client  |                                  |     Server    |
     |         |&lt;--(C)---- Access Token ---------&lt;|               |
     |         |    (w/ Optional Refresh Token)   |               |
     +---------+                                  +---------------+
 
            Figure 5:资源所有者密码凭据流
 
   
   图5所示的流程包括以下步骤：
 
   (A)  资源所有者向客户端提供其用户名和密码。
 
   (B)  客户端通过包括从资源所有者收到的凭据从授权服务器的令牌节点请求访问令牌。 
        发出请求时,客户端会通过授权服务器进行身份验证。
 
   (C)  授权服务器对客户端进行身份验证并验证资源所有者凭据,如果有效,则颁发访问令牌。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.3.1.  授权请求和响应
 
   客户端获取资源所有者凭据的方法超出了此规范的范围。 获取访问令牌后,客户端必须放弃
   凭据。
 
4.3.2.  访问令牌请求
 
   客户端通过添加以下参数,使用"application/x-www-form-urlencoded"格式,
   在 HTTP 请求实体中添加 UTF-8 字符编码,从而向令牌节点发出请求:
 
   grant_type
         REQUIRED.  Value MUST be set to "password".
 
   username
         REQUIRED.  The resource owner username.
 
   password
         REQUIRED.  The resource owner password.
 
   scope
         OPTIONAL.  The scope of the access request as described by         Section 3.3.
 
   如果客户端类型是机密的,或者客户端已发出客户端凭据(或分配了其他身份验证要求),则
   客户端必须按照第 3.2.1 节所述使用授权服务器进行身份验证。
 
   例如,客户端使用传输层安全性发出以下 HTTP 请求(仅出于显示目的使用额外换行符):
 
     POST /token HTTP/1.1
     Host: server.example.com
     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
     Content-Type: application/x-www-form-urlencoded
 
     grant_type=password&amp;username=johndoe&amp;password=A3ddj3w</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   授权服务器必须:
 
   o  要求对机密客户端或任何已颁发客户端凭据(或其他身份验证要求)的客户端进行身份验证,
 
   o  如果包含客户端身份验证,则对客户端进行身份验证,以及
 
   o  使用其现有密码验证算法验证资源所有者密码凭据。
 
   由于此访问令牌请求使用资源所有者的密码,因此授权服务器必须保护终结点免受暴力攻击
   (例如,使用速率限制或生成警报)。
 
4.3.3.  访问令牌响应
 
   如果访问令牌请求有效且经过授权,则授权服务器将颁发访问令牌和可选刷新令牌,如第5.1节
   所述。 如果请求失败的客户端身份验证或无效,授权服务器将返回错误响应,如第 5.2 节
   所述。
 
   成功响应示例:
 
     HTTP/1.1 200 OK
     Content-Type: application/json;charset=UTF-8
     Cache-Control: no-store
     Pragma: no-cache
 
     {
       "access_token":"2YotnFZFEjr1zCsicMWpAA",
       "token_type":"example",
       "expires_in":3600,
       "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
       "example_parameter":"example_value"
     }
 
4.4.  客户端凭据 Grant
 
   当客户端请求对其控制的受保护资源或以前其他资源所有者的访问权限时,客户端只能使用其
   客户端凭据(或其他受支持的身份验证方式)请求访问令牌与授权服务器(其方法超出本规范的
   范围)一起安排。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   客户端凭据Grant类型只能由机密客户端使用。
 
     +---------+                                  +---------------+
     |         |                                  |               |
     |         |&gt;--(A)- Client Authentication ---&gt;| Authorization |
     | Client  |                                  |     Server    |
     |         |&lt;--(B)---- Access Token ---------&lt;|               |
     |         |                                  |               |
     +---------+                                  +---------------+
 
                     Figure 6: 客户端凭据流
 
   图 6 所示的流包括以下步骤:
 
   (A)  客户端使用授权服务器进行身份验证,并从令牌终结点请求访问令牌。
 
   (B)  授权服务器对客户端进行身份验证,如果有效,则颁发访问令牌。
 
4.4.1.  授权请求和响应
 
   由于客户端身份验证用作授权授予,因此无需其他授权请求。
 
4.4.2.  访问令牌请求
 
   客户端使用"application/x-www-form-urlencoded"格式utf-8编码请求token节点:
 
   grant_type
         REQUIRED.  Value MUST be set to "client_credentials".
 
   scope
         OPTIONAL.  The scope of the access request as described by
         Section 3.3.
 
   客户端必须按照第 3.2.1 节所述使用授权服务器进行身份验证。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   例如,客户端使用TLS发出以下 HTTP 请求(仅出于显示目的使用额外换行符):
 
     POST /token HTTP/1.1
     Host: server.example.com
     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
     Content-Type: application/x-www-form-urlencoded
 
     grant_type=client_credentials
 
   授权服务器必须对客户端进行身份验证。
 
4.4.3.  访问令牌响应
 
   如果访问令牌请求有效且经过授权,则授权服务器将颁发访问令牌,如第 5.1 节所述。 不应
   包含刷新令牌。 如果请求失败的客户端身份验证或无效,授权服务器将返回错误响应,如
   第 5.2 节所述。
 
   成功响应示例:
 
     HTTP/1.1 200 OK
     Content-Type: application/json;charset=UTF-8
     Cache-Control: no-store
     Pragma: no-cache
 
     {
       "access_token":"2YotnFZFEjr1zCsicMWpAA",
       "token_type":"example",
       "expires_in":3600,
       "example_parameter":"example_value"
     }
 
4.5.  扩展 Grants
 
   客户端使用绝对 URI(由授权服务器定义)指定Grant类型作为令牌节点的"grant_type"
   参数的值,并添加所需的任何其他参数,从而使用扩展Grant类型。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   
   例如，要使用[OAuth-SAML2]定义的安全断言标记语言(SAML)2.0断言授权类型请求访问
   令牌，客户端可以使用TLS发出以下HTTP请求(额外的换行符仅用于显示目的)：
 
     POST /token HTTP/1.1
     Host: server.example.com
     Content-Type: application/x-www-form-urlencoded
 
     grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Asaml2-
     bearer&amp;assertion=PEFzc2VydGlvbiBJc3N1ZUluc3RhbnQ9IjIwMTEtMDU
     [...omitted for brevity...]aG5TdGF0ZW1lbnQ-PC9Bc3NlcnRpb24-
 
   如果访问令牌请求有效且经过授权,则授权服务器将颁发访问令牌和可选刷新令牌,如第
   5.1 节所述。如果请求失败的客户端身份验证或无效,授权服务器将返回错误响应,如第
   5.2 节所述。
 
5.  颁发访问令牌
 
   如果访问令牌请求有效且经过授权,则授权服务器将颁发访问令牌和可选刷新令牌,如
   第 5.1 节所述。如果请求失败的客户端身份验证或无效,授权服务器将返回错误响应,如
   第 5.2 节所述。
 







5.1.  成功响应
 
   授权服务器颁发访问令牌和可选刷新令牌,并通过向具有 200 (OK) 状态代码的 HTTP
   响应的实体正文添加以下参数来构造响应:
 
   access_token
         REQUIRED. The access token issued by the authorization server.
 
   token_type
         REQUIRED.  第 7.1 节中描述的令牌类型。 值不区分大小写。
 
   expires_in
         推荐。 访问令牌的生存期(以秒为单位)。 例如,值"3600"表示访问令牌将在生成
         响应后一小时内过期。如果省略,授权服务器应通过其他方式提供过期时间或记录
         默认值。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   refresh_token
          可选，刷新令牌,可用于使用第 6 节中所述的相同授权授予来获取新的访问令牌。
 
   scope
         实际scope与请求scope不一致时，必填
 
   参数包含在 HTTP 响应的实体正文中,使用 [RFC4627] 定义的"application/json" 
   媒体类型。 通过在最高结构级别添加每个参数,这些参数被序列化为 JavaScript 对象
   表示法 (JSON) 结构。参数名称和字符串值作为 JSON 字符串包含在内。数值作为 JSON 
   数字包含在内。 参数的顺序并不重要,并且可能会有所不同。
 
   授权服务器必须在包含令牌、凭据或其他敏感信息的任何响应中包含 HTTP 
   "Cache-Control" 响应标头字段 [RFC2616],其值为"no-store", 以及 "Pragma" 
   响应标头字段 [RFC2616] 的值为"no-cache"。
 
   For example:
 
     HTTP/1.1 200 OK
     Content-Type: application/json;charset=UTF-8
     Cache-Control: no-store
     Pragma: no-cache
 
     {
       "access_token":"2YotnFZFEjr1zCsicMWpAA",
       "token_type":"example",
       "expires_in":3600,
       "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
       "example_parameter":"example_value"
     }
 
   客户端必须忽略响应中无法识别的值名称。 从授权服务器接收的令牌和其他值的大小未定义。
   客户端应避免对值大小（长度）进行假设。 授权服务器应记录它发出的任何值的大小。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
5.2.  错误响应
 
   授权服务器使用 HTTP 400(错误请求)状态代码(除非另有指定)进行响应,并在响应中包括
   以下参数:
 
   error
         必填。 以下单个 ASCII [USASCII] 错误代码:
 
         invalid_request
               请求缺少必需的参数,包括不支持的参数值(授权类型以外的),重复一个参数,
               包括多个凭据,利用多个机制来验证客户端,或者格式不正确。
 
         invalid_client
               客户端身份验证失败(例如,未知客户端、不包含客户端身份验证或不支持的
               身份验证方法)。 授权服务器可能会返回 HTTP 401(未授权)状态代码,以
               指示支持哪些 HTTP 身份验证方案。 如果客户端试图通过"授权" 请求标头
               字段进行身份验证,则授权服务器必须使用 HTTP 401(未授权)状态代码进行
               响应,并包括与身份验证匹配的"WWW 身份验证" 响应标头字段客户端使用的
               方案。
 
         invalid_grant
                提供的授权grant(例如,授权码、资源所有者凭据)或刷新令牌无效、
                已过期、已吊销、与授权请求中使用的重定向 URI 不匹配,或已颁发
                到另一个客户端。

         unauthorized_client
               已验证的客户端无权使用此授权授予类型。
 
         unsupported_grant_type
               授权服务器不支持的grant类型。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
         invalid_scope
               请求的scope无效、未知、格式不正确或超出资源所有者授予的范围。
 
         "error"参数的值不得包含设置 %x20-21 / %x23-5B / %x5D-7E 以外的字符。
 
   error_description
         可选。 人可读的 ASCII [USASCII] 文本提供附加信息,用于帮助客户端开发人员
         了解发生的错误。
         "error_description"参数的值不得包含设置 %x20-21 / %x23-5B 
         / %x5D-7E 以外的字符。
 
   error_uri
         可选。  一个 URI,用于标识包含错误信息的人类可读网页,用于向客户端开发人员
         提供有关该错误的其他信息。       
         "error_uri"参数的值必须符合 URI 引用语法,因此不得包含设置 %x21 / 
         %23-5B / %x5D-7E 以外的字符。
 
   参数包含在 HTTP 响应的实体正文中,使用 [RFC4627] 定义的"application/json" 
   媒体类型。 通过在最高结构级别添加每个参数,参数序列化为 JSON 结构。参数名称和
   字符串值作为 JSON 字符串包含在内。 数值作为 JSON 数字包含在内。 参数的顺序并不
   重要,并且可能会有所不同。
 
   For example:
 
     HTTP/1.1 400 Bad Request
     Content-Type: application/json;charset=UTF-8
     Cache-Control: no-store
     Pragma: no-cache
 
     {
       "error":"invalid_request"
     }</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
6.  刷新访问令牌
 
   如果授权服务器向客户端发出刷新令牌,则客户端会在 HTTP 请求实体正文中使用
   "application/x-www-form-urlencoded" 格式添加以下参数,并将其字符编码为
    UTF-8,从而向令牌节点发出刷新请求:
 
   grant_type
         REQUIRED.  Value MUST be set to "refresh_token".
 
   refresh_token
         REQUIRED.  The refresh token issued to the client.
 
   scope
         OPTIONAL.  访问请求的范围,如第 3.3 节所述。 请求的范围不得包括资源所有者
         最初未授予的任何作用域,如果省略,则视为与资源所有者最初授予的范围相等。
 
   由于刷新令牌通常是用于请求其他访问令牌的持久凭据,因此刷新令牌绑定到其颁发到的
   客户端。如果客户端类型是机密的,或者客户端已发出客户端凭据(或分配了其他身份验证
   要求),则客户端必须按照第 3.2.1 节所述使用授权服务器进行身份验证。
 
   例如,客户端使用 TLS 发出以下 HTTP 请求(仅出于显示目的使用额外换行符):
 
     POST /token HTTP/1.1
     Host: server.example.com
     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
     Content-Type: application/x-www-form-urlencoded
 
     grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   授权服务器必须:
 
   o  要求对机密客户端或任何已颁发客户端凭据(或其他身份验证要求)的客户端进行身份验证,
 
   o  如果包含客户端身份验证,则对客户端进行身份验证,并确保刷新令牌已颁发给经过身份
      验证的客户端,以及
 
   o  验证刷新令牌。
 
   如果验证和授权通过,授权服务器将颁发访问令牌,如第 5.1 节所述。 如果请求验证失败或
   无效,授权服务器将返回错误响应,如第 5.2 节所述。
 
   授权服务器可能会颁发新的刷新令牌,在这种情况下,客户端必须放弃旧的刷新令牌并将其替换
   为新的刷新令牌。 授权服务器可能会在向客户端发出新的刷新令牌后撤消旧刷新令牌。 如果
   发出新的刷新令牌,刷新令牌范围必须与客户端在请求中包含的刷新令牌的范围相同。
 







7.  访问受保护资源
 
   客户端通过将访问令牌呈现给资源服务器来访问受保护的资源。 资源服务器必须验证访问
   令牌,并确保它尚未过期,并且其范围涵盖请求的资源。 资源服务器用于验证访问令牌(以及
   任何错误响应)的方法超出了此规范的范围,但通常涉及资源服务器和授权服务器之间的交互
   或协调。
 
   客户端使用访问令牌对资源服务器进行身份验证的方法取决于授权服务器颁发的访问令牌的
   类型。 通常,它涉及使用 HTTP [Authorization] 请求标头字段 [RFC2617] 与由
   所使用的访问令牌类型的规范定义的身份验证方案,例如 [RFC6750]。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
7.1.  访问令牌类型
 
   访问令牌类型为客户端提供了成功利用访问令牌发出受保护资源请求(以及特定于类型的属性)
   所需的信息。 如果客户端不了解令牌类型,则不得使用访问令牌。
 
   例如,只需在请求中包括访问令牌字符串,即可使用在 [RFC6750] 中定义的"bearer" 令牌
   类型:
 
     GET /resource/1 HTTP/1.1
     Host: example.com
     Authorization: Bearer mF_9.B5f-4.1JqM
 
   在 [OAuth-HTTP-MAC] 中定义的 "mac" 令牌类型通过颁发消息身份验证代码 (MAC) 
   密钥以及用于对 HTTP 请求的某些组件进行签名的访问令牌来使用:
 
     GET /resource/1 HTTP/1.1
     Host: example.com
     Authorization: MAC id="h480djs93hd8",
                        nonce="274312:dj83hs9s",
                        mac="kDZvddkndxvhGRXZhvuDjEWhGeE="
 
   上述示例仅供说明目的。  建议开发人员在使用前参考 [RFC6750] 和 
   [OAuth-HTTP-MAC] 规范。
 
   每个访问令牌类型定义指定发送到客户端的其他属性(如果有)以及"access_token"响应
   参数。 它还定义了用于在发出受保护资源请求时包括访问令牌的 HTTP 身份验证方法。
 






7.2.  错误响应
 
   如果资源访问请求失败,资源服务器应通知客户端错误。 虽然此类错误响应的细节超出了
   本规范的范围,但本文档在第 11.4 节中建立了一个通用注册表,用于在 OAuth 令牌身份
   验证方案之间共享错误值。
 
   主要为 OAuth 令牌身份验证设计的新身份验证方案应定义一种向客户端提供错误状态代码
   的机制,其中允许的错误值在此规范建立的错误注册表中注册。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   此类方案可能会将有效错误代码集限制为已注册值的子集。 如果使用命名参数返回错误代码,
   则参数名称应为"error"。
 
   其他能够用于 OAuth 令牌身份验证(但主要不是为此目的而设计)的方案可能以相同的方式将
   其错误值绑定到注册表。
 
   新的身份验证方案可以选择同时指定使用"error_描述"和"error_uri"参数,以与其在此
   规范中的用法类似的方式返回错误信息。
 
8.  可扩展性
 
8.1.  定义访问令牌类型
 
   访问令牌类型可通过以下两种方式之一定义:在 Access 令牌类型注册表中注册(按照
   第 11.1 节中的过程),或者使用唯一的绝对 URI 作为其名称。
 
   使用 URI 名称的类型应仅限于通常不适用的特定于供应商的实现,并且特定于使用 URI 的
   资源服务器的实现详细信息。
 
   必须注册所有其他类型。 类型名称必须符合类型名称 ABNF。 如果类型定义包含新的 HTTP
   身份验证方案,则类型名称应与 HTTP 身份验证方案名称相同(由 [RFC2617] 定义)。 令牌
   类型"example"保留用于示例。
 
     type-name  = 1*name-char
     name-char  = "-" / "." / "_" / DIGIT / ALPHA
 






8.2.  定义新的节点参数
 
   按照第 11.2 节中的步骤,在 OAuth 参数注册表中定义并注册用于授权节点或令牌节点的
   新请求或响应参数。
 
   参数名称必须符合参数名称 ABNF,并且参数值语法必须定义良好(例如,使用 ABNF 或对现有
   参数的语法的引用)。
 
     param-name  = 1*name-char
     name-char   = "-" / "." / "_" / DIGIT / ALPHA</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   未注册的特定于供应商的参数扩展,这些扩展通常不适用,并且特定于使用它们的授权服务器的
   实现详细信息,应使用与供应商特定的前缀,该前缀与其他注册值不同(例如,
   以"companyname_"开头)。
 
8.3.  定义新的授权 Grant Types
 
   可以通过为它们分配一个唯一的绝对 URI 来定义新的授权授予类型,以便与"grant_type"
   参数一起使用。 如果扩展Grant类型需要其他令牌节点参数,则必须在第 11.2 节所述的
   OAuth 参数注册表中注册这些参数。
 
8.4.  定义新的授权节点响应类型
 
   按照第 11.3 节中的步骤,在授权节点响应类型注册表中定义和注册了用于授权节点的新响应
   类型。 响应类型名称必须符合响应类型 ABNF。
 
     response-type  = response-name *( SP response-name )
     response-name  = 1*response-char
     response-char  = "_" / DIGIT / ALPHA
 
   如果响应类型包含一个或多个空格字符 (%x20),则将其作为空格分隔的值列表进行比较,其中
   值的顺序无关紧要。 只能注册一个值顺序,它涵盖了同一组值的所有其他排列。
 
   例如,响应类型"token code"未在此规范中定义。 但是,扩展可以定义和注册
   "token code"响应类型。 注册后,无法将相同的组合注册为"code token",但这两个值都
   可用于表示相同的响应类型。
 
8.5.  定义其他错误代码
 
   如果协议扩展(即访问令牌类型、扩展参数或扩展授予类型)需要与授权代码授予错误响应一起
   使用的其他错误代码(第 4.1.2.1 节),则隐式授予错误响应 (第 4.2.2.1 节、令牌错误
   响应(第 5.2 节)或资源访问错误响应(第 7.2 节),可能已经定义了此类错误代码。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   如果扩展错误代码与注册访问令牌类型、已注册的节点参数或扩展授予类型结合使用,则必须
   注册扩展错误代码(按照第 11.4 节中的过程)。 可以注册与未注册扩展一起使用的错误
   代码。
 
   错误代码必须符合错误 ABNF,并且应尽可能以标识名称作为前缀。 例如,标识设置为扩展
   参数"example"的无效值的错误应命名为"example_invalid"。
 
     error      = 1*error-char
     error-char = %x20-21 / %x23-5B / %x5D-7E
 



9.  本机应用程序
 
   本机应用程序是在资源所有者(即桌面应用程序、本机移动应用程序)使用的设备上安装和执行
   的客户端。 本机应用程序需要特别考虑安全性、平台功能和总体最终用户体验。
 
   授权节点需要客户端和资源所有者的用户代理之间的交互。 本机应用程序可以调用外部用户
   代理或在应用程序中嵌入用户代理。  例如:
 
   o  外部用户代理 - 本机应用程序可以使用重定向 URI 从授权服务器捕获响应,该 URI 与
      在操作系统上注册的方案一起调用客户端作为处理程序,手动复制和粘贴凭据,运行本地
      Web 服务器、安装用户代理扩展,或通过提供重定向 URI 来标识客户端控制下的服务器
      托管资源,从而使响应对本机应用程序可用。
 
   o  嵌入式用户代理 - 本机应用程序通过监视资源加载期间发出的状态更改或访问用户代理
      的 Cookie 存储,直接与嵌入式用户代理通信来获得响应。
 
   在外部或嵌入式用户代理之间进行选择时,开发人员应考虑以下事项:
 
   o  外部用户代理可以提高完成率,因为资源所有者可能已经与授权服务器有活动会话,无需
      重新进行身份验证。 它提供了熟悉的最终用户体验和功能。 资源所有者还可以依赖用户
      代理功能或扩展来协助身份验证(例如,密码管理器、双因素设备读取器)。
</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 


 
   o  嵌入式用户代理可以提供更好的可用性,因为它无需切换上下文和打开新窗口。
 
   o  嵌入式用户代理会带来安全挑战,因为资源所有者在未识别的窗口中进行身份验证,而无法
      访问大多数外部用户代理中直观保护。 嵌入式用户代理教育最终用户信任未识别的身份
      验证请求(使网络钓鱼攻击更易于执行)。
 
   在隐式授予类型和授权码授予类型之间进行选择时,应考虑以下事项:
 
   o  使用授权码授予类型的本机应用程序应该不使用客户端凭据,因为本机应用程序无法对
      客户端凭据保密。
 
   o  使用隐式授予类型流时,不会返回刷新令牌,这需要在访问令牌过期后重复授权过程。
 
10.  安全考虑
 
   作为一个灵活且可扩展的框架,OAuth 的安全注意事项取决于许多因素。 以下各节为实现者
   提供了安全指南,重点介绍第 2.1 节中介绍的三个客户端配置文件:Web 应用程序、基于用户
   代理的应用程序和本机应用程序。
 
   [OAuth-THREATMODEL] 提供了全面的 OAuth 安全模型和分析,以及协议设计的背景。
 
10.1.  客户端身份验证
 
   授权服务器与 Web 应用程序客户端建立客户端凭据,以便进行客户端身份验证。 建议授权
   服务器考虑比客户端密码更强的客户端身份验证手段。 Web 应用程序客户端必须确保客户端
   密码和其他客户端凭据的机密性。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   出于客户端身份验证的目的,授权服务器不得向本机应用程序或基于用户代理的应用程序客户端
   颁发客户端密码或其他客户端凭据。 授权服务器可能会为在特定设备上的特定安装本机应用
   程序客户端发出客户端密码或其他凭据。
 
   当无法进行客户端身份验证时,授权服务器应采用其他方法来验证客户端的标识,例如,要求
   注册客户端重定向 URI 或登记资源所有者以确认身份。 在请求资源所有者授权时,有效的
   重定向URI 不足以验证客户端的身份,但可用于防止在获得资源所有者授权后将凭据传递到
   伪造客户端。
 
   授权服务器必须考虑与未经身份验证的客户端交互的安全影响,并采取措施限制向此类客户端
   颁发的其他凭据(例如刷新令牌)的潜在暴露。
 
10.2.  客户端模拟
 
   如果模拟的客户端无法或无法对其客户端凭据保密,恶意客户端可以模拟另一个客户端并获取
   对受保护资源的访问。
 
   授权服务器必须尽可能对客户端进行身份验证。 如果授权服务器由于客户端的性质而无法对
   客户端进行身份验证,则授权服务器必须要求注册用于接收授权响应的任何重定向 URI,并且
   应该使用其他方法来保护资源来自此类潜在恶意客户端的所有者。 例如,授权服务器可以与
   资源所有者接洽,以帮助识别客户端及其来源。
 
   授权服务器应强制实施显式资源所有者身份验证,并向资源所有者提供有关客户端和请求的
   授权范围和生存期的信息。 资源所有者有权在当前客户端的上下文中查看信息,并授权或
   拒绝请求。
 
   授权服务器不应自动处理重复的授权请求(无需活动资源所有者交互),而不验证客户端或依赖
   其他措施以确保重复的请求来自原始请求客户端,而不是模拟者。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
10.3.  访问令牌
 
   访问令牌凭据(以及任何机密访问令牌属性)必须在传输和存储中保密,并且仅在授权服务器、
   访问令牌有效的资源服务器以及访问到其的客户端之间共享令牌颁发。 访问令牌凭据只能
   使用 TLS 传输,如第 1.6 节所述,服务器身份验证由 [RFC2818] 定义。。
 
   使用隐式授予类型时,访问令牌在 URI 片段中传输,这可能会使其暴露给未经授权的参与方。
 
   授权服务器必须确保不能生成、修改或猜测访问令牌,以便未经授权的方生成有效的访问令牌。
 
   客户端应请求具有最小范围的访问令牌。 授权服务器在选择如何遵守请求的范围时应考虑
   客户端标识,并且可能以比请求的权限更少的权限颁发访问令牌。
 
   此规范不为资源服务器提供任何方法,以确保授权服务器向该客户端发出给定客户端呈现的访问
   令牌。
 
10.4.  刷新令牌
 
   授权服务器可能会向 Web 应用程序客户端和本机应用程序客户端颁发刷新令牌.
 
   刷新令牌必须在传输和存储中保密,并且仅在授权服务器和向其颁发刷新令牌的客户端之间
   共享。授权服务器必须维护刷新令牌和向其发出令牌的客户端之间的绑定。 刷新令牌只能
   使用 TLS 传输,如第 1.6 节所述,服务器身份验证由 [RFC2818] 定义。
 
   每当可以对客户端标识进行身份验证时,授权服务器必须验证刷新令牌和客户端标识之间的
   绑定。当无法进行客户端身份验证时,授权服务器应部署其他方法来检测刷新令牌滥用。
 
   例如,授权服务器可以采用刷新令牌轮换,其中每个访问令牌刷新响应都会发出新的刷新令牌。
   以前的刷新令牌无效,但由授权服务器保留。 如果刷新令牌被攻击者和合法客户端破坏并
   随后使用,其中一个将呈现无效刷新令牌,这将通知授权服务器违反。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 




 
   授权服务器必须确保无法生成、修改或猜测刷新令牌,以便未经授权的方生成有效的刷新令牌。
 
10.5.  授权码
 
   授权码的传输应通过安全通道进行,如果 URI 标识网络资源,则客户端应要求使用 TLS 及其
   重定向 URI。 由于授权码是通过用户代理重定向传输的,因此可能通过用户代理历史记录和
   HTTP 引用标头进行公开。
 
   授权代码作为纯文本承载凭据运行,用于验证在授权服务器上授予授权的资源所有者是否与返回
   客户端以完成该过程的资源所有者相同。 因此,如果客户端依赖于其自己的资源所有者身份
   验证的授权代码,则客户端重定向节点必须要求使用 TLS。
 
   授权代码必须是短期的和一次性的。 如果授权服务器观察到多次尝试为访问令牌交换授权
   代码,则授权服务器应尝试撤销基于受攻击的授权代码已授予的所有访问令牌。
 
   如果客户端可以进行身份验证,则授权服务器必须对客户端进行身份验证,并确保授权代码已
   颁发给同一客户端。
 
10.6.  授权码重定向 URI 操作
 
   使用授权代码授予类型请求授权时,客户端可以通过"redirect_uri"参数指定重定向 URI。
   如果攻击者可以操作重定向 URI 的值,则可能导致授权服务器使用授权代码将资源所有者用户
   代理重定向到由攻击者控制的 URI。
 
   攻击者可以在合法客户端创建帐户并启动授权流。 当攻击者的用户代理发送到授权服务器以
   授予访问权限时,攻击者将获取合法客户端提供的授权 URI,并将客户端的重定向 URI 替换为
   攻击者控制下的 URI。 然后,攻击者诱使受害者跟踪受操作的链接,以授权对合法客户端的
   访问。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 



 
   在授权服务器访问后,将提示受害者代表合法且受信任的客户端发出正常、有效的请求,并授权
   该请求。 然后,受害者被重定向到攻击者控制下的节点,并带有授权代码。 攻击者使用客户端
   提供的原始重定向 URI 将授权码发送到客户端,从而完成授权流。 客户端使用访问令牌交换
   授权码,并将其链接到攻击者的客户端帐户,攻击者现在可以访问受害者授权的受保护资源
   (通过客户端)。
 
   为了防止此类攻击,授权服务器必须确保用于获取授权代码的重定向 URI 与交换访问令牌的
   授权码时提供的重定向 URI 相同。 授权服务器必须要求公共客户端,并且应要求机密客户端
   注册其重定向 URI。 如果在请求中提供了重定向 URI,则授权服务器必须根据已注册的值对
   其进行验证。
 








10.7.  资源所有者密码凭据
 
   资源所有者密码凭据授予类型通常用于旧版或迁移原因。 它降低了客户端存储用户名和密码的
   总体风险,但无法消除向客户端公开高特权凭据的需要。
 
   此授予类型比其他授予类型具有更高的风险,因为它维护了此协议要避免的密码反模式。客户端
   可能会滥用密码,或者密码可能会无意中泄露给攻击者(例如,通过日志文件或客户端保存的
   其他记录)。
 
   此外,由于资源所有者无法控制授权过程(资源所有者的介入在将凭据交给客户端时结束),因此
   客户端可以获取访问令牌,其范围与资源所有者一致。 授权服务器应考虑通过此授予类型颁发
   的访问令牌的范围和生存期。
 
   授权服务器和客户端应尽量减少使用此授予类型的服务,并尽可能利用其他授予类型。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
10.8.  请求保密
 
   不得以明晰的方式传输访问令牌、刷新令牌、资源所有者密码和客户端凭据。 授权码不应以
   明示传输。
 
   "状态"和"范围"参数不应包含纯文本中的敏感客户端或资源所有者信息,因为它们可以通过
   不安全的通道传输或不安全地存储。
 
10.9.  确保节点真实性
 
   为了防止中间人攻击,授权服务器必须要求对发送到授权和令牌终结点的任何请求使用 TLS 和
   由 [RFC2818] 定义的服务器身份验证。 客户端必须验证授权服务器的 TLS 证书,该证书
   由 [RFC6125] 定义,并符合其服务器标识身份验证的要求。
 



10.10.  凭据猜测攻击
 
   授权服务器必须防止攻击者猜测访问令牌、授权代码、刷新令牌、资源所有者密码和客户端
   凭据。
 
   攻击者猜测生成的令牌(以及不打算由最终用户处理的其他凭据)的概率MUST小于或等于
    2^(-128),并且SHOULD小于或等于 2^(-160)。
 
   授权服务器必须使用其他方法来保护用于最终用户使用的凭据。
 
10.11.  网络钓鱼攻击
 
   广泛部署此协议和类似协议可能会导致最终用户习惯于被重定向到要求他们输入密码的网站。
   如果最终用户在输入凭据之前不谨慎验证这些网站的真实性,攻击者可能会利用这种做法窃取
   资源所有者的密码。
 
   服务提供商应尝试教育最终用户了解网络钓鱼攻击带来的风险,并应提供机制,使最终用户能够
   轻松地确认其网站的真实性。 客户端开发人员应考虑他们如何与用户代理(例如外部、
   嵌入式)交互的安全影响,以及最终用户验证授权服务器真实性的能力。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   为了降低网络钓鱼攻击的风险,授权服务器必须在用于最终用户交互的每个节点上使用 TLS。
 
10.12.  跨站点请求伪造
 
   跨站点请求伪造 (CSRF) 是一种漏洞,攻击者利用此漏洞,使受害最终用户的用户代理遵循
   恶意 URI(例如,作为误导性链接、图像或重定向提供给用户代理)到信任服务器(通常通过
   存在有效的会话 Cookie)。
 
   CSRF 攻击客户端的重定向 URI 允许攻击者注入其自己的授权代码或访问令牌,这可能导致
   客户端使用与攻击者受保护资源关联的访问令牌,而不是受害者的访问令牌(例如,保存受害者
   的银行账户信息到由攻击者控制的受保护资源)。
 
   客户端必须为其重定向 URI 实现 CSRF 保护。这通常是通过要求发送到重定向 URI 节点
   的任何请求来包括将请求绑定到用户代理的身份验证状态的值(例如,用于验证用户代理的会话
   Cookie 的哈希)。发出授权请求时,客户端应利用"状态"请求参数将此值传递到授权
   服务器。
 
   从最终用户获得授权后,授权服务器将最终用户的用户代理重定向回客户端,其中包含"state"
   参数中所需的绑定值。绑定值使客户端能够通过将绑定值与用户代理的身份验证状态匹配来
   验证请求的有效性。 用于 CSRF 保护的绑定值必须包含不可猜测的值(如第 10.10 节
   所述),并且用户代理的身份验证状态(例如会话 Cookie、HTML5 本地存储)必须保存在只有
   客户端和用户才能访问的位置。代理(即受同源策略保护)。
 
   对授权服务器的授权节点进行 CSRF 攻击可能导致攻击者获取恶意客户端的最终用户授权,
   而无需涉及最终用户或向最终用户发出警报。
 
   授权服务器必须为其授权节点实现 CSRF 保护,并确保恶意客户端在没有资源所有者的认知和
   明确同意的情况下无法获得授权。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
10.13.  点击劫持
 
   在点击劫持攻击中,攻击者注册合法客户端,然后构建一个恶意站点,其中它将授权服务器的
   授权节点网页加载在覆盖在一组虚拟按钮之上的透明 iframe 中,这些按钮是小心的直接放置
   在授权页面上的重要按钮下。 当最终用户单击误导性的可见按钮时,最终用户实际上是在单击
   授权页面上的不可见按钮(如"授权"按钮)。 这允许攻击者欺骗资源所有者在最终用户不知情
   的情况下授予其客户端访问权限。
 
   为了防止这种攻击形式,本机应用程序在请求最终用户授权时应使用外部浏览器,而不是在应用
   程序中嵌入浏览器。 对于大多数较新的浏览器,授权服务器可以使用(非标准)
   "x-frame-options" 标头强制避免 iframe。 此标头可以有两个值,"deny"和
   "sameorigin",将分别阻止任何框架,或按具有不同源的站点进行帧。 对于较旧的浏览器,
   可以使用 JavaScript frame-busting 技术,但可能并非在所有浏览器中都有效。
 






10.14.  代码注入和输入验证
 
   当在不安全的应用程序使用输入或其他外部变量并导致对应用程序逻辑进行修改时,将发生
   代码注入攻击。 这可能允许攻击者访问应用程序设备或其数据,导致拒绝服务,或引入各种
   恶意副作用。
 
   授权服务器和客户端必须清理(并在可能的情况下验证)收到的任何值 -- 特别是"state"
   和"redirect_uri"参数的值。
 
10.15.  开放式重定向
 
   授权服务器、授权终结点和客户端重定向终结点可以错误地配置,并作为打开的重定向器运行。
   打开的重定向器是使用参数自动将用户代理重定向到参数值指定的位置而不进行任何验证的
   节点。
 
   开放重定向器可用于网络钓鱼攻击,或者攻击者可以使用熟悉且受信任的目标的 URI 权限
   组件让最终用户访问恶意网站。 此外,如果授权服务器允许客户端仅注册重定向 URI 的
   一部分,则攻击者可以使用由客户端操作的开放式重定向器来构造重定向 URI,该 URI 将
   通过授权服务器验证,但会发送在攻击者的控制下,将代码或访问令牌访问到终结点。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 



 
10.16.  滥用访问令牌在隐式流中模拟资源所有者
 
   对于使用隐式流的公共客户端,此规范不提供任何方法供客户端确定向哪些客户端发出访问
   令牌。
 
   资源所有者可能愿意通过将访问令牌授予攻击者的恶意客户端来委派对资源的访问权限。这
   可能是由于网络钓鱼或其他一些借口。 攻击者还可能通过其他机制窃取令牌。 然后,攻击者
   可能会尝试通过向合法的公共客户端提供访问令牌来模拟资源所有者。
 
   在隐式流(response_type_token)中,攻击者可以轻松地从授权服务器切换响应中的令牌,
   将实际访问令牌替换为以前发给攻击者的访问令牌。
 
   与依赖于在后通道中传递访问令牌以识别客户端用户的本机应用程序通信的服务器可能会受到
   攻击者的类似危害,攻击者会创建可能注入任意窃取的入侵应用程序。
 
   任何假定只有资源所有者才能为资源提供有效的访问令牌的公共客户端都容易受到此类攻击。
 
   这种类型的攻击可能会向攻击者(恶意客户端)公开有关合法客户端的资源所有者的信息。
   这还允许攻击者使用与最初授予访问令牌或授权代码的资源所有者相同的权限在合法客户端
   执行操作。
 
   将资源所有者验证为客户端已不属于此规范的范围。 使用授权过程作为委托给客户端的最终
   用户身份验证形式的任何规范(例如,第三方登录服务)不得使用隐式流,而无需其他安全机制,
   使客户端能够确定如果访问令牌是为其使用而颁发的(例如,访问群体 - 限制访问令牌)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
11.  IANA 注意事项
 
11.1.  OAuth 访问令牌类型注册表
 
   此规范建立 OAuth 访问令牌类型注册表。
 
   Access token types are registered with a Specification Required   ([RFC5226]) after a two-week review period on the
   oauth-ext-review@ietf.org mailing list, on the advice of one or more   Designated Experts.  However, to allow for the allocation of values   prior to publication, the Designated Expert(s) may approve   registration once they are satisfied that such a specification will   be published.
 
   Registration requests must be sent to the oauth-ext-review@ietf.org   mailing list for review and comment, with an appropriate subject   (e.g., "Request for access token type: example").
 
   Within the review period, the Designated Expert(s) will either   approve or deny the registration request, communicating this decision   to the review list and IANA.  Denials should include an explanation   and, if applicable, suggestions as to how to make the request   successful.
 
   IANA must only accept registry updates from the Designated Expert(s)   and should direct all requests for registration to the review mailing   list.
 
11.1.1.  注册模板
 
   Type name:
      The name requested (e.g., "example").
 
   Additional Token Endpoint Response Parameters:
      其他响应参数与"access_token"参数一起返回。 新参数必须在 OAuth 参数注册表中
      单独注册,如第 11.2 节所述。
 
   HTTP Authentication Scheme(s):
      HTTP 身份验证方案名称(如果有)用于使用此类型的访问令牌对受保护的资源请求进行
      身份验证。
 
   Change controller:
      对于标准跟踪 RFC,状态为"IETF"。 对于其他,请说出责任方的名称。 其他详细信息
      (例如邮寄地址、电子邮件地址、主页 URI)也可能包括在内。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Specification document(s):
      对指定参数的文档的引用,最好包括可用于检索文档副本的 URI。 还可包括相关章节的
      指示,但不是必需的。
 
11.2.  OAuth 参数注册
 
   此规范建立 OAuth 参数注册表。

   Additional parameters for inclusion in the authorization endpoint
   request, the authorization endpoint response, the token endpoint
   request, or the token endpoint response are registered with a
   Specification Required ([RFC5226]) after a two-week review period on
   the oauth-ext-review@ietf.org mailing list, on the advice of one or
   more Designated Experts.  However, to allow for the allocation of
   values prior to publication, the Designated Expert(s) may approve
   registration once they are satisfied that such a specification will
   be published.

   Registration requests must be sent to the oauth-ext-review@ietf.org
   mailing list for review and comment, with an appropriate subject
   (e.g., "Request for parameter: example").

   Within the review period, the Designated Expert(s) will either
   approve or deny the registration request, communicating this decision
   to the review list and IANA.  Denials should include an explanation
   and, if applicable, suggestions as to how to make the request
   successful.

   IANA must only accept registry updates from the Designated Expert(s)
   and should direct all requests for registration to the review mailing
   list.
11.2.1.  注册模板
 
   Parameter name:
      The name requested (e.g., "example").

   Parameter usage location:
      可以使用参数的位置。 可能的位置是授权请求、授权响应、令牌请求或令牌响应。

   Change controller:
      对于标准跟踪 RFC,状态为"IETF"。 对于其他人,需要责任方的名称。 其他详细信息
      (例如邮寄地址、电子邮件地址、主页 URI)也可能包括在内。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Specification document(s):
      对指定参数的文档的引用,最好包括可用于检索文档副本的 URI。 还可包括相关章节的
      指示,但不是必需的。
 
11.2.2.  初始注册表内容
 
   OAuth 参数注册表的初始内容是:
 
   o  Parameter name: client_id
   o  Parameter usage location: authorization request, token request
   o  Change controller: IETF
   o  Specification document(s): RFC 6749
 
   o  Parameter name: client_secret
   o  Parameter usage location: token request
   o  Change controller: IETF
   o  Specification document(s): RFC 6749
 
   o  Parameter name: response_type
   o  Parameter usage location: authorization request
   o  Change controller: IETF
   o  Specification document(s): RFC 6749
 
   o  Parameter name: redirect_uri
   o  Parameter usage location: authorization request, token request
   o  Change controller: IETF
   o  Specification document(s): RFC 6749
 
   o  Parameter name: scope
   o  Parameter usage location: authorization request, authorization
      response, token request, token response
   o  Change controller: IETF
   o  Specification document(s): RFC 6749
 
   o  Parameter name: state
   o  Parameter usage location: authorization request, authorization
      response
   o  Change controller: IETF
   o  Specification document(s): RFC 6749
 
   o  Parameter name: code
   o  Parameter usage location: authorization response, token request
   o  Change controller: IETF
   o  Specification document(s): RFC 6749</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   o  Parameter name: error_description
   o  Parameter usage location: authorization response, token response
   o  Change controller: IETF
   o  Specification document(s): RFC 6749
 
   o  Parameter name: error_uri
   o  Parameter usage location: authorization response, token response
   o  Change controller: IETF
   o  Specification document(s): RFC 6749
 
   o  Parameter name: grant_type
   o  Parameter usage location: token request
   o  Change controller: IETF
   o  Specification document(s): RFC 6749
 
   o  Parameter name: access_token
   o  Parameter usage location: authorization response, token response
   o  Change controller: IETF
   o  Specification document(s): RFC 6749
 
   o  Parameter name: token_type
   o  Parameter usage location: authorization response, token response
   o  Change controller: IETF
   o  Specification document(s): RFC 6749
 
   o  Parameter name: expires_in
   o  Parameter usage location: authorization response, token response
   o  Change controller: IETF
   o  Specification document(s): RFC 6749
 
   o  Parameter name: username
   o  Parameter usage location: token request
   o  Change controller: IETF
   o  Specification document(s): RFC 6749
 
   o  Parameter name: password
   o  Parameter usage location: token request
   o  Change controller: IETF
   o  Specification document(s): RFC 6749
 
   o  Parameter name: refresh_token
   o  Parameter usage location: token request, token response
   o  Change controller: IETF
   o  Specification document(s): RFC 6749</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
11.3.  OAuth Authorization Endpoint Response Types Registry

   This specification establishes the OAuth Authorization Endpoint
   Response Types registry.

   Additional response types for use with the authorization endpoint are
   registered with a Specification Required ([RFC5226]) after a two-week
   review period on the oauth-ext-review@ietf.org mailing list, on the
   advice of one or more Designated Experts.  However, to allow for the
   allocation of values prior to publication, the Designated Expert(s)
   may approve registration once they are satisfied that such a
   specification will be published.

   Registration requests must be sent to the oauth-ext-review@ietf.org
   mailing list for review and comment, with an appropriate subject
   (e.g., "Request for response type: example").

   Within the review period, the Designated Expert(s) will either
   approve or deny the registration request, communicating this decision
   to the review list and IANA.  Denials should include an explanation
   and, if applicable, suggestions as to how to make the request
   successful.

   IANA must only accept registry updates from the Designated Expert(s)
   and should direct all requests for registration to the review mailing
   list.

11.3.1.  Registration Template

   Response type name:
      The name requested (e.g., "example").

   Change controller:
      For Standards Track RFCs, state "IETF".  For others, give the name
      of the responsible party.  Other details (e.g., postal address,
      email address, home page URI) may also be included.

   Specification document(s):
      Reference to the document(s) that specify the type, preferably
      including a URI that can be used to retrieve a copy of the
      document(s).  An indication of the relevant sections may also be
      included but is not required.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
11.3.2.  Initial Registry Contents

   The OAuth Authorization Endpoint Response Types registry's initial
   contents are:

   o  Response type name: code
   o  Change controller: IETF
   o  Specification document(s): RFC 6749

   o  Response type name: token
   o  Change controller: IETF
   o  Specification document(s): RFC 6749

11.4.  OAuth Extensions Error Registry

   This specification establishes the OAuth Extensions Error registry.

   Additional error codes used together with other protocol extensions
   (i.e., extension grant types, access token types, or extension
   parameters) are registered with a Specification Required ([RFC5226])
   after a two-week review period on the oauth-ext-review@ietf.org
   mailing list, on the advice of one or more Designated Experts.
   However, to allow for the allocation of values prior to publication,
   the Designated Expert(s) may approve registration once they are
   satisfied that such a specification will be published.

   Registration requests must be sent to the oauth-ext-review@ietf.org
   mailing list for review and comment, with an appropriate subject
   (e.g., "Request for error code: example").

   Within the review period, the Designated Expert(s) will either
   approve or deny the registration request, communicating this decision
   to the review list and IANA.  Denials should include an explanation
   and, if applicable, suggestions as to how to make the request
   successful.

   IANA must only accept registry updates from the Designated Expert(s)
   and should direct all requests for registration to the review mailing
   list.
</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
11.4.1.  Registration Template

   Error name:
      The name requested (e.g., "example").  Values for the error name
      MUST NOT include characters outside the set %x20-21 / %x23-5B /
      %x5D-7E.

   Error usage location:
      The location(s) where the error can be used.  The possible
      locations are authorization code grant error response
      (Section 4.1.2.1), implicit grant error response
      (Section 4.2.2.1), token error response (Section 5.2), or resource
      access error response (Section 7.2).

   Related protocol extension:
      The name of the extension grant type, access token type, or
      extension parameter that the error code is used in conjunction
      with.

   Change controller:
      For Standards Track RFCs, state "IETF".  For others, give the name
      of the responsible party.  Other details (e.g., postal address,
      email address, home page URI) may also be included.

   Specification document(s):
      Reference to the document(s) that specify the error code,
      preferably including a URI that can be used to retrieve a copy of
      the document(s).  An indication of the relevant sections may also
      be included but is not required.
 
12.  参考
 
12.1.  规范参考
 
   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC2246]  Dierks, T. and C. Allen, "The TLS Protocol Version 1.0",
              RFC 2246, January 1999.

   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext
              Transfer Protocol -- HTTP/1.1", RFC 2616, June 1999.

   [RFC2617]  Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,
              Leach, P., Luotonen, A., and L. Stewart, "HTTP
              Authentication: Basic and Digest Access Authentication",
              RFC 2617, June 1999.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [RFC2818]  Rescorla, E., "HTTP Over TLS", RFC 2818, May 2000.

   [RFC3629]  Yergeau, F., "UTF-8, a transformation format of
              ISO 10646", STD 63, RFC 3629, November 2003.

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              RFC 3986, January 2005.

   [RFC4627]  Crockford, D., "The application/json Media Type for
              JavaScript Object Notation (JSON)", RFC 4627, July 2006.

   [RFC4949]  Shirey, R., "Internet Security Glossary, Version 2",
              RFC 4949, August 2007.

   [RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", BCP 26, RFC 5226,
              May 2008.

   [RFC5234]  Crocker, D. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", STD 68, RFC 5234, January 2008.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246, August 2008.

   [RFC6125]  Saint-Andre, P. and J. Hodges, "Representation and
              Verification of Domain-Based Application Service Identity
              within Internet Public Key Infrastructure Using X.509
              (PKIX) Certificates in the Context of Transport Layer
              Security (TLS)", RFC 6125, March 2011.

   [USASCII]  American National Standards Institute, "Coded Character
              Set -- 7-bit American Standard Code for Information
              Interchange", ANSI X3.4, 1986.

   [W3C.REC-html401-19991224]
              Raggett, D., Le Hors, A., and I. Jacobs, "HTML 4.01
              Specification", World Wide Web Consortium
              Recommendation REC-html401-19991224, December 1999,
              http://www.w3.org/TR/1999/REC-html401-19991224.

   [W3C.REC-xml-20081126]
              Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E.,
              and F. Yergeau, "Extensible Markup Language (XML) 1.0
              (Fifth Edition)", World Wide Web Consortium
               Recommendation REC-xml-20081126, November 2008,
              http://www.w3.org/TR/2008/REC-xml-20081126.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
12.2.  Informative References

   [OAuth-HTTP-MAC]
              Hammer-Lahav, E., Ed., "HTTP Authentication: MAC Access
              Authentication", Work in Progress, February 2012.

   [OAuth-SAML2]
              Campbell, B. and C. Mortimore, "SAML 2.0 Bearer Assertion
              Profiles for OAuth 2.0", Work in Progress, September 2012.

   [OAuth-THREATMODEL]
              Lodderstedt, T., Ed., McGloin, M., and P. Hunt, "OAuth 2.0
              Threat Model and Security Considerations", Work
              in Progress, October 2012.

   [OAuth-WRAP]
              Hardt, D., Ed., Tom, A., Eaton, B., and Y. Goland, "OAuth
              Web Resource Authorization Profiles", Work in Progress,
              January 2010.

   [RFC5849]  Hammer-Lahav, E., "The OAuth 1.0 Protocol", RFC 5849,
              April 2010.

   [RFC6750]  Jones, M. and D. Hardt, "The OAuth 2.0 Authorization
              Framework: Bearer Token Usage", RFC 6750, October 2012.
</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
Appendix A.  Augmented Backus-Naur Form (ABNF) Syntax

   This section provides Augmented Backus-Naur Form (ABNF) syntax
   descriptions for the elements defined in this specification using the
   notation of [RFC5234].  The ABNF below is defined in terms of Unicode
   code points [W3C.REC-xml-20081126]; these characters are typically
   encoded in UTF-8.  Elements are presented in the order first defined.

   Some of the definitions that follow use the "URI-reference"
   definition from [RFC3986].

   Some of the definitions that follow use these common definitions:

     VSCHAR     = %x20-7E
     NQCHAR     = %x21 / %x23-5B / %x5D-7E
     NQSCHAR    = %x20-21 / %x23-5B / %x5D-7E
     UNICODECHARNOCRLF = %x09 /%x20-7E / %x80-D7FF /
                         %xE000-FFFD / %x10000-10FFFF

   (The UNICODECHARNOCRLF definition is based upon the Char definition
   in Section 2.2 of [W3C.REC-xml-20081126], but omitting the Carriage
   Return and Linefeed characters.)

A.1.  "client_id" Syntax

   The "client_id" element is defined in Section 2.3.1:

     client-id     = *VSCHAR

A.2.  "client_secret" Syntax

   The "client_secret" element is defined in Section 2.3.1:

     client-secret = *VSCHAR

A.3.  "response_type" Syntax

   The "response_type" element is defined in Sections 3.1.1 and 8.4:

     response-type = response-name *( SP response-name )
     response-name = 1*response-char
     response-char = "_" / DIGIT / ALPHA</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
A.4.  "scope" Syntax
 
   The "scope" element is defined in Section 3.3:
 
     scope       = scope-token *( SP scope-token )
     scope-token = 1*NQCHAR
 
A.5.  "state" Syntax
 
   The "state" element is defined in Sections 4.1.1, 4.1.2, 4.1.2.1,
   4.2.1, 4.2.2, and 4.2.2.1:
 
     state      = 1*VSCHAR
 
A.6.  "redirect_uri" Syntax
 
   The "redirect_uri" element is defined in Sections 4.1.1, 4.1.3,
   and 4.2.1:
 
     redirect-uri      = URI-reference
 
A.7.  "error" Syntax
 
   The "error" element is defined in Sections 4.1.2.1, 4.2.2.1, 5.2,   7.2, and 8.5:
 
     error             = 1*NQSCHAR
 
A.8.  "error_description" Syntax
 
   The "error_description" element is defined in Sections 4.1.2.1,   4.2.2.1, 5.2, and 7.2:
 
     error-description = 1*NQSCHAR
 
A.9.  "error_uri" Syntax
 
   The "error_uri" element is defined in Sections 4.1.2.1, 4.2.2.1, 5.2,
   and 7.2:
 
     error-uri         = URI-reference</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
A.10.  "grant_type" Syntax
 
   The "grant_type" element is defined in Sections 4.1.3, 4.3.2, 4.4.2,   4.5, and 6:
 
     grant-type = grant-name / URI-reference
     grant-name = 1*name-char
     name-char  = "-" / "." / "_" / DIGIT / ALPHA
 
A.11.  "code" Syntax
 
   The "code" element is defined in Section 4.1.3:
 
     code       = 1*VSCHAR
 
A.12.  "access_token" Syntax
 
   The "access_token" element is defined in Sections 4.2.2 and 5.1:
 
     access-token = 1*VSCHAR
 
A.13.  "token_type" Syntax
 
   The "token_type" element is defined in Sections 4.2.2, 5.1, and 8.1:
 
     token-type = type-name / URI-reference
     type-name  = 1*name-char
     name-char  = "-" / "." / "_" / DIGIT / ALPHA
 
A.14.  "expires_in" Syntax
 
   The "expires_in" element is defined in Sections 4.2.2 and 5.1:
 
     expires-in = 1*DIGIT
 
A.15.  "username" Syntax
 
   The "username" element is defined in Section 4.3.2:
 
     username = *UNICODECHARNOCRLF
 
A.16.  "password" Syntax
 
   The "password" element is defined in Section 4.3.2:
 
     password = *UNICODECHARNOCRLF</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
A.17.  "refresh_token" Syntax
 
   The "refresh_token" element is defined in Sections 5.1 and 6:
 
     refresh-token = 1*VSCHAR
 
A.18.  Endpoint Parameter Syntax
 
   The syntax for new endpoint parameters is defined in Section 8.2:
 
     param-name = 1*name-char
     name-char  = "-" / "." / "_" / DIGIT / ALPHA
 
Appendix B.  Use of application/x-www-form-urlencoded Media Type

   At the time of publication of this specification, the
   "application/x-www-form-urlencoded" media type was defined in
   Section 17.13.4 of [W3C.REC-html401-19991224] but not registered in
   the IANA MIME Media Types registry
   (<http: www.iana.org="" assignments="" media-types="">).  Furthermore, that
   definition is incomplete, as it does not consider non-US-ASCII
   characters.

   To address this shortcoming when generating payloads using this media
   type, names and values MUST be encoded using the UTF-8 character
   encoding scheme [RFC3629] first; the resulting octet sequence then
   needs to be further encoded using the escaping rules defined in
   [W3C.REC-html401-19991224].

   When parsing data from a payload using this media type, the names and
   values resulting from reversing the name/value encoding consequently
   need to be treated as octet sequences, to be decoded using the UTF-8
   character encoding scheme.

   For example, the value consisting of the six Unicode code points
   (1) U+0020 (SPACE), (2) U+0025 (PERCENT SIGN),
   (3) U+0026 (AMPERSAND), (4) U+002B (PLUS SIGN),
   (5) U+00A3 (POUND SIGN), and (6) U+20AC (EURO SIGN) would be encoded
   into the octet sequence below (using hexadecimal notation):

     20 25 26 2B C2 A3 E2 82 AC

   and then represented in the payload as:

     +%25%26%2B%C2%A3%E2%82%AC</http:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
Appendix C.  Acknowledgements

   The initial OAuth 2.0 protocol specification was edited by David
   Recordon, based on two previous publications: the OAuth 1.0 community
   specification [RFC5849], and OAuth WRAP (OAuth Web Resource
   Authorization Profiles) [OAuth-WRAP].  Eran Hammer then edited many
   of the intermediate drafts that evolved into this RFC.  The Security
   Considerations section was drafted by Torsten Lodderstedt, Mark
   McGloin, Phil Hunt, Anthony Nadalin, and John Bradley.  The section
   on use of the "application/x-www-form-urlencoded" media type was
   drafted by Julian Reschke.  The ABNF section was drafted by Michael
   B. Jones.

   The OAuth 1.0 community specification was edited by Eran Hammer and
   authored by Mark Atwood, Dirk Balfanz, Darren Bounds, Richard M.
   Conlan, Blaine Cook, Leah Culver, Breno de Medeiros, Brian Eaton,
   Kellan Elliott-McCrea, Larry Halff, Eran Hammer, Ben Laurie, Chris
   Messina, John Panzer, Sam Quigley, David Recordon, Eran Sandler,
   Jonathan Sergent, Todd Sieling, Brian Slesinsky, and Andy Smith.

   The OAuth WRAP specification was edited by Dick Hardt and authored by
   Brian Eaton, Yaron Y. Goland, Dick Hardt, and Allen Tom.

   This specification is the work of the OAuth Working Group, which
   includes dozens of active and dedicated participants.  In particular,
   the following individuals contributed ideas, feedback, and wording
   that shaped and formed the final specification:

   Michael Adams, Amanda Anganes, Andrew Arnott, Dirk Balfanz, Aiden
   Bell, John Bradley, Marcos Caceres, Brian Campbell, Scott Cantor,
   Blaine Cook, Roger Crew, Leah Culver, Bill de hOra, Andre DeMarre,
   Brian Eaton, Wesley Eddy, Wolter Eldering, Brian Ellin, Igor
   Faynberg, George Fletcher, Tim Freeman, Luca Frosini, Evan Gilbert,
   Yaron Y. Goland, Brent Goldman, Kristoffer Gronowski, Eran Hammer,
   Dick Hardt, Justin Hart, Craig Heath, Phil Hunt, Michael B. Jones,
   Terry Jones, John Kemp, Mark Kent, Raffi Krikorian, Chasen Le Hara,
   Rasmus Lerdorf, Torsten Lodderstedt, Hui-Lan Lu, Casey Lucas, Paul
   Madsen, Alastair Mair, Eve Maler, James Manger, Mark McGloin,
   Laurence Miao, William Mills, Chuck Mortimore, Anthony Nadalin,
   Julian Reschke, Justin Richer, Peter Saint-Andre, Nat Sakimura, Rob
   Sayre, Marius Scurtescu, Naitik Shah, Luke Shepard, Vlad Skvortsov,
   Justin Smith, Haibin Song, Niv Steingarten, Christian Stuebner,
   Jeremy Suriel, Paul Tarjan, Christopher Thomas, Henry S. Thompson,
   Allen Tom, Franklin Tse, Nick Walker, Shane Weeden, and Skylar
   Woodward.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   This document was produced under the chairmanship of Blaine Cook,
   Peter Saint-Andre, Hannes Tschofenig, Barry Leiba, and Derek Atkins.
   The area directors included Lisa Dusseault, Peter Saint-Andre, and
   Stephen Farrell.

Author's Address

   Dick Hardt (editor)
   Microsoft

   EMail: dick.hardt@gmail.com
   URI:   http://dickhardt.org/
 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 
Hardt                        Standards Track                   [Page 76]</pre><br>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.129c, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>
