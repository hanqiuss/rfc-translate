<div class="content" style="float: left; margin: 0px 30%; width: 579px; font-size: 10pt;">
   <div style="height: 13px;">
      <div onmouseover="this.style.cursor='pointer';" onclick="showElem('legend');" onmouseout="hideElem('legend')" style="height: 6px; position: absolute; cursor: pointer;" class="pre noprint docinfo bgblue" title="Click for colour legend.">                                                                        </div>
      <div id="legend" class="docinfo noprint pre legend" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; " onmouseover="showElem('legend');" onmouseout="hideElem('legend');">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="../html/" title="Document search and retrieval page">Docs</a>] [<a href="/rfc/rfc8446.txt" title="Plaintext version of this document">txt</a>|<a href="/pdf/rfc8446" title="PDF version of this document">pdf</a>] [<a href="./draft-ietf-tls-tls13" title="draft-ietf-tls-tls13">draft-ietf-tls-...</a>] [<a href="https://datatracker.ietf.org/doc/rfc8446" title="IESG Datatracker information for this document">Tracker</a>] [<a href="/rfcdiff?difftype=--hwdiff&amp;url2=rfc8446" title="Inline diff (wdiff)">Diff1</a>] [<a href="/rfcdiff?url2=rfc8446" title="Side-by-side diff">Diff2</a>] [<a href="https://datatracker.ietf.org/ipr/search/?rfc=8446&amp;submit=rfc" title="IPR disclosures related to this document">IPR</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=8446">Errata</a>]</span><br>
<span class="pre noprint docinfo">                                                                        </span><br>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br>
<pre style="height: 780px; white-space: pre-wrap;">Internet Engineering Task Force (IETF)                       E. Rescorla
Request for Comments: 8446                                       Mozilla
Obsoletes: 5077, 5246, 6961                                  August 2018
Updates: 5705, 6066
类别: 标准跟踪
ISSN: 2070-1721
 

        The Transport Layer Security (TLS) Protocol Version 1.3
 
摘要
 
   本文档规定了传输层安全(TLS)协议的1.3版。TLS允许客户端/服务器应用程序通过
   Internet以一种旨在防止窃听、篡改和消息伪造的方式进行通信。
 
   本文档更新了RFC 5705和6066，并废弃了RFC 5077、5246和6961。本文档还指定了
   TLS 1.2实现的新要求。
 
备忘录状态
 
   这是Internet标准跟踪文档。
 
   本文档是Internet工程任务组(IETF)的产品。它代表了IETF社区的共识。它已经接受了
   公众的审查，并已被互联网工程指导小组(IESG)批准出版。有关Internet标准的更多信息，
   请参阅 RFC 7841 的第2节。
 
   有关本文档的当前状态、任何勘误表以及如何提供反馈的信息，请访问。
   https://www.rfc-editor.org/info/rfc8446.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
Copyright Notice

   Copyright (c) 2018 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (https://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
目录
 <p style="font-family: 新宋体;">
   1. 简介         ....................................................6
      1.1. 公约和术语                  ................................7
      1.2. 与 TLS 1.2 的主要区别          .............................8
      1.3. 影响 TLS 1.2 的更新       ..................................9
   2. 协议概述          ..............................................10
      2.1. 不正确的 DHE 共享   .......................................14
      2.2. 恢复和预共享密钥(PSK)               .......................15
      2.3. 0-RTT数据  ................................................17
   3. 演示语言              ..........................................19
      3.1. 基本块大小       ..........................................19
      3.2. 杂项          .............................................20
      3.3. 数字    ...................................................20
      3.4. 向量    ...................................................20
      3.5. 枚举        ...............................................21
      3.6. 构造类型          .........................................22
      3.7. 常量      .................................................23
      3.8. 变体     ..................................................23
   4. 握手协议           .............................................24
      4.1. 密钥交换消息          .....................................25
           4.1.1. 加密协商                  ..........................26
           4.1.2. Client Hello .......................................27
           4.1.3. Server Hello .......................................31
           4.1.4. Hello重试请求       ................................33
      4.2. 扩展       ................................................35
           4.2.1. 支持的版本         .................................39
           4.2.2. Cookie .............................................40
           4.2.3. 签名算法             ...............................41
           4.2.4. 证书颁发机构            ............................45
           4.2.5. OID过滤器   ........................................45
           4.2.6. 握手后客户端身份验证                 ...............47
           4.2.7. 支持的组         ...................................47
           4.2.8. 密钥共享  ..........................................48
           4.2.9. 预共享密钥交换模式            ......................51
           4.2.10. 早期数据指示          .............................52
           4.2.11. 预共享密钥扩展           ..........................55
      4.3. 服务器参数        .........................................59
           4.3.1. 加密扩展             ...............................60
           4.3.2. 证书请求            ................................60
      4.4. 身份验证消息            ...................................61
           4.4.1. The Transcript Hash ................................63
           4.4.2. Certificate ........................................64
           4.4.3. Certificate Verify .................................69
           4.4.4. Finished ...........................................71
      4.5. 早期数据结束      .........................................72
</p></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

  <p style="font-family: 新宋体;">
      4.6. 握手后消息              ...................................73
           4.6.1. 新会话票证消息             .........................73
           4.6.2. 握手后身份验证                ......................75
           4.6.3. 密钥和初始化矢量更新                 ...............76
   5. 记录协议        ................................................77
      5.1. 记录层       ..............................................78
      5.2. 记录有效负载保护          .................................80
      5.3. Per-Record随机数 ..........................................82
      5.4. Record 填充    ............................................83
      5.5. 密钥使用限制        .......................................84
   6. 警报协议       .................................................85
      6.1. 关闭警报       ............................................87
      6.2. 错误警报     ..............................................88
   7. 密码计算                   .....................................90
      7.1. 密钥明细表   ..............................................91
      7.2. 更新流通密码             ..................................94
      7.3. 流通密码计算            ...................................95
      7.4. (EC)DHE共享密钥计算               .........................95
           7.4.1. 有限域Diffie-Hellman        ........................95
           7.4.2. 椭圆曲线Diffie-Hellman        ......................96
      7.5. Exporters .................................................97
   8. 0-RTT 和防重放        ..........................................98
      8.1. 单次票据           ........................................99
      8.2. Client Hello Recording ....................................99
      8.3. Freshness Checks .........................................101
   9. 合规要求                .......................................102
      9.1. 强制实施密码套件                     .....................102
      9.2. 强制实施扩展                      ........................103
      9.3. 协议不变量          ......................................104
   10. 安全注意事项            ......................................106
   11. IANA 注意事项       ..........................................106
   12. 参考       ...................................................109
      12.1. 标准参考             ....................................109
      12.2. 信息参考               ..................................112
   附录 A. 状态机            ........................................120
     A.1. Client ....................................................120
     A.2. Server ....................................................121
   附录B. 协议数据结构和常量值                              .........122
     B.1. Record Layer ..............................................122
     B.2. Alert Messages ............................................123
     B.3. Handshake Protocol ........................................124
       B.3.1. Key Exchange Messages .................................125
       B.3.2. Server Parameters Messages ............................131
       B.3.3. Authentication Messages ...............................132
       B.3.4. Ticket Establishment ..................................132
       B.3.5. Updating Keys .........................................133
     B.4. Cipher Suites .............................................133
</p></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

  <p style="font-family: 新宋体;">
   附录C. 实施说明                  .................................134
     C.1. 随机数生成和种子                     ......................134
     C.2. 证书和身份验证                  ...........................135
     C.3. 实施陷阱                ...................................135
     C.4. 客户跟踪预防               ................................137
     C.5. 未经认证的操作            .................................137
   附录D. 向后兼容性                  ...............................138
     D.1. 与旧服务器协商                   ..........................139
     D.2. 与旧客户端协商                   ..........................139
     D.3. 0-RTT 向后兼容性             ..............................140
     D.4. 中间盒兼容模式               ..............................140
     D.5. 与向后兼容性相关的安全限制                    .............141
   附录E. 安全属性概述                         ......................142
     E.1. 握手      .................................................142
       E.1.1. 密钥推导和HKDF          ...............................145
       E.1.2. 客户端身份验证        .................................146
       E.1.3. 0-RTT .................................................146
       E.1.4. Exporter Independence .................................146
       E.1.5. 妥协后的安全             ..............................146
       E.1.6. 外部参考            ...................................147
     E.2. 记录层       ..............................................147
       E.2.1. 外部参考            ...................................148
     E.3. 流量分析         ..........................................148
     E.4. 旁路攻击             ......................................149
     E.5. 0-RTT上的重播攻击       ...................................150
       E.5.1. 回放和导出器         ..................................151
     E.6. PSK身份暴露           .....................................152
     E.7. 共享PSK      ..............................................152
     E.8. 对静态 RSA 的攻击     .....................................152
   贡献者       .....................................................153
   Author's Address .................................................160
</p></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
1.  简介
 
   TLS的主要目标是在两个通信对等体之间提供安全通道；底层传输的唯一要求是可靠、有序的
   数据流。具体地说，安全通道应提供以下属性：
 
   -  身份验证: 通道的服务器端始终经过身份验证;客户端是可选的身份验证。身份验证可以
      通过非对称加密（例如，RSA [RSA]、椭圆曲线数字签名算法 （ECDSA） [ECDSA] 或
      Edwards-Curve曲线数字签名算法 （EdSA） [RFC8032]） 或对称预共享密钥
     （PSK） 进行。
 
   -  机密性: 建立后通过通道发送的数据只对端点可见。TLS不会隐藏它传输的数据的长度，
      尽管端点可以填充TLS记录，以掩盖长度并改进针对流量分析技术的保护。
 
   -  完整性: 在建立后通过通道发送的数据，攻击者对其进行修改会被发现。
 
   即使面对完全控制网络的攻击者，这些属性也应该是正确的，如[RFC3552]中所述。有关安全
   属性的更完整声明，请参见附录E。
 
   TLS由两个主要组件组成：
 
   -  握手协议(第4节)，用于验证通信方，协商加密模式和参数，并建立共享密钥材料。握手
      协议旨在抵抗篡改；主动攻击者不应能够强制对等协商与未受到攻击时协商的连接参数
     不同的参数。
 
   -  记录协议(第5节)，使用握手协议建立的参数来保护通信对等体之间的流量。记录协议
      将流量划分为一系列记录，每个记录使用流量密钥独立保护。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   TLS是独立于应用协议的；更高级别的协议可以透明地叠加在TLS之上。然而，TLS标准没有
   指定协议如何使用TLS增加安全性；如何启动TLS握手以及如何解释交换的认证证书，留给
   运行在TLS之上的协议的设计者和实现者来判断。
 
   本文档定义了 TLS 1.3 版。虽然 TLS 1.3 不直接与以前的版本兼容，但TLS的所有版本
   都包含了一个版本控制机制，该机制允许客户端和服务器互操作地协商一个共同的版本(如果
   两个对等体都支持一个版本)。
 
   本文档取代并废弃了TLS的以前版本，包括版本 1.2[RFC5246]。它还废弃了[RFC5077]中
   定义的TLS票证机制，并用2.2节中定义的机制取代了它。由于 TLS 1.3 更改了派生密钥的
   方式，因此它会更新[RFC5705]，如7.5节所述。它还改变了在线证书状态协议(OCSP)消息
   的携带方式，因此更新[RFC6066]并废弃[RFC6961]，如第4.4.2.1节所述。
 
1.1.  约定和术语
 
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and   "OPTIONAL" in this document are to be interpreted as described in   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all   capitals, as shown here.
 
   使用以下术语：
 
   客户端：发起TLS连接的端点。
 
   连接：两个端点之间的传输层连接。
 
   端点：连接的客户端或服务器。
 
   握手：客户端和服务器之间的初始协商，用于在TLS内建立其后续交互的参数。
 
   Peer：端点。当讨论特定端点时，“对等”指的是非主要讨论主题的端点。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   接收方：接收记录的端点。
 
   发送方：正在传输记录的端点。
 
   服务器：非启动TLS连接的端点。
 
1.2.  与TLS 1.2的主要区别
 
   以下是 TLS 1.2 和 TLS 1.3 之间主要功能差异的列表。 它不是详尽无遗的，还有许多
   细微的差别。
 
   -  已删除支持的对称加密算法列表中所有被视为遗留的算法。剩下的都是带关联数据的认证
      加密(AEAD)算法。密码套件的概念已经改变，以将认证和密钥交换机制与记录保护算法
     (包括秘密密钥长度)和散列分开，以便与密钥导出函数和握手消息认证码(MAC)一起使用。
 
   -  添加了零往返时间(0-RTT)模式，节省了某些应用数据的连接建立时的往返行程，但代价
      是某些安全属性。
 
   -  静态RSA和Diffie-Hellman密码套件已被删除；所有基于公钥的密钥交换机制现在都
      提供向前保密。
 
   -  ServerHello之后的所有握手消息现在都已加密。新引入的加密扩展消息允许以前在
      ServerHello中明文发送的各种扩展也享有机密性保护。
 
   -  重新设计了密钥派生函数。由于其改进的密钥分离特性，新的设计允许密码学家更容易
      进行分析。基于HMAC的提取和扩展密钥导出函数(HKDF)用作底层原语。
 
   -  握手状态机进行了显著的重构，使其更加一致，并去除了ChangeCipherSpec等多余的
      消息(中间盒兼容性需要时除外)。
 
   -  椭圆曲线算法现在基础规范中，并且包括了新的签名算法，例如EdDSA。TLS 1.3 删除
      了点格式协商，支持每条曲线的单点格式。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   -  进行了其他加密改进，包括更改RSA填充以使用RSA概率签名方案(RSASSA-PSS)，以及
      删除压缩、数字签名算法(DSA)和自定义临时Diffie-Hellman(DHE)组。
 
   -  TLS 1.2版本协商机制已被弃用，取而代之的是扩展中的版本列表。这增加了与不正确
      实现版本协商的现有服务器的兼容性。
 
   -  具有服务器端状态和无服务器端状态的会话恢复以及早期 TLS 版本的基于 PSK 的密码
      套件已被单个新的 PSK 交换所取代。
 
   -  参考资料已适当更新，指向RFC的更新版本(例如，RFC 5280而不是RFC 3280)。
 
1.3.  影响TLS 1.2的更新
 
   本文档定义了几个有选择地影响TLS 1.2实现的更改，包括那些也不支持TLS 1.3的更改：
 
   -  版本降级保护机制在第 4.1.3 节中介绍。
 
   -  RSASSA-PSS 签名方案在第 4.2.3 节中定义。
 
   -  “Supported_Versions”ClientHello扩展可用于协商要使用的TLS版本，优先于
      ClientHello的Legacy_Version字段。
 
   -  “Signature_Algorithms_cert”扩展允许客户端指明它可以在X.509证书中验证
      哪些签名算法。
 
   此外，本文档还澄清了TLS早期版本的一些合规性要求；参见第9.3节。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
2.  协议概述
 
   安全通道使用的加密参数由 TLS 握手协议生成。 此 TLS 子协议由客户端和服务器在首次
   相互通信时使用。 握手协议允许对等方协商协议版本、选择加密算法、选择相互验证以及
   建立共享密钥材料。 握手完成后，对等方将使用已建立的密钥来保护应用程序层流量。
 
   握手失败或其他协议错误会触发连接终止，可选择在此之前发送警告消息(第6节)。
 
   TLS支持三种基本的密钥交换模式：
 
   -  (EC)DHE(有限域或椭圆曲线上的Diffie-Hellman)。
 
   -  PSK-only
 
   -  PSK with (EC)DHE</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Figure 1 below shows the basic full TLS handshake:

       Client                                           Server

Key  ^ ClientHello
Exch | + key_share*
     | + signature_algorithms*
     | + psk_key_exchange_modes*
     v + pre_shared_key*       --------&gt;
                                                  ServerHello  ^ Key
                                                 + key_share*  | Exch
                                            + pre_shared_key*  v
                                        {EncryptedExtensions}  ^  Server
                                        {CertificateRequest*}  v  Params
                                               {Certificate*}  ^
                                         {CertificateVerify*}  | Auth
                                                   {Finished}  v
                               &lt;--------  [Application Data*]
     ^ {Certificate*}
Auth | {CertificateVerify*}
     v {Finished}              --------&gt;
       [Application Data]      &lt;-------&gt;  [Application Data]
 
              +  表示在前面的消息中发送的值得注意的扩展。
 
              *  表示并非总是发送的可选或依赖于情况的消息/扩展。
 
              {} 握手阶段加密消息
 
              [] 握手完成后的加密消息
 
                  图 1：完整的 TLS 握手消息流
 
   握手可视为具有三个阶段（如上图所示）：
 
   -  密钥交换：建立共享密钥材料并选择加密参数。 此阶段后的所有内容都已加密。
 
   -  服务器参数：建立其他握手参数（客户端是否经过身份验证、应用程序层协议支持等）。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   -  身份验证：对服务器（以及（可选）的客户端进行身份验证，并提供密钥确认和握手
      完整性。
 
   在密钥交换阶段，客户端发送ClientHello(第4.1.2节)消息，其中包含随机
   nonce(ClientHello.random)；其提供的协议版本；对称密码/HKDF散列对的列表；一组
   Diffie-Hellman密钥共享(在“KEY_SHARE”(第4.2.8节)扩展中)；一组预共享密钥标签
   (在“PRE_SHARED_KEY”(第4.2.11节)扩展中)，或两者；以及潜在的附加扩展。也可以
   存在额外的字段和/或消息以实现中间盒兼容性。
 
   服务器处理ClientHello并为连接确定适当的加密参数。然后，它用自己的ServerHello
   (第4.1.3节)进行响应，指示协商的连接参数。ClientHello和ServerHello的组合确定
   共享密钥。如果正在使用(EC)DHE密钥建立，则ServerHello包含带有服务器短暂
   Diffie-Hellman共享的“key_share”扩展；服务器共享必须与客户端共享之一在同一组
   中。如果正在使用PSK密钥建立，则ServerHello包含“pre_shared_key”扩展，指示
   选择了客户端提供的PSK中的哪一个。请注意，实现可以同时使用(EC)DHE和PSK，在这种
   情况下，将同时提供这两个扩展。
 
   然后，服务器发送两条消息以建立服务器参数：
 
   EncryptedExtensions：对ClientHello扩展的响应，这些扩展不是确定加密参数所必需
      的，特定于单个证书的参数除外。[第4.3.1条]。
 
   CertificateRequest：如果需要基于证书的客户端身份验证，则需要该证书的所需参数。
      如果不需要客户端身份验证，则省略此消息。[第4.3.2条]</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   最后，客户端和服务器交换身份验证消息。每次需要基于证书的身份验证时，TLS都使用
   相同的消息集。(基于PSK的身份验证是密钥交换的副作用。)。具体而言：
 
   Certificate：端点的证书和任何每个证书扩展。如果服务器未使用证书进行身份验证，
      则此消息将被服务器省略；如果服务器未发送CertificateRequest，则客户端将省略
      此消息(从而表明客户端不应使用证书进行身份验证)。请注意，如果原始公钥[RFC7250]
      或缓存信息扩展[RFC7924]正在使用中，则此消息将不包含证书，而是包含与服务器的
      长期密钥相对应的其他值。[第4.4.2条]。
 
   CertificateVerify:  在整个握手过程中使用与证书消息中的公钥对应的私钥进行签名。
      如果端点不是通过证书进行身份验证，则忽略此消息。[第4.4.3条]。
 
   Finished:  整个握手过程中的MAC(消息验证码)。此消息提供密钥确认，将端点的身份
      绑定到交换的密钥，并且在PSK模式下还会验证握手。[第4.4.4条]。
 
   在接收到服务器的消息后，客户端用其身份验证消息(Certificate和CertificateVerify
   (如果请求)进行响应，并 Finished 。
 
   此时，握手完成，客户端和服务器导出记录层所需的密钥材料，以交换通过身份验证加密保护
   的应用层数据。除第2.3节规定外，在发送 Finished 消息之前不得发送应用程序数据。请
   注意，虽然服务器可能在接收客户端的身份验证消息之前发送应用程序数据，但此时发送的
   任何数据当然是发送给未经过身份验证的对等体。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
2.1.  不正确的 DHE 共享
 
   如果客户端没有提供足够的“key_share”扩展(例如，它只包括服务器不能接受或不支持的
   DHE 或 ECDHE 组)，则服务器用 HelloRetryRequest 纠正不匹配，并且客户端需要用
   适当的 “key_share” 扩展重新启动握手，如图2所示。如果无法协商公共密码参数，则
   服务器必须中止握手并发出适当的警报。
 
        Client                                               Server

        ClientHello
        + key_share             --------&gt;
                                                  HelloRetryRequest
                                &lt;--------               + key_share
        ClientHello
        + key_share             --------&gt;
                                                        ServerHello
                                                        + key_share
                                              {EncryptedExtensions}
                                              {CertificateRequest*}
                                                     {Certificate*}
                                               {CertificateVerify*}
                                                         {Finished}
                                &lt;--------       [Application Data*]
        {Certificate*}
        {CertificateVerify*}
        {Finished}              --------&gt;
        [Application Data]      &lt;-------&gt;        [Application Data]
 
                 图 2：具有不匹配参数的完整握手的消息流
 
   注意：握手记录包含初始ClientHello/HelloRetryRequest交换；它不会使用新的
   ClientHello重置。
 
   TLS还允许基本握手的几个优化变体，如以下各节所述。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
2.2.  恢复和预共享密钥(PSK)
 
   虽然TLS PSK可以在带外建立，但是PSK也可以在以前的连接中建立，然后用于建立新的连接
   (使用PSK“会话恢复”或“恢复”)。一旦握手完成，服务器就可以向客户端发送一个PSK身份，
   该PSK身份对应于从初始握手导出的唯一密钥(参见4.6.1节)。然后，客户端可以在将来的
   握手中使用该PSK身份来协商相关PSK的使用。如果服务器接受PSK，则新连接的安全上下文被
   加密地绑定到原始连接，并且从初始握手导出的密钥被用于引导加密状态而不是完全握手。在
   TLS 1.2 及更低版本中，此功能由“session IDs”和“session tickets”[RFC5077]
   提供。这两种机制在TLS 1.3中都已过时。
 
   PSK可以与(EC)DHE密钥交换一起使用，以便结合共享密钥提供前向保密性，或者可以单独
   使用，但代价是失去应用数据的前向保密性。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   图3显示了一对握手，其中第一次握手建立PSK，第二次握手使用PSK：
 
          Client                                               Server

   Initial Handshake:
          ClientHello
          + key_share               --------&gt;
                                                          ServerHello
                                                          + key_share
                                                {EncryptedExtensions}
                                                {CertificateRequest*}
                                                       {Certificate*}
                                                 {CertificateVerify*}
                                                           {Finished}
                                    &lt;--------     [Application Data*]
          {Certificate*}
          {CertificateVerify*}
          {Finished}                --------&gt;
                                    &lt;--------      [NewSessionTicket]
          [Application Data]        &lt;-------&gt;      [Application Data]


   Subsequent Handshake:
          ClientHello
          + key_share*
          + pre_shared_key          --------&gt;
                                                          ServerHello
                                                     + pre_shared_key
                                                         + key_share*
                                                {EncryptedExtensions}
                                                           {Finished}
                                    &lt;--------     [Application Data*]
          {Finished}                --------&gt;
          [Application Data]        &lt;-------&gt;      [Application Data]
 
                          图3：恢复和PSK的消息流
 
   由于服务器通过PSK进行身份验证，因此它不会发送Certificate或CertificateVerify
   消息。当客户端通过PSK提供恢复时，它还应该向服务器提供“KEY_SHARE”扩展，以允许
   服务器拒绝恢复并回退到完全握手(如果需要)。服务器用“PRE_SHARED_KEY”扩展响应以
   协商PSK密钥建立的使用，并且可以(如此处所示)用“KEY_SHARE”扩展响应以进行(EC)DHE
   密钥建立，从而提供前向保密性。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   当 PSK 在带外预配时，还必须预配要与 PSK 一起使用的 PSK 标识和 KDF 哈希算法。
 
   注意：当使用带外预配的预共享密钥时，一个关键的考虑因素是在密钥生成期间使用足够的
   熵，如 [RFC4086] 中所述。 从密码或其他低熵源派生共享密钥不安全。 低熵机密或密码
   会根据 PSK 活页夹进行字典攻击。 指定的 PSK 身份验证不是强基于密码的身份验证密钥
   交换，即使与 Diffie-Hellman 密钥建立一起使用也是如此。 具体而言，它不会阻止可以
   观察握手的攻击者对密码/预共享密钥执行暴力攻击。
 
2.3.  0-RTT Data
 
   当客户端和服务器共享PSK(通过外部获取或通过先前的握手获得)时，TLS 1.3允许客户端
   在第一次飞行时发送数据(“早期数据”)。客户端使用PSK对服务器进行身份验证，并对早期
   数据进行加密。
 
   如图4所示，0-RTT数据只是添加到第一次飞行中的1-RTT握手。握手的其余部分使用与具有
   PSK恢复的1-RTT握手相同的消息。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
         Client                                               Server

         ClientHello
         + early_data
         + key_share*
         + psk_key_exchange_modes
         + pre_shared_key
         (Application Data*)     --------&gt;
                                                         ServerHello
                                                    + pre_shared_key
                                                        + key_share*
                                               {EncryptedExtensions}
                                                       + early_data*
                                                          {Finished}
                                 &lt;--------       [Application Data*]
         (EndOfEarlyData)
         {Finished}              --------&gt;
         [Application Data]      &lt;-------&gt;        [Application Data]
 
              +  表示在前面的消息中发送的值得注意的扩展。
 
              *  表示并非总是发送的可选或依赖于情况的消息/扩展。

              ()表示使用从client_early_traffic_secret派生的密钥保护的消息。
 
              {} 握手阶段加密消息
 
              [] 握手完成后的加密消息
 
                            图4：0-RTT握手的消息流</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   重要说明：0-RTT数据的安全属性比其他类型的TLS数据的安全属性弱。具体而言：
 
   1.  此数据不是前向秘密，因为它仅在使用所提供的PSK导出的密钥下加密。
 
   2.  连接之间不能保证不重放。普通 TLS 1.3 1-RTT 数据的重放保护通过服务器的
       Random值提供，但 0-RTT 数据不依赖于 ServerHello ，因此具有较弱的保证。
       如果使用TLS客户端身份验证或在应用程序协议内部对数据进行身份验证，则这一点
       尤其重要。同样的警告也适用于 early_exporter_master_secret 的任何用法。
 
   0-RTT 数据不能在一个连接内复制(即，服务器不会为相同的连接处理相同的数据两次)，
   并且攻击者将无法使 0-RTT 数据看起来是 1-RTT 数据(因为它受到不同密钥的保护)。
   附录E.5 包含对潜在攻击的描述，第8节描述了服务器可用于限制重放影响的机制。
 
3.  演示语言
 
   本文档处理外部表示中的数据格式。将使用以下非常基本且有些随意定义的表示语法。
 
3.1.  基本块大小
 
   明确指定所有数据项的表示。基本数据块大小是一个字节(即，8位)。多字节数据项是字节
   的串联，从左到右，从上到下。从字节流中，多字节项(以下示例中的数字)通过以下方式
   形成(使用C表示法)：
 
      value = (byte[0] &lt;&lt; 8*(n-1)) | (byte[1] &lt;&lt; 8*(n-2)) |
              ... | byte[n-1];
 
   多字节值的字节排序是常见的网络字节顺序或大字节格式。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
3.2.  杂项
 
   注释以“/*”开头，以“*/”结尾。
 
   可选组件通过将其括在“[[]]”(双括号)中来表示。
 
   包含未解释数据的单字节实体属于不透明类型。
 
   现有类型T的类型别名T‘定义如下：
 
      T T';
 
3.3.  数字
 
   基本的数字数据类型是无符号字节(Uint8)。所有较大的数值数据类型都是由固定长度的
   字节序列构造的，这些字节序列按照3.1节中的描述连接起来，并且也是无符号的。以下数值
   类型是预定义的。
 
      uint8 uint16[2];
      uint8 uint24[3];
      uint8 uint32[4];
      uint8 uint64[8];
 
   所有值（此处和规范中的其他地方）均按网络字节（大端）顺序传输;由十六进制 
   01 02 03 04 表示的 uint32 等效于十进制值 16909060。
 
3.4.  向量
 
   向量(一维数组)是同构数据元素的流。矢量的大小可以在文档编制时指定，或者直到运行时
   才指定。在任何一种情况下，长度都声明向量中的字节数，而不是元素数。用于指定新类型
   T‘(即T类型的定长向量)的语法是。
 
      T T'[n];
 
   这里，T‘占据数据流中的n个字节，其中 n 是T的大小的倍数。向量的长度不包括在
   编码流中。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   在下面的示例中，Datum 被定义为协议不解释的三个连续字节，而 Data 是三个连续的
   Datum，总共消耗九个字节。
 
      opaque Datum[3];      /* three uninterpreted bytes */
      Datum Data[9];        /* three consecutive 3-byte vectors */
 
   可变长度向量是通过指定合法长度的子范围来定义的，使用表示法 &lt;下限..上限&gt; 。
   当这些被编码时，实际长度在字节流中的向量内容之前。长度将采用数字的形式，消耗的
   字节数与保持矢量指定的最大(上限)长度所需的字节数相同。实际长度字段为零的可变长度
   向量称为空向量。
 
      T T'&lt;floor..ceiling&gt;;
 
   在下面的示例中，“mandatory” 是一个必须包含300到400个不透明类型的字节的向量。
   它永远不会是空的。“实际长度”字段消耗两个字节，即uint16，这足以表示值400(参见
   第3.3节)。类似地，“longer”可以表示多达800字节的数据，或400个uint16元素，并且
   它可以是空的。它的编码将包括两个字节的实际长度字段，放在向量的前面。编码向量的长度必须是单个元素长度的精确倍数(例如，uint16的17字节向量是非法的)。
 
      opaque mandatory&lt;300..400&gt;;
            /* length field is two bytes, cannot be empty */
      uint16 longer&lt;0..800&gt;;
            /* zero to 400 16-bit unsigned integers */
 
3.5.  枚举
 
   其他稀疏数据类型（称为 "枚举"）。 每个定义都是不同的类型。 只能分配或比较相同类型
   的枚举。 枚举的每个元素都必须分配一个值，如以下示例所示。 由于枚举的元素不排序，
   因此可以按任意顺序为其分配任何唯一值。
 
      enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;
 
   将来对协议的扩展或添加可以定义新值。实现需要能够解析和忽略未知值，除非字段的定义
   另有说明。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   枚举在字节流中占用的空间与其定义的最大序数值一样多。下面的定义将使用一个字节
   携带Color类型的字段。
 
      enum { red(3), blue(5), white(7) } Color;
 
   可以任选地指定一个没有其关联标签的值，以强制宽度定义，而不定义多余的元素。
 
   在下面的示例中，Taste将占用数据流中的两个字节，但只能在协议的当前版本中取值
   1、2或4。
 
      enum { sweet(1), sour(2), bitter(4), (32000) } Taste;
 
   枚举元素的名称在定义的类型中限定作用域。在第一个示例中，对枚举的第二个元素的完全
   限定引用将是Color.blue。如果指定的目标明确，则不需要这种资格。
 
      Color color = Color.blue;     /* overspecified, legal */
      Color color = blue;           /* correct, type implicit */
 
   枚举元素的名称在定义的类型中限定作用域。在第一个示例中，对枚举的第二个元素的完全
   限定引用将是Color.blue。如果指定的目标明确，则不需要这种限制。
 
      enum { sad(0), meh(1..254), happy(255) } Mood;
 
3.6.  结构类型

   为方便起见，可以从基元类型构造结构类型。每个规范都声明了一个新的、唯一的类型。
   用于定义的语法非常类似于C。
 
      struct {
          T1 f1;
          T2 f2;
          ...
          Tn fn;
      } T;
 
   使用标准向量语法允许固定和可变长度向量域。变体示例(3.8节)中的结构V1和V2证明了
   这一点。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   结构中的字段可以使用类型的名称进行指定，其语法非常类似于枚举可用的语法。例如，
   T.f2是指前一个声明的第二个字段。
 
3.7.  常量
 
   可以使用“=”为字段和变量分配固定值，如：
 
      struct {
          T1 f1 = 8;  /* T.f1 must always be 8 */
          T2 f2;
      } T;
 
3.8.  变体
 
   定义的结构可能具有基于环境中可用的某些知识的变体。选择器必须是枚举类型，用于定义
   结构定义的可能变体。SELECT的每个分支(见下图)都指定了该变量的字段类型和可选的字段
   标签。在运行时选择变体的机制不是由表示语言规定的。
 
      struct {
          T1 f1;
          T2 f2;
          ....
          Tn fn;
          select (E) {
              case e1: Te1 [[fe1]];
              case e2: Te2 [[fe2]];
              ....
              case en: Ten [[fen]];
          };
      } Tv;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   For example:
 
      enum { apple(0), orange(1) } VariantTag;
 
      struct {
          uint16 number;
          opaque string&lt;0..10&gt;; /* variable length */
      } V1;
 
      struct {
          uint32 number;
          opaque string[10];    /* fixed length */
      } V2;
 
      struct {
          VariantTag type;
          select (VariantRecord.type) {
              case apple:  V1;
              case orange: V2;
          };
      } VariantRecord;
 
4.  握手协议
 
   握手协议用于协商连接的安全参数。握手消息被提供给TLS记录层，在那里它们被封装在一个
   或多个 TLSPlaintext 或 TLSCiphertext 结构中，这些结构按照当前活动连接的状态
   进行处理和传输。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
      enum {
          client_hello(1),
          server_hello(2),
          new_session_ticket(4),
          end_of_early_data(5),
          encrypted_extensions(8),
          certificate(11),
          certificate_request(13),
          certificate_verify(15),
          finished(20),
          key_update(24),
          message_hash(254),
          (255)
      } HandshakeType;
 
      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* remaining bytes in message */
          select (Handshake.msg_type) {
              case client_hello:          ClientHello;
              case server_hello:          ServerHello;
              case end_of_early_data:     EndOfEarlyData;
              case encrypted_extensions:  EncryptedExtensions;
              case certificate_request:   CertificateRequest;
              case certificate:           Certificate;
              case certificate_verify:    CertificateVerify;
              case finished:              Finished;
              case new_session_ticket:    NewSessionTicket;
              case key_update:            KeyUpdate;
          };
      } Handshake;
 
   协议消息必须按照第4.4.1节中定义的顺序发送，并在第2节的图表中显示。以意外顺序接收
   握手消息的对等体必须中止握手并发出 “unexpected_message” 警报。
 
   新的握手消息类型由IANA分配，如第11节所述。
 
4.1.  Key Exchange 消息
 
   密钥交换消息用于确定客户端和服务器的安全能力，并建立共享密钥，包括用于保护其余
   握手和数据的业务密钥。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.1.1.  加密协商
 
   在TLS中，加密协商通过客户端在 ClientHello 中提供以下四组选项来进行：
 
   -  密码套件列表，指示客户端支持的 AEAD算法/HKDF散列对。
 
   -  “supported_groups”(4.2.7节)扩展，表示客户端支持的(EC)DHE组；
      “key_share”(4.2.8节)扩展，包含部分或所有这些组的(EC)DHE共享。
 
   -  “signature_algorithms”(第4.2.3节)扩展，表示客户端可以接受的签名算法。
      还可以添加“signature_algorithms_cert”扩展(第4.2.3节)，以指示证书特定的
      签名算法。
 
   -  “pre_shared_key”(第4.2.11节)扩展，其中包含客户端已知的对称密钥身份列表，
      以及“psk_key_exchange_modes”(第4.2.9节)扩展，该扩展指示可与PSK一起
      使用的密钥交换模式。
 
   如果服务器不选择PSK，则这些选项中的前三个选项完全正交：服务器独立地选择密码组、
   (EC)DHE组和密钥共享用于密钥建立，以及签名算法/证书对以向客户端验证其自身。如果
   接收到的“supported_groups”与服务器支持的组之间没有重叠，则服务器必须中止握手，
   并发出“handshake_failure”或“insufficient_security”警报。
 
   如果服务器选择PSK，则它还必须从客户端的“psk_key_exchange_modes”扩展所指示的
   集合中选择密钥建立模式(目前，PSK单独或与(EC)DHE一起)。请注意，如果PSK可以在没有
   (EC)DHE的情况下使用，则“supported_groups”参数中的不重叠不一定是致命的，就像
   上一段中讨论的非PSK情况一样。
 
   如果服务器选择(EC)DHE组，并且客户端没有在初始 ClientHello 中提供兼容的
   “key_share”扩展，则服务器必须使用 HelloRetryRequest(第4.1.4节)消息进行
   响应。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   如果服务器成功选择参数且不需要 HelloRetryRequest，则ServerHello中选择的参数
   如下：
 
   -  如果正在使用PSK，则服务器将发送“pre_shared_key”扩展，指示所选密钥。
 
   -  使用(EC)DHE时，服务器还将提供“key_share”扩展。如果未使用PSK，则始终使用
      (EC)DHE和基于证书的身份验证。
 
   -  在进行证书身份验证时，服务器将发送 Certificate (第4.4.2节)和
      CertificateVerify(第4.4.3节)消息。在本文档定义的TLS 1.3中，始终使用PSK
      或证书，但不能同时使用。未来的文档可能会定义如何将它们一起使用。
 
   如果服务器无法协商支持的一组参数(即客户端和服务器参数之间没有重叠)，则必须中止
   握手，并发出“handshake_failure”或“insufficient_security”致命警报
   (参见第6节)。
 
4.1.2.  Client Hello
 
   当客户端首次连接到服务器时，需要发送ClientHello作为其第一个TLS消息。当服务器使用
   HelloRetryRequest 响应其 ClientHello 时，客户端还将发送 ClientHello 。在
   这种情况下，客户端必须发送相同的 ClientHello 而不进行修改，以下情况除外：
 
   -  如果 HelloRetryRequest 中提供了“key_share”扩展，则将共享列表替换为
      包含指定组中单个 KeyShareEntry 的列表。
 
   -  如果存在“early_data”扩展(第4.2.10节)，则删除该扩展。
      HelloRetryRequest 之后不允许早期数据。
 
   -  如果HelloRetryRequest中提供了“cookie”扩展，则包括“cookie”扩展。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   -  更新“pre_shared_key”扩展(如果存在)，方法是重新计算
      “obfuscated_ticket_age”和绑定器值，并(可选)删除与服务器指示的密码套件
      不兼容的任何PSK。
 
   -  可选地添加、删除或更改扩展的“填充”长度[RFC7685]。
 
   -  未来定义的扩展可能允许的其他修改，并且存在于 HelloRetryRequest 中。
 



   由于 TLS 1.3 禁止重新协商，因此如果服务器已经协商了 TLS 1.3 并在任何其他时间
   收到ClientHello，则它必须终止连接并发出“unexpected_message”警报。
 

   如果服务器与以前版本的 TLS 建立了 TLS 连接，并在重新协商中收到
   TLS 1.3 ClientHello，则它必须保留以前的协议版本。特别是，它不能协商TLS 1.3。
 


   Structure of this message:
 
      uint16 ProtocolVersion;
      opaque Random[32];
 
      uint8 CipherSuite[2];    /* Cryptographic suite selector */
 
      struct {
          ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
          Random random;
          opaque legacy_session_id&lt;0..32&gt;;
          CipherSuite cipher_suites&lt;2..2^16-2&gt;;
          opaque legacy_compression_methods&lt;1..2^8-1&gt;;
          Extension extensions&lt;8..2^16-1&gt;;
      } ClientHello;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   legacy_version:  在TLS的早期版本中，此字段用于版本协商，表示客户端支持的最高
      版本号。经验表明，许多服务器没有正确实现版本协商，导致
      “version intolerance”， 即服务器拒绝一个本来可以接受的 ClientHello，
     其版本号高于它所支持的版本号。在TLS 1.3中，客户端在 “supported_versions”
     扩展(第4.2.1节)中指明其版本首选项，并且 Legacy_Version 字段必须设置为
     0x0303，这是 TLS 1.2 的版本号。TLS 1.3 ClientHellos被标识为具有0x0303
     的 legacy_version 和 supported_versions 扩展，其中0x0304是其中指示的
     最高版本。(有关向后兼容性的详细信息，请参阅附录D。)。





   random:  由安全随机数生成器生成的32个字节。有关更多信息，请参见附录C。
 

   legacy_session_id:  TLS 1.3 之前的TLS版本支持“会话恢复”功能，该功能已与此
      版本中的预共享密钥合并(参见第2.2节)。具有由TLS 1.3之前的服务器设置的缓存
      会话ID 的客户端应将该字段设置为该值。在兼容模式下(参见附录D.4)，此字段必须
      非空，因此未提供TLS 1.3之前的会话的客户端必须生成新的32字节值。这个值不需要是
      随机的，但是应该是不可预测的，以避免实现专注于特定的值(也称为渗透)。否则，必须
      将其设置为零长度向量(即，零值单字节长度字段)。
 




   cipher_suites:  客户端支持的对称密码选项列表，指定记录层保护算法(包括密钥长度)
      和要与HKDF一起使用的散列，按客户端首选项的降序排列。值在附录B.4 中定义。如果
      列表中包含服务器不识别、不支持或不希望使用的密码套件，则服务器必须忽略这些
      密码套件，并像往常一样处理其余的密码套件。如果客户端正在尝试PSK密钥建立，则它
      应该通告至少一个指示与PSK相关联的散列的密码套件。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   legacy_compression_methods:  1.3之前的TLS版本支持压缩，支持的压缩方法列表
      在此字段中发送。对于每个 TLS 1.3 ClientHello，此向量必须正好包含一个字节，
      设置为零，这与以前版本的TLS中的“null”压缩方法相对应。如果接收到的TLS 1.3 
      ClientHello 具有此字段中的任何其他值，则服务器必须中止握手并发出
      “illegal_parameter” 警报。请注意，TLS 1.3 服务器可能会收到包含其他压缩
      方法的TLS 1.2或以前的ClientHellos，并且(如果协商这样的以前版本)必须遵循
      适用于TLS以前版本的过程。
 



   extensions:  客户端通过发送扩展字段中的数据从服务器请求扩展功能。实际的
      “Extension” 格式在4.2节中定义。在 TLS 1.3中，某些扩展的使用是强制性的，
      因为功能已经转移到扩展中，以保持 ClientHello 与以前版本的TLS的兼容性。服务器
      必须忽略无法识别的扩展。
 


   TLS的所有版本都允许扩展字段可选地跟随在 compression_methods 字段之后。
   TLS 1.3 ClientHello 消息始终包含扩展(最低限度为“supported_versions”，
   否则，它们将被解释为TLS 1.2 ClientHello 消息)。但是，TLS 1.3 服务器可能会从
   以前版本的TLS接收没有扩展字段的 ClientHello 消息。扩展的存在可以通过确定
   ClientHello末尾的 compression_methods 字段后面是否有字节来检测。请注意，这种
   检测可选数据的方法不同于具有可变长度字段的常规TLS方法，但它用于在定义扩展之前与
   TLS 兼容。TLS 1.3 服务器需要首先执行此检查，并且只有在存在
   “supported_versions”扩展时才会尝试协商 TLS 1.3。如果协商1.3之前的TLS版本，
   则服务器必须检查消息是否在 legacy_compression_methods 之后不包含数据，或者
   它是否包含有效的扩展块，后面没有数据。如果不是，则必须中止握手并发出
   “decode_error” 警报。
 
   在客户端使用扩展请求附加功能并且该功能不是由服务器提供的情况下，客户端可能会中止
   握手。
 
   发送 ClientHello 消息后，客户端等待 ServerHello 或 HelloRetryRequest消息。
   如果正在使用早期数据，则客户端可以在等待下一次握手消息的同时传输早期应用数据
   (第2.3节)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.1.3.  Server Hello
 
   如果服务器能够基于ClientHello协商可接受的握手参数集，则服务器将响应
   ClientHello 消息发送此消息以继续进行握手。
 
   Structure of this message:
 
      struct {
          ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
          Random random;
          opaque legacy_session_id_echo&lt;0..32&gt;;
          CipherSuite cipher_suite;
          uint8 legacy_compression_method = 0;
          Extension extensions&lt;6..2^16-1&gt;;
      } ServerHello;
 
   legacy_version:  在TLS的以前版本中，此字段用于版本协商，并表示连接的选定
      版本号。不幸的是，一些中间件在提供新值时会失败。在TLS 1.3中，TLS服务器使用
      “supported_versions”扩展(第4.2.1节)指示其版本，并且legacy_version字段
      必须设置为0x0303，这是TLS 1.2的版本号。(有关向后兼容性的详细信息，请参阅
      附录D。)
 



   random:  由安全随机数生成器生成的32字节。有关更多信息，请参见附录C。如果协商
      TLS 1.2 或 TLS 1.1 ，则必须覆盖后8个字节，如下所述，但其余字节必须是
      随机的。此结构由服务器生成，并且必须独立于 ClientHello.random 生成。


 
   legacy_session_id_echo:  客户端的 legacy_session_id 字段的内容。请注意，
      即使客户端的值对应于服务器已选择不恢复的缓存的TLS 1.3之前的会话，也会回显此
      字段。接收到与其在 ClientHello中发送的字段不匹配的legacy_session_id_echo
      字段的客户端必须中止握手，并发出“illegal_parameter”警报。



 
   cipher_suite:  服务器从 ClientHello.cipher_suites 中的列表中选择的单个密码
      套件。接收到未提供的密码套件的客户端必须中止握手，并发出“illegal_parameter”
      警报。
 
   legacy_compression_method:  必须具有值0的单个字节。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   extensions:  扩展的列表.   ServerHello 必须仅包含建立加密上下文和协商协议
      版本所需的扩展。 所有 TLS 1.3 ServerHello 消息必须包含
      "supported_versions" 扩展。 当前 ServerHello 消息还包含
      "pre_shared_key"扩展或"key_share"扩展，或两者（当 PSK 与 （EC）DHE 
      密钥建立时）。 其他扩展（请参阅第 4.2 节）在加密扩展消息中单独发送。
 
   出于与中间件向后兼容的原因(参见附录D.4)，HelloRetryRequest 消息使用与
   ServerHello相同的结构，但 Random 设置为 “HelloRetryRequest” 的SHA-256的
   特殊值：
 
     CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91
     C2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C
 
   在接收到 server_hello 类型的消息时，实现必须首先检查 Random 值，如果它与此值
   匹配，则按照4.1.4节中的描述对其进行处理。
 
   TLS 1.3在服务器的随机值中嵌入了降级保护机制。为响应 ClientHello 而协商
   TLS 1.2 或更低版本的 TLS 1.3 服务器必须特别在其 ServerHello 中设置其随机值
   的最后8个字节。
 
   如果协商 TLS 1.2，TLS 1.3 服务器必须将其随机值的最后8个字节设置为字节：
 
     44 4F 57 4E 47 52 44 01
 
   如果协商TLS 1.1或更低版本，则 TLS 1.3 服务器必须，并且TLS 1.2服务器应将其
   ServerHello.Random 值的最后8个字节设置为字节：
 
     44 4F 57 4E 47 52 44 00
 
   TLS 1.3客户端收到指示TLS 1.2或更低版本的ServerHello时，必须检查最后8个字节
   是否不等于这些值中的任何一个。如果ServerHello指示TLS 1.1或更低，TLS 1.2客户端
   还应检查最后8个字节是否等于第二个值。如果找到匹配项，客户端必须中止握手并发出
   “illegal_parameter”警报。此机制提供有限的保护，以防止在完成的交换所提供的内容
   之上的降级攻击：因为存在于TLS 1.2及更低版本中的消息 ServerKeyExchange 包括
   对两个随机值的签名，因此只要使用短暂的密码，主动攻击者就不可能在未检测的情况下
   修改随机值。使用静态RSA时，它不提供降级保护。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 




 
   注意：这是对[RFC5246]的更改，因此在实践中许多TLS 1.2客户端和服务器将不会像
   上面指定的那样工作。
 
   与TLS 1.2或更早版本执行重新协商并且在重新协商期间接收到 TLS 1.3 ServerHello
   的传统TLS客户端必须中止握手并发出“protocol_version”警报。请注意，当TLS 1.3
   已被协商时，重新协商是不可能的。
 
4.1.4.  Hello Retry Request
 
   如果服务器能够找到一组可接受的参数，但 ClientHello 没有包含足够的信息来继续
   进行握手，则服务器将发送此消息以响应 ClientHello 消息。如第4.1.3节所述，
   HelloRetryRequest 具有与 ServerHello 消息相同的格式，Legacy_Version、
   Legacy_Session_id_echo、cipher_Suite 和 Legacy_Compression_Method字段
   具有相同的含义。然而，为了方便起见，我们在整个文档中讨论 “HelloRetryRequest”，
   就好像它是一条截然不同的消息一样。
 
   服务器的扩展必须包含“supported_versions”。此外，它应该包含客户端生成正确
   的 ClientHello 对所需的最小扩展集。与 ServerHello 一样，HelloRetryRequest
   不得包含客户端在其 ClientHello 中首先提供的任何扩展，但可选的 “cookie” 
   (参见第4.2.2节)扩展除外。
 




   收到 HelloRetryRequest 后，客户端必须按照第4.1.3节的规定检查
   Legacy_Version、Legacy_Session_id_echo、cipher_Suite和
   Legacy_Compression_Method，然后处理扩展，首先使用“Supported_Versions”
   确定版本。如果HelloRetryRequest不会导致ClientHello中的任何更改，则客户端必须
   中止握手并发出“illegal_parameter”警报。如果客户端在同一连接中接收到第二个
   HelloRetryRequest(即ClientHello本身响应HelloRetryRequest)，则它必须中止
   握手并发出“unexpected_message”警报。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   否则，客户端必须处理HelloRetryRequest中的所有扩展，并发送第二个更新的
   ClientHello。本规范中定义的HelloRetryRequest扩展包括：
 
   -  supported_versions (see Section 4.2.1)
 
   -  cookie (see Section 4.2.2)
 
   -  key_share (see Section 4.2.8)
 
   接收到未提供密码套件的客户端必须中止握手。服务器必须确保在接收符合更新的
   ClientHello 时协商相同的密码套件(如果服务器选择密码套件作为协商的第一步，则这
   将自动发生)。在接收到ServerHello后，客户端必须检查 ServerHello 中提供的密码
   套件与HelloRetryRequest中提供的密码套件是否相同，否则会中止握手并发出
   “illegal_parameter”警报。

 
   此外，在其更新的ClientHello中，客户端不应提供与所选密码套件的散列以外的散列
   相关联的任何预共享密钥。这允许客户端避免必须为第二ClientHello中的多个散列计算
   部分散列转录本。
 
   HelloRetryRequest的“supported_versions”扩展中 selected_version 的值
   必须保留在 ServerHello 中，并且如果值更改，客户端必须中止握手并发出
   “illegal_parameter”警报。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.  Extensions
 
   许多TLS消息包含标记长度值编码的扩展结构。
 
    struct {
        ExtensionType extension_type;
        opaque extension_data&lt;0..2^16-1&gt;;
    } Extension;
 
    enum {
        server_name(0),                             /* RFC 6066 */
        max_fragment_length(1),                     /* RFC 6066 */
        status_request(5),                          /* RFC 6066 */
        supported_groups(10),                       /* RFC 8422, 7919 */
        signature_algorithms(13),                   /* RFC 8446 */
        use_srtp(14),                               /* RFC 5764 */
        heartbeat(15),                              /* RFC 6520 */
        application_layer_protocol_negotiation(16), /* RFC 7301 */
        signed_certificate_timestamp(18),           /* RFC 6962 */
        client_certificate_type(19),                /* RFC 7250 */
        server_certificate_type(20),                /* RFC 7250 */
        padding(21),                                /* RFC 7685 */
        pre_shared_key(41),                         /* RFC 8446 */
        early_data(42),                             /* RFC 8446 */
        supported_versions(43),                     /* RFC 8446 */
        cookie(44),                                 /* RFC 8446 */
        psk_key_exchange_modes(45),                 /* RFC 8446 */
        certificate_authorities(47),                /* RFC 8446 */
        oid_filters(48),                            /* RFC 8446 */
        post_handshake_auth(49),                    /* RFC 8446 */
        signature_algorithms_cert(50),              /* RFC 8446 */
        key_share(51),                              /* RFC 8446 */
        (65535)
    } ExtensionType;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Here:
 
   -  "extension_type" 标识特定的扩展类型。
 
   -  "extension_data" 包含特定于特定扩展类型的信息。
 
   扩展类型列表由IANA维护，如第11节所述。
 
   扩展通常是以请求/响应的方式构造的，尽管一些扩展只是没有相应响应的指示。客户端
   在ClientHello消息中发送其扩展请求，服务器在ServerHello、
   EncryptedExtensions、HelloRetryRequest和Certificate消息中发送其扩展响应。
   服务器在CertificateRequest消息中发送扩展请求，客户端可以用证书消息来响应。
   服务器也可以在NewSessionTicket中发送未经请求的扩展，尽管客户端不直接响应这些
   扩展。
 
   如果远程端点没有发送相应的扩展请求，则实现不得发送扩展响应，HelloRetryRequest
   中的“cookie”扩展除外。在接收到这样的扩展时，端点必须中止握手并发出
   “unsupported_extension”警报。
 
   下表显示给定扩展可能出现的消息，使用以下表示法：CH(ClientHello)、
   SH(ServerHello)、EE(EncryptedExtensions)、CT(Certificate)、
   CR(CertificateRequest)、NST(NewSessionTicket)和
   HRR(HelloRetryRequest)。如果实现接收到它识别的扩展，并且没有为它出现的消息
   指定该扩展，则它必须中止握手并发出“illegal_parameter”警报。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   +--------------------------------------------------+-------------+
   | Extension                                        |     TLS 1.3 |
   +--------------------------------------------------+-------------+
   | server_name [RFC6066]                            |      CH, EE |
   |                                                  |             |
   | max_fragment_length [RFC6066]                    |      CH, EE |
   |                                                  |             |
   | status_request [RFC6066]                         |  CH, CR, CT |
   |                                                  |             |
   | supported_groups [RFC7919]                       |      CH, EE |
   |                                                  |             |
   | signature_algorithms (RFC 8446)                  |      CH, CR |
   |                                                  |             |
   | use_srtp [RFC5764]                               |      CH, EE |
   |                                                  |             |
   | heartbeat [RFC6520]                              |      CH, EE |
   |                                                  |             |
   | application_layer_protocol_negotiation [RFC7301] |      CH, EE |
   |                                                  |             |
   | signed_certificate_timestamp [RFC6962]           |  CH, CR, CT |
   |                                                  |             |
   | client_certificate_type [RFC7250]                |      CH, EE |
   |                                                  |             |
   | server_certificate_type [RFC7250]                |      CH, EE |
   |                                                  |             |
   | padding [RFC7685]                                |          CH |
   |                                                  |             |
   | key_share (RFC 8446)                             | CH, SH, HRR |
   |                                                  |             |
   | pre_shared_key (RFC 8446)                        |      CH, SH |
   |                                                  |             |
   | psk_key_exchange_modes (RFC 8446)                |          CH |
   |                                                  |             |
   | early_data (RFC 8446)                            | CH, EE, NST |
   |                                                  |             |
   | cookie (RFC 8446)                                |     CH, HRR |
   |                                                  |             |
   | supported_versions (RFC 8446)                    | CH, SH, HRR |
   |                                                  |             |
   | certificate_authorities (RFC 8446)               |      CH, CR |
   |                                                  |             |
   | oid_filters (RFC 8446)                           |          CR |
   |                                                  |             |
   | post_handshake_auth (RFC 8446)                   |          CH |
   |                                                  |             |
   | signature_algorithms_cert (RFC 8446)             |      CH, CR |
   +--------------------------------------------------+-------------+</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   当存在多个不同类型的扩展时，扩展可以任何顺序出现，除了“pre_shared_key”
   (第4.2.11节)，它必须是ClientHello中的最后一个扩展 (但可以出现在ServerHello
   Extensions块的任何地方)。给定的扩展块中不能有多个相同类型的扩展。
 
   在TLS 1.3中，与TLS 1.2不同，即使在恢复PSK模式下，也会为每次握手协商扩展。
   然而，0-RTT 参数是在前一次握手中协商的参数；不匹配可能需要拒绝0-RTT
   (参见4.2.10节)。
 
   在这个协议中，新功能和现有功能之间可能会发生一些微妙的(也不是那么微妙的)交互作用，
   这可能会导致总体安全性的显着降低。设计新扩展时应考虑以下注意事项：
 
   -  服务器不同意扩展的某些情况是错误条件(例如，握手不能继续)，而有些情况只是拒绝
      支持特定功能。通常，前者应使用错误警报，后者应在服务器扩展响应中使用一个字段。
 
   -  扩展应尽可能设计为防止通过操纵握手消息来强制使用(或不使用)特定功能的任何攻击。
      无论是否认为该功能会导致安全问题，都应遵循此原则。通常，扩展字段被包括在完成
      的消息散列的输入中的事实将是足够的，但是当扩展改变在握手阶段发送的消息的含义
      时，需要格外小心。设计者和实现者应该意识到这样一个事实：在握手得到验证之前，
      主动攻击者可以修改消息并插入、删除或替换扩展。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.1.  Supported Versions
 
      struct {
          select (Handshake.msg_type) {
              case client_hello:
                   ProtocolVersion versions&lt;2..254&gt;;
 
              case server_hello: /* and HelloRetryRequest */
                   ProtocolVersion selected_version;
          };
      } SupportedVersions;
 
   “supported_versions”扩展由客户端用来指示它支持的TLS版本，服务器用来指示它
   正在使用的版本。该扩展包含按优先顺序排列的受支持版本的列表，最首选的版本排在第一
   位。本规范的实现必须在ClientHello中发送此扩展，其中包含它们准备协商的所有TLS
   版本(对于本规范，这意味着最低限度为0x0304，但如果允许协商TLS的以前版本，则它们
   也必须存在)。
 
   如果不存在此扩展，则符合本规范且支持TLS 1.2的服务器必须按照[RFC5246]中的规定
   协商TLS 1.2或更早版本，即使ClientHello.legacy_version 为0x0304或更高版本
   也是如此。服务器可能会在接收到具有legacy_version 0x0304或更高版本的
   ClientHello时中止握手。
 
   协商TLS 1.3之前的TLS版本的服务器必须设置ServerHello.version，并且不能发送
   “supported_versions”扩展。协商TLS 1.3的服务器必须通过发送包含所选版本值
   (0x0304)的“supported_versions”扩展来响应。它必须将
   ServerHello.legacy_version 字段设置为0x0303(TLS 1.2)。客户端必须在处理
   ServerHello的其余部分之前检查此扩展(尽管它们必须解析ServerHello才能读取扩展)。
   如果存在此扩展，则客户端必须忽略 ServerHello.legacy_version 值，并且必须
   仅使用“supported_versions”扩展来确定所选版本。如果ServerHello中的
   “supported_versions”扩展包含客户端未提供的版本或包含TLS 1.3之前的版本，则
   客户端必须中止握手并发出“illegal_parameter”警报。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 







 
4.2.2.  Cookie
 
      struct {
          opaque cookie&lt;1..2^16-1&gt;;
      } Cookie;
 
   Cookie有两个主要用途：
 
   -  允许服务器强制客户端在其明显的网络地址展示可达性(从而提供DoS保护措施)。这
      主要用于非面向连接的传输(参见[RFC6347]中的一个例子)。
 
   -  允许服务器将状态卸载到客户端，从而允许它发送HelloRetryRequest而不存储任何
      状态。服务器可以通过将ClientHello的散列存储在HelloRetryRequest cookie
      (用一些适当的完整性保护算法保护)中来做到这一点。
 
   当发送HelloRetryRequest时，服务器可以向客户端提供“cookie”扩展(这是通常
   规则的例外，即可能发送的唯一扩展是那些出现在ClientHello中的扩展)。当发送
   新的ClientHello时，客户端必须将HelloRetryRequest中接收到的扩展的内容复制到
   新ClientHello中的“cookie”扩展中。在后续连接中，客户端不得在其初始
   ClientHello中使用Cookie。
 
   当服务器无状态运行时，它可能会在第一个ClientHello和第二个ClientHello之间接收
   change_cipher_spec类型的不受保护的记录(参见第5节)。由于服务器没有存储任何
   状态，这将看起来好像它是要接收的第一条消息。无状态运行的服务器必须忽略这些记录。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.3.  Signature Algorithms
 
   TLS 1.3提供了两个扩展，用于指示在数字签名中可以使用哪些签名算法。
   “signature_algorithms_cert” 扩展适用于证书中的签名，而最初出现在TLS 1.2中的
   “signature_algorithms”扩展适用于 CertificateVerify 消息中的签名。证书中找
   到的密钥还必须是与其一起使用的签名算法的适当类型。这是RSA密钥和PSS签名的特殊
   问题，如下所述。如果不存在“signature_algorithms_cert”扩展，则
   “signature_algorithms”扩展也适用于证书中出现的签名。希望服务器通过证书对自身
   进行身份验证的客户端必须发送“signature_algorithms”扩展。如果服务器通过证书进行
   身份验证，而客户端尚未发送“signature_algorithms”扩展，则服务器必须中止握手
   并发出“missing_extension”警报(参见第9.2节)。
 
   添加了"signature_algorithms_cert"扩展，以允许支持证书和 TLS 本身的不同
   算法集的实现清楚地发出其功能信号。  TLS 1.2 实现也应处理此扩展。在这两种情况下
   具有相同策略的实现可能会省略"signature_algorithms_cert"扩展。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   这些扩展的“extension_data”字段包含SignatureSchemeList 值：
 
      enum {
          /* RSASSA-PKCS1-v1_5 algorithms */
          rsa_pkcs1_sha256(0x0401),
          rsa_pkcs1_sha384(0x0501),
          rsa_pkcs1_sha512(0x0601),
 
          /* ECDSA algorithms */
          ecdsa_secp256r1_sha256(0x0403),
          ecdsa_secp384r1_sha384(0x0503),
          ecdsa_secp521r1_sha512(0x0603),
 
          /* RSASSA-PSS algorithms with public key OID rsaEncryption */
          rsa_pss_rsae_sha256(0x0804),
          rsa_pss_rsae_sha384(0x0805),
          rsa_pss_rsae_sha512(0x0806),
 
          /* EdDSA algorithms */
          ed25519(0x0807),
          ed448(0x0808),
 
          /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */
          rsa_pss_pss_sha256(0x0809),
          rsa_pss_pss_sha384(0x080a),
          rsa_pss_pss_sha512(0x080b),
 
          /* Legacy algorithms */
          rsa_pkcs1_sha1(0x0201),
          ecdsa_sha1(0x0203),
 
          /* Reserved Code Points */
          private_use(0xFE00..0xFFFF),
          (0xFFFF)
      } SignatureScheme;
 
      struct {
          SignatureScheme supported_signature_algorithms&lt;2..2^16-2&gt;;
      } SignatureSchemeList;
 
   注意：这个枚举被命名为“SignatureScheme”，因为在TLS 1.2中已经有一个
   “SignatureAlgorithm”类型，这将被替换。我们在整个文本中使用术语
   “signature algorithm”。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   每个SignatureScheme值列出了客户端愿意验证的单个签名算法。这些值以首选项的降序
   表示。请注意，签名算法将任意长度的消息而不是摘要作为输入。传统上作用于摘要的算法
   应该在TLS中定义，以首先使用指定的散列算法对输入进行散列，然后照常进行。上面列出
   的码点组有以下含义：
 
   RSASSA-PKCS1-v1_5 algorithms:  表示使用 RSASSA-PKCS1-v1_5[RFC8017]
      和[SHS]中定义的相应散列算法的签名算法。这些值仅指出现在证书中的签名(参见
      第4.4.2.2节)，并未定义为在签名的TLS握手消息中使用，尽管为了与TLS 1.2向后
      兼容，它们可能出现在“Signature_Algorithms”
      和“Signature_Algorithms_cert”中。
 
   ECDSA algorithms:  表示使用ECDSA[ECDSA]的签名算法，ANSI X9.62[ECDSA]
      和 FIPS 186-4[DSS]中定义的相应曲线，以及[SHS]中定义的相应散列算法。签名
      表示为DER编码的[X690]ECDSA-sig-value结构。
 
   RSASSA-PSS RSAE algorithms:  表示使用带有掩码生成函数1的
      RSASSA-PSS[RFC8017]的签名算法。掩码生成函数中使用的摘要和正在签名的摘要
      都是[SHS]中定义的相应散列算法。Salt的长度必须等于摘要算法的输出长度。如果
      公钥在X.509证书中携带，则必须使用rsaEncryption OID[RFC5280]。
 
   EdDSA algorithms:  表示使用[RFC8032]或其后继者中定义的EdDSA的签名算法。
      请注意，这些对应于“PureEdDSA”算法，而不是“Manage”变体。
 
   RSASSA-PSS PSS algorithms:  表示使用带有掩码生成函数1的
      RSASSA-PSS[RFC8017]的签名算法。掩码生成函数中使用的摘要和正在签名的摘要
      都是[SHS]中定义的相应散列算法。Salt的长度必须等于摘要算法的长度。如果公钥
      在X.509证书中携带，则必须使用 RSASSA-PSS OID[RFC5756]。在证书签名中使用
      时，必须对算法参数进行DER编码。如果存在相应的公钥参数，则签名中的参数必须与
      公钥中的参数相同。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Legacy algorithms:  表示由于使用具有已知弱点的算法而被弃用的算法，特别是在此
      上下文中与使用(1)RSASSA-PKCS1-v1_5或(2)ECDSA的RSA一起使用的SHA-1。这些
      值仅指出现在证书中的签名(参见第4.4.2.2节)，并未定义为在签名的TLS握手消息中
      使用，尽管为了与TLS 1.2向后兼容，它们可能出现在“Signature_Algorithms”和
      “Signature_Algorithms_cert”中。端点不应协商这些算法，但允许这样做只是
      为了向后兼容。提供这些值的客户端必须将它们列为最低优先级(列在
      SignatureSchemeList中的所有其他算法之后)。TLS 1.3服务器不得提供SHA-1
      签名的证书，除非没有它就无法产生有效的证书链(参见第4.4.2.2节)。
 
   自签名证书上的签名或作为信任锚的证书上的签名不会被验证，因为它们开始了一个证书路径
   (参见[RFC5280]，第 3.2节)。开始认证路径的证书可以使用在
   “signature_algorithms”扩展中未被宣传为受支持的签名算法。
 
   请注意，TLS 1.2对此扩展的定义有所不同。愿意协商TLS 1.2的TLS 1.3实现在协商
   该版本时必须符合[RFC5246]的要求。特别是：
 
   -  TLS 1.2客户端Hellos可以省略此扩展。
 
   -  在TLS 1.2中，扩展包含散列/签名对。这些对以两个二进制八位数编码，因此已
      分配SignatureScheme值以与TLS 1.2的编码对齐。一些遗留对未分配。从TLS 1.3
      开始，不推荐使用这些算法。任何实施都不能提供或协商它们。特别是，不能使用
      MD5[SLOTH]、SHA-224和DSA。
 
   -  ECDSA签名方案与TLS 1.2的ECDSA散列/签名对一致。然而，旧的语义并没有约束
      签名曲线。如果TLS 1.2被协商，实现必须准备接受使用他们在“supported_groups”
      扩展中通告的任何曲线的签名。
 
   -  发布对 RSASSA-PSS 的支持（TLS 1.3 中是强制性的）的实现必须准备好接受使用
      该方案的签名，即使协商 TLS 1.2 也是如此。 在 TLS 1.2 中，RSASSA-PSS 与
      RSA 密码套件一起使用。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.4.  Certificate Authorities
 
   “certificate_authority” 扩展用于指示端点支持的证书颁发机构(CA)，以及接收端点
   应该使用哪些证书颁发机构来指导证书选择。
 
   “certificate_authority”扩展的主体由CertificateAuthoritiesExtension结构
   组成。
 
      opaque DistinguishedName&lt;1..2^16-1&gt;;
 
      struct {
          DistinguishedName authorities&lt;3..2^16-1&gt;;
      } CertificateAuthoritiesExtension;
 
   authorities:  可接受的证书颁发机构的可分辨名称[X501]的列表，以DER编码的
      [X690]格式表示。这些可分辨名称为信任锚或从属CA指定了所需的可分辨名称；因此，
      此消息可用于描述已知的信任锚以及所需的授权空间。
 
   客户端可以在ClientHello消息中发送“certificate_authority”扩展。服务器可以
   在 CertificateRequest 消息中发送它。
 
   “Trusted_ca_keys”扩展[RFC6066]具有类似的用途，但更为复杂，在TLS 1.3中
   未使用(尽管它可能出现在来自提供先前版本的TLS的客户端的ClientHello消息中)。
 
4.2.5.  OID Filters
 
   “oid_filters”扩展允许服务器提供一组OID/值对，它希望客户端的证书匹配这些
   OID/值对。如果服务器提供此扩展，则只能在 CertificateRequest 消息中发送。
 
      struct {
          opaque certificate_extension_oid&lt;1..2^8-1&gt;;
          opaque certificate_extension_values&lt;0..2^16-1&gt;;
      } OIDFilter;
 
      struct {
          OIDFilter filters&lt;0..2^16-1&gt;;
      } OIDFilterExtension;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   filters:  证书扩展OID[RFC5280]及其允许值的列表，并以DER编码的[X690]格式
      表示。一些证书扩展OID允许多个值(例如，扩展密钥用法)。如果服务器包含非空筛选器
      列表，则响应中包含的客户端证书必须包含客户端识别的所有指定扩展OID。对于客户端
      识别的每个扩展OID，所有指定的值都必须存在于客户端证书中(但证书也可以具有其他
      值)。但是，客户端必须忽略并跳过任何无法识别的证书扩展OID。如果客户端忽略了一些
      所需的证书扩展OID，并提供了一个不满足请求的证书，则服务器可以在不进行客户端
      身份验证的情况下继续连接，或者通过“unsupported_certificate”警报中止握手。
      任何给定的OID不得在筛选器列表中出现一次以上。
 
   PKIX RFC定义了各种证书扩展OID及其相应的值类型。根据类型的不同，匹配的证书扩展值
   不一定是逐位相等的。预计TLS实现将依赖于其PKI库来使用证书扩展OID执行证书选择。
 
   本文档为[RFC5280]中定义的两个标准证书扩展定义了匹配规则：
 
   -  当请求中断言的所有密钥使用位也在密钥使用证书扩展中断言时，证书中的密钥使用扩展
      与请求相匹配。
 
   -  证书中的扩展密钥使用扩展与请求匹配，此时请求中存在的所有关键用途 OID 也位于
      扩展密钥使用证书扩展中。 请求中不得使用任何扩展密钥使用 OID 的特殊键。
 
   单独的规范可以为其他证书扩展定义匹配规则。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.6.  Post-Handshake Client Authentication
 
   “post_handshak_auth”扩展用于表示客户端愿意执行握手后身份验证(第4.6.2节)。
   服务器不能向不提供此扩展的客户端发送握手后CertificateRequest。服务器不得发送
   此扩展。
 
      struct {} PostHandshakeAuth;
 
   “post_handshak_auth”扩展的“extension_data”字段长度为零。
 
4.2.7.  Supported Groups
 
   当客户端发送时，“supported_groups”扩展表示客户端支持的用于密钥交换的命名组，
   按从最优先到最不优先的顺序排列。
 
   注意：在TLS 1.3之前的TLS版本中，此扩展为“椭圆曲线”，并且仅包含椭圆曲线组。
   参见[RFC8422]和[RFC7919]。此扩展也用于协商ECDSA曲线。签名算法现在是独立协商
   的(参见第4.2.3节)。
 
   此扩展的“extension_data”字段包含一个“NamedGroupList”值：
 
      enum {
 
          /* Elliptic Curve Groups (ECDHE) */
          secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
          x25519(0x001D), x448(0x001E),
 
          /* Finite Field Groups (DHE) */
          ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),
          ffdhe6144(0x0103), ffdhe8192(0x0104),
 
          /* Reserved Code Points */
          ffdhe_private_use(0x01FC..0x01FF),
          ecdhe_private_use(0xFE00..0xFEFF),
          (0xFFFF)
      } NamedGroup;
 
      struct {
          NamedGroup named_group_list&lt;2..2^16-1&gt;;
      } NamedGroupList;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Elliptic Curve Groups (ECDHE):  表示支持相应的命名曲线，在FIPS 186-4[DSS]
      或[RFC7748]中定义。值0xFE00至0xFEFF保留供私人使用[RFC8126]。
 
   Finite Field Groups (DHE):  表示对[RFC7919]中定义的相应有限域组的支持。
      值0x01FC至0x01FF保留供私人使用。
 
   named_group_list 中的项目根据发件方的偏好排序(最优先选择)。
 
   从TLS 1.3开始，允许服务器向客户端发送“supported_groups”扩展。在成功完成握手
   之前，客户端不能根据在“supported_groups”中找到的任何信息采取行动，但可以使用从
   成功完成的握手中学到的信息来更改它们在后续连接中使用的“key_share”扩展中的组。
   如果服务器具有比“key_share”扩展中的组更喜欢的组，但仍愿意接受ClientHello，则
   应发送“supported_groups”以更新客户端的首选项视图；此扩展应包含服务器支持的所有
   组，无论客户端当前是否支持这些组。
 
4.2.8.  Key Share
 
   “key_share”扩展包含端点的加密参数。
 
   客户端可能会发送空的client_shares 向量，以便向服务器请求组选择，代价是额外的往返
   (参见第4.1.4节)。
 
      struct {
          NamedGroup group;
          opaque key_exchange&lt;1..2^16-1&gt;;
      } KeyShareEntry;
 
   group:  正在交换的密钥的命名组。
 
   key_exchange:  密钥交换信息。此字段的内容由指定的组及其相应的定义确定。有限域
      Diffie-Hellman[DH76]参数在4.2.8.1节中描述；椭圆曲线Diffie-Hellman参数
      在4.2.8.2节中描述。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   在ClientHello消息中，该扩展的“extension_data”字段包含一个
   “KeyShareClientHello”值：
 
      struct {
          KeyShareEntry client_shares&lt;0..2^16-1&gt;;
      } KeyShareClientHello;
 
   client_shares:  按客户端首选项的降序排列的提供的KeyShareEntry值的列表。
 
   如果客户端正在请求HelloRetryRequest，则此向量可能为空。每个KeyShareEntry值
   必须对应于“supported_groups”扩展中提供的组，并且必须以相同的顺序出现。然而，
   这些值可以是“supported_groups”扩展的非连续子集，并且可以省略最优选的组。如果
   最优先的群体是新的，而且不太可能在足够的地方得到支持，以便预先生成关键份额，则
   可能会出现这种情况。
 
   客户端可以提供与其提供的支持组数量相同的KeyShareEntry值，每个组代表一组密钥交换
   参数。例如，客户可能提供几条椭圆曲线或多个FFDHE组的份额。必须独立生成每个
   KeyShareEntry的key_exchange值。客户端不能为同一组提供多个KeyShareEntry值。
   客户端不得为客户端的“Supported_Groups”扩展中未列出的组提供任何KeyShareEntry
   值。服务器可以检查是否违反了这些规则，如果有违反，则中止握手，并发出
   “illegal_parameter”警报。
 
   在HelloRetryRequest消息中，此扩展的“extension_data”字段包含
   KeyShareHelloRetryRequest值：
 
      struct {
          NamedGroup selected_group;
      } KeyShareHelloRetryRequest;
 
   selected_group:  服务器打算协商的相互支持的组，并请求重试的客户端
      Hello/KeyShare。
 
   在HelloRetryRequest中接收到此扩展后，客户端必须验证(1)selected_group字段
   对应于原始ClientHello中的“supported_groups”扩展中提供的组，以及
   (2)selected_group字段不对应于原始 ClientHello 中的 “Key_Share”扩展中提供
   的组。如果这两个检查中的任何一个失败，则客户端必须中止握手并发出
   “illegal_parameter”警报。否则，在发送新的 ClientHello 时，客户端必须将原始
   的“key_share”扩展替换为仅包含触发HelloRetryRequest的selected_group字段中
   指示的组的新KeyShareEntry的扩展。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 


 
   在ServerHello消息中，此扩展的“extension_data”字段包含KeyShareServerHello
   值：
 
      struct {
          KeyShareEntry server_share;
      } KeyShareServerHello;
 
   server_share:  与client's shares之一在同一组中的单个KeyShareEntry值。
 
   如果使用(EC)DHE密钥建立，服务器在ServerHello中只提供一个KeyShareEntry。
   此值必须与服务器为协商的密钥交换选择的客户端提供的KeyShareEntry值在同一组中。
   服务器不得为客户端的“Supported_Groups”扩展中未指明的任何组发送
   KeyShareEntry，也不得在使用“PSK_ke”PskKeyExchangeMode时发送
   KeyShareEntry。如果客户端收到使用(EC)DHE密钥建立和包含“KEY_SHARE”扩展
   的HelloRetryRequest，则客户端必须验证ServerHello中选定的NamedGroup与
   HelloRetryRequest中的NamedGroup相同。如果此检查失败，客户端必须中止握手并
   发出“illegal_parameter”警报。
 
4.2.8.1.  Diffie-Hellman Parameters
 
   客户端和服务器的Diffie-Hellman[DH76]参数都编码在KeyShare结构中
   KeyShareEntry的不透明KEY_EXCHANGE字段中。OPAQUE值包含指定组的
   Diffie-Hellman公共值(Y=g^X mod p)(有关组定义，请参阅[RFC7919])，编码为
   大端整数，并在左侧填充0，大小为p(以字节为单位)。
 
   注意：对于给定的Diffie-Hellman组，填充会导致所有公钥具有相同的长度。
 
   对等点必须通过确保1</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.8.2.  ECDHE Parameters
 
   客户端和服务器的ECDHE参数都编码在KeyShare结构中KeyShareEntry的不透明
   KEY_EXCHANGE字段中。
 
   对于secp256r1、secp384r1和secp521r1，内容是以下struct的序列化值：
 
      struct {
          uint8 legacy_form = 4;
          opaque X[coordinate_length];
          opaque Y[coordinate_length];
      } UncompressedPointRepresentation;
 
   X和Y分别是网络字节顺序中x和y值的二进制表示。没有内部长度标记，因此每个数字表示
   占用与曲线参数所暗示的一样多的二进制八位数。对于P-256，这意味着X和Y中的每一个都
   使用32个二进制八位数，如有必要，在左侧用零填充。对于P-384，他们每个采取48个八位
   组。对于P-521，他们每个采取66个八位组。
 
   对于曲线secp256r1、secp384r1和secp521r1，对等节点必须通过确保该点是椭圆曲线
   上的有效点来验证彼此的公共值Q。适当的验证程序在[ECDSA]的第4.3.7节中定义，或者在
   [KEYAGREEMENT]的第5.6.2.3节中定义。这个过程包括三个步骤：(1)验证q不是无穷远处
   的点(O)，(2)验证对于q=(x，y)整数x和y都在正确的区间内，以及(3)确保(x，y)是椭圆
   曲线方程的正确解。对于这些曲线，实现者不需要验证正确子组中的成员资格。
 
   对于X25519和X448，公共值的内容是[RFC7748]中定义的相应函数的字节串输入和
   输出：X25519为32字节，X448为56字节。
 
   注意：1.3之前的TLS版本允许点格式协商；TLS 1.3删除了此功能，支持每条曲线的
   单点格式。
 
4.2.9.  Pre-Shared Key Exchange Modes
 
   为了使用PSK，客户端还必须发送“psk_key_exchange_modes”扩展。此扩展的语义是
   客户端仅支持使用具有这些模式的PSK，这限制了在此ClientHello中提供的PSK的使用，
   以及服务器可能通过NewSessionTicket提供的PSK的使用。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   如果客户端提供“pre_shared_key”扩展，则它必须提供“psk_key_exchange_modes”
   扩展。如果客户端提供的“pre_shared_key”不带“psk_key_exchange_modes”扩展，
   则服务器必须中止握手。服务器不得选择客户端未列出的密钥交换模式。此扩展还限制了
   用于PSK恢复的模式。服务器不应发送带有与通告模式不兼容的票证的NewSessionTicket；
   但是，如果服务器这样做，其影响只会是客户端的恢复尝试失败。
 
   服务器不得发送“psk_key_exchange_modes”扩展。
 
      enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;
 
      struct {
          PskKeyExchangeMode ke_modes&lt;1..255&gt;;
      } PskKeyExchangeModes;
 
   psk_ke:  仅PSK密钥建立。在此模式下，服务器不得提供“key_share”值。
 
   psk_dhe_ke:  PSK与(EC)DHE密钥建立。在此模式下，客户端和服务器必须提供
       “key_share”值，如第4.2.8节所述。
 
   分配的任何未来值必须确保传输的协议消息明确地标识服务器选择了哪种模式；目前，这是
   由ServerHello中存在的“key_share”指示的。
 
4.2.10.  Early Data Indication
 
   当使用PSK并且允许该PSK的早期数据时，客户端可以在其第一次发送消息时发送应用程序
   数据。如果客户端选择这样做，它必须同时提供“pre_shared_key”和“Early_Data”
   扩展。
 
   此扩展的“extension_data”字段包含一个“EarlyDataIndication”值。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
      struct {} Empty;
 
      struct {
          select (Handshake.msg_type) {
              case new_session_ticket:   uint32 max_early_data_size;
              case client_hello:         Empty;
              case encrypted_extensions: Empty;
          };
      } EarlyDataIndication;
 
   有关max_early_data_size 字段使用的详细信息，请参阅第4.6.1节。
 
   0-RTT数据的参数(版本、对称密码组、应用层协议协商(ALPN)[RFC7301]协议等)。是与
   正在使用的PSK相关联的那些。对于外部调配的PSK，关联值是与密钥一起调配的值。对于
   通过 NewSessionTicket 消息建立的PSK，关联值是在建立 PSK 的连接中协商的那些
   值。用于加密早期数据的PSK必须是客户端的“pre_shared_key”扩展中列出的第一个PSK。
 
   对于通过 NewSessionTicket 提供的PSK，服务器必须验证所选PSK身份(通过从
   PskIdentity.obfuscated_ticket_age % 2^32 - Ticket_age_add计算)的票龄
   在自票证发出后的时间容差内(参见第8节)。如果不是，则服务器应继续握手，但拒绝
   0-RTT，并且不应采取任何其他假定此ClientHello是新的操作。
 
   在第一个航班中发送的0-RTT消息与在其他航班中发送的相同类型的消息(握手和应用数据)
   具有相同的(加密的)内容类型，但受到不同密钥的保护。在接收到服务器的完成消息后，
   如果服务器已经接受了早期数据，则会发送EndOfEarlyData消息以指示密钥更改。此消息
   将使用0-RTT业务密钥进行加密。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   接收“early_data”扩展的服务器必须采用以下三种方式之一：
 
   -  忽略扩展并返回常规的 1-RTT 响应。 然后，服务器会跳过过去的早期数据，尝试使用
      握手流密钥取消对接收到的记录层的保护，丢弃未能取消保护的记录数据（最多为配置的
      max_early_data_size）。 一旦记录层被成功取消保护，它将被视为客户端第二次
      消息的开始，服务器继续执行普通 1-RTT 握手。
 
   -  请求客户端通过响应 HelloRetryRequest 发送另一个 ClientHello 。 客户端
      不得在其后续 ClientHello 中包含"early_data"扩展。 然后，服务器通过跳过
      外部内容类型为"application_data"（指示它们已加密）的所有记录来忽略早期
      数据，最长为已配置的 max_early_data_size。
 
   -  在EncryptedExtensions中返回自己的“early_data”扩展，表示打算处理早期数据。
      服务器不可能仅接受早期数据消息的子集。即使服务器发送接受早期数据的消息，实际的
      早期数据本身在服务器生成此消息时可能已经在运行。
 








   为了接受早期数据，服务器必须接受PSK密码套件并选择客户端的“pre_shared_key”扩展
   中提供的第一个密钥。此外，它必须验证以下值是否与所选PSK关联的值相同：
 
   -  TLS版本号
 
   -  选定的密码套件
 
   -  所选ALPN[RFC7301]协议(如果有)
 
   这些要求是使用所讨论的 PSK 执行 1-RTT 握手所需的那些要求的超集。对于外部建立的
   PSK，关联值是与密钥一起提供的值。对于通过 NewSessionTicket 消息建立的 PSK，
   关联值是在建立票证的连接中协商的那些值。
 
   未来的扩展必须定义它们与0-RTT的交互。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   如果这些检查中的任何一个失败，服务器必须不响应扩展，并且必须使用上面列出的前两个
   机制之一丢弃所有的第一次飞行数据(因此回退到1-RTT或2-RTT)。如果客户端尝试0-RTT
   握手，但服务器拒绝它，则服务器通常不具有0-RTT记录保护密钥，并且必须改为使用试用
   解密(或者使用1-RTT握手密钥，或者通过在HelloRetryRequest的情况下通过查找明文
   ClientHello)来找到第一个非0-RTT消息。
 
   如果服务器选择接受“early_data”扩展，则在处理早期数据记录时，它必须符合为所有
   记录指定的相同错误处理要求。具体地说，如果服务器在接受的“early_data”扩展之后
   未能解密0-RTT记录，则必须按照5.2节的规定使用“bad_record_mac”警报终止连接。
 
   如果服务器拒绝“early_data”扩展，则一旦握手完成，客户端应用程序可以选择重新传输
   先前在early_data中发送的应用程序数据。注意，早期数据的自动重传可能导致关于连接
   状态的不正确假设。例如，当协商的连接选择与用于早期数据的ALPN协议不同的ALPN协议
   时，应用程序可能需要构造不同的消息。同样，如果早期数据假定有关连接状态的任何内容，
   则可能在握手完成后错误地发送。
 
   TLS实现不应自动重新发送早期数据；应用程序可以更好地决定何时重新传输是合适的。
   除非协商的连接选择相同的ALPN协议，否则TLS实现不得自动重新发送早期数据。
 












4.2.11.  Pre-Shared Key Extension
 
   “pre_shared_key”扩展用于协商与PSK密钥建立关联的给定握手使用的预共享密钥的身份。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   此扩展的“extension_data”字段包含“PreSharedKeyExtension”值：
 
      struct {
          opaque identity&lt;1..2^16-1&gt;;
          uint32 obfuscated_ticket_age;
      } PskIdentity;
 
      opaque PskBinderEntry&lt;32..255&gt;;
 
      struct {
          PskIdentity identities&lt;7..2^16-1&gt;;
          PskBinderEntry binders&lt;33..2^16-1&gt;;
      } OfferedPsks;
 
      struct {
          select (Handshake.msg_type) {
              case client_hello: OfferedPsks;
              case server_hello: uint16 selected_identity;
          };
      } PreSharedKeyExtension;
 
   identity:  密钥标签。例如，票证(如附录B.3.4中所定义)或外部建立的预共享密钥的
      标签。
 
   obfuscated_ticket_age:  密钥年龄的模糊版本。第4.2.11.1节描述了如何为通过
      NewSessionTicket 消息建立的身份形成此值。对于外部建立的身份，应使用0的
      obfuscated_ticket_age，并且服务器必须忽略该值。
 
   identities:  客户端愿意与服务器协商的身份列表。如果与“early_data”扩展一起发送
      (参见第4.2.10节)，则第一个身份是用于0-RTT数据的身份。
 
   binders:  一系列HMAC值，每个值对应身份列表中的每个值，并按相同的顺序进行计算，
      如下所述。
 
   selected_identity:  服务器选择的标识，表示为客户端列表中标识的(从0开始)索引。
 






   每个PSK与单个散列算法相关联。对于通过票证机制建立的PSK(第4.6.1节)，这是建立
   票证的连接上的KDF哈希算法。对于外部建立的PSK，在建立PSK时必须设置Hash算法，如果
   未定义此类算法，则默认设置为SHA-256。服务器必须确保它选择兼容的PSK(如果有的话)
   和密码套件。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   
 
   在TLS 1.3之前的TLS版本中，服务器名称标识(SNI)值旨在与会话相关联(
   [RFC6066]的第3节)，要求服务器强制与会话关联的SNI值与恢复握手中指定的SNI值相
   匹配。然而，在现实中，对于它们将使用两个提供的SNI值中的哪一个，实现并不一致，导致
   客户端事实上强制执行一致性要求。在TLS 1.3中，SNI值总是在恢复握手中显式指定，
   服务器不需要将SNI值与票证相关联。然而，客户应将SNI与PSK一起存储，以满足
   第4.6.1节的要求。
 








   实现者注意：当会话恢复是PSK的主要用例时，实现PSK/密码套件匹配要求的最直接的方法
   是首先协商密码套件，然后排除任何不兼容的PSK。应该简单地忽略任何未知的PSK(例如，
   不在PSK数据库中或用未知密钥加密的PSK)。如果未找到可接受的PSK，则服务器应执行
   非PSK握手(如果可能)。如果向后兼容性很重要，客户端提供的外部建立的PSK应该会影响
   密码套件的选择。
 



   在接受PSK密钥建立之前，服务器必须验证相应的绑定器值(参见下面的4.2.11.2节)。
   如果此值不存在或未验证，则服务器必须中止握手。服务器不应尝试验证多个绑定器；相反，
   它们应该选择单个PSK并仅验证对应于该PSK的绑定器。有关此要求的安全理由，请参见
   第8.2节和附录E.6。为了接受PSK密钥建立，服务器发送指示所选身份的
   “pre_shared_key”扩展。
 
   客户端必须验证服务器的selected_identity是否在客户端提供的范围内，服务器是否
   选择了指示与PSK关联的哈希的密码套件，以及如果 ClientHello
   “psk_key_exchange_modes”扩展需要，服务器“key_share”扩展是否存在。如果这些值
   不一致，客户端必须中止握手并发出“illegal_parameter”警报。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   如果服务器提供了“early_data”扩展名，则客户端必须验证服务器的selected_identity
   是否为0。如果返回任何其他值，则客户端必须中止握手并发出“illegal_parameter”
   警报。
 
   “pre_shared_key”扩展名必须是ClientHello中的最后一个扩展名(这便于实现，如下
   所述)。服务器必须检查它是否是最后一个扩展名，否则握手失败，并显示
   “illegal_parameter” 警报。
 
4.2.11.1.  Ticket Age
 
   客户端对票龄的看法是自收到 NewSessionTicket 消息以来的时间。客户端不得尝试使用
   年龄大于随票证提供的“ticket_lifetime”值的票证。每个PskIdentity的
   “obfuscated_ticket_age” 字段包含一个模糊版本的票龄，其形成方式是以毫秒为单位
   取年龄并添加票证附带的“ticket_age_add”值(参见第4.6.1节)，模数为2^32。此添加
   可防止被动观察者关联连接，除非重新使用票证。请注意，NewSessionTicket消息中的
   “ticket_lifetime”字段以秒为单位，而“obfuscated_ticket_age”以毫秒为单位。
   由于票证寿命被限制为一周，因此32位足以表示任何合理的年龄，即使以毫秒为单位。
 
4.2.11.2.  PSK Binder
 
   PSK 绑定器值在 PSK 和当前握手之间形成绑定，以及在生成 PSK 的握手（如果通过
   NewSessionTicket消息）和当前握手之间的绑定。绑定器列表中的每个条目都被计算为
   基于包含部分ClientHello的哈希值，包括PreSharedKeyExtension.identities的
   HMAC。也就是说，它包括所有ClientHello，但不包括绑定器列表本身。消息的长度字段
   (包括总长度、扩展块的长度和“pre_shared_key”扩展的长度)都被设置为好像存在正确
   长度的绑定器一样。
 
   PskBinderEntry的计算方法与Finished消息相同(第4.4.4节)，但BaseKey是通过密钥
   进度表从提供的相应PSK导出的binder_key(参见7.1节)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   如果握手包括 HelloRetryRequest，则初始客户端Hello和 HelloRetry请求将连同
   新的ClientHello一起包含在记录中。 例如，如果客户端发送 ClientHello1，其
   绑定器将通过以下方式计算：
 
      Transcript-Hash(Truncate(ClientHello1))
 
   其中 Truncate() 从ClientHello 中删除绑定器列表。
 
   如果服务器响应HelloRetryRequest，然后客户端发送ClientHello2，则将计算其绑定：
 
      Transcript-Hash(ClientHello1,
                      HelloRetryRequest,
                      Truncate(ClientHello2))
 
   完整的ClientHello1/ClientHello2包含在所有其他握手散列计算中。请注意，在
   第一次飞行中，Truncate(ClientHello1)直接进行散列，但在第二次飞行中，对
   ClientHello1进行散列，然后作为“message_hash”消息重新注入，如第4.4.1节所述。
 
4.2.11.3.  Processing Order
 
   允许客户端“流式传输”0-RTT数据，直到它们接收到服务器完成，然后才发送
   EndOfEarlyData消息，然后是握手的其余部分。为了避免死锁，在接受“early_data”
   时，服务器必须处理客户端的ClientHello，然后立即发送它们的消息，而不是在发送
   ServerHello之前等待客户端的EndOfEarlyData消息。
 
4.3.  Server Parameters
 
   接下来来自服务器的两条消息 EncryptedExtensions 和 CertificateRequest 包含
   来自服务器的信息，这些信息决定了握手的其余部分。使用从
   server_handshake_traffic_secret派生的密钥对这些消息进行加密。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.3.1.  Encrypted Extensions
 
   在所有握手中，服务器必须在ServerHello消息之后立即发送EncryptedExtensions
   消息。这是在从server_handshak_traffic_secret派生的密钥下加密的第一条消息。
 
   加密扩展消息包含可受保护的扩展，即任何不需要建立加密上下文但不与单个证书关联的
   扩展。客户端必须检查EncryptedExtensions是否存在任何禁止的扩展，如果发现任何
   扩展，则必须中止握手并发出“illegal_parameter”警报。
 
   Structure of this message:
 
      struct {
          Extension extensions&lt;0..2^16-1&gt;;
      } EncryptedExtensions;
 
   extensions:  扩展列表。有关更多信息，请参见4.2节中的表格。
 
4.3.2.  Certificate Request
 
   使用证书进行身份验证的服务器可以可选地向客户端请求证书。如果发送此消息，则必须在
   EncryptedExtensions之后。
 
   Structure of this message:
 
      struct {
          opaque certificate_request_context&lt;0..2^8-1&gt;;
          Extension extensions&lt;2..2^16-1&gt;;
      } CertificateRequest;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   certificate_request_context:  标识证书请求并将在客户端的证书消息中回显的
      字符串。certificate_request_context 在此连接范围内必须是唯一的(从而防止
      客户端 CertificateVerify 消息的重播)。此字段应为零长度，除非用于4.6.2节
      中描述的握手后身份验证交换。当请求握手后身份验证时，服务器应使上下文对客户端
      不可预测(例如，通过随机生成上下文)，以防止对客户端私钥具有临时访问权限的
      攻击者预先计算有效的CertificateVerify消息。
 
   extensions:  描述所请求证书的参数的一组扩展。必须指定“signature_algorithms”
      扩展，如果为此消息定义了其他扩展，则可以选择包括其他扩展。客户端必须忽略无法
      识别的扩展。
 







   在TLS的以前版本中，CertificateRequest消息包含服务器将接受的签名算法和证书颁发
   机构的列表。在TLS 1.3中，前者通过发送“signature_algorithms”和可选的
   “signature_algorithms_cert”扩展来表示。后者通过发送
   “certificate_authority”扩展来表示(参见第4.2.4节)。
 
   使用PSK进行身份验证的服务器不得在主握手中发送CertificateRequest消息，尽管它们
   可以在握手后身份验证中发送该消息(参见第4.6.2节)，但前提是客户端已发送
   “post_handshak_auth”扩展(参见第4.2.6节)。
 

4.4.  Authentication Messages
 
   如第2节所述，TLS通常使用一组通用的消息进行身份验证、密钥确认和握手
   完整性：Certificate、CertificateVerify和Finish。(PSK绑定器也以类似的方式
   执行密钥确认。)。这三条消息总是作为他们握手飞行中的最后一条消息发送。Certificate
   和CertificateVerify 消息仅在某些情况下发送，定义如下。完成的消息始终作为身份
   验证块的一部分发送。这些消息在从 [sender]_handshake_traffic_secret 派生的
   密钥下进行加密。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   验证消息的计算都统一采用以下输入:
 
   -  要使用的证书和签名密钥
 
   -  握手上下文，由要包含在记录散列中的一组消息组成。
 
   -  用于计算MAC密钥的基础密钥。
 
   基于这些输入，消息随后添加：
 
   Certificate:  用于身份验证的证书，以及链中的任何支持证书。请注意，基于证书的
      客户端身份验证在PSK握手流(包括0-RTT)中不可用。
 
   CertificateVerify:  Hash(Handshake Context, Certificate)的签名
 
   Finished:  使用从基密钥派生的MAC密钥在 Transcript-Hash(Handshake   
      Context, Certificate，CertificateVerify) 的值上进行MAC。
 
   下表定义了每个场景的握手上下文和MAC基础密钥：
 
   +-----------+-------------------------+-----------------------------+
   | Mode      | Handshake Context       | Base Key                    |
   +-----------+-------------------------+-----------------------------+
   | Server    | ClientHello ... later   | server_handshake_traffic_   |
   |           | of EncryptedExtensions/ | secret                      |
   |           | CertificateRequest      |                             |
   |           |                         |                             |
   | Client    | ClientHello ... later   | client_handshake_traffic_   |
   |           | of server               | secret                      |
   |           | Finished/EndOfEarlyData |                             |
   |           |                         |                             |
   | Post-     | ClientHello ... client  | client_application_traffic_ |
   | Handshake | Finished +              | secret_N                    |
   |           | CertificateRequest      |                             |
   +-----------+-------------------------+-----------------------------+</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.4.1.  The Transcript Hash
 
   TLS 中的许多加密计算都使用Transcript哈希。 此值是通过对包含的每个握手消息（包括
   包含握手消息类型和长度字段的握手消息标头）的串联进行哈希计算的，但不包括记录层
   标头。即：
 
    Transcript-Hash(M1, M2, ... Mn) = Hash(M1 || M2 || ... || Mn)
 
   作为此一般规则的例外情况，当服务器使用 HelloRetryRequest 响应 ClientHello
   时，ClientHello1  的值将替换为包含哈希（ClientHello1）的握手类型为
   "message_hash" 的特殊合成握手消息。 即
 
  Transcript-Hash(ClientHello1, HelloRetryRequest, ... Mn) =
      Hash(message_hash ||        /* Handshake type */
           00 00 Hash.length  ||  /* Handshake message length (bytes) */
           Hash(ClientHello1) ||  /* Hash of ClientHello1 */
           HelloRetryRequest  || ... || Mn)
 
   这种构造的原因是允许服务器通过在cookie中仅存储ClientHello1的散列来执行无状态
   HelloRetryRequest，而不是要求它导出整个中间散列状态(参见第4.2.2节)。
 
   为具体起见，始终从以下握手消息序列中提取记录散列，从第一个ClientHello开始，并且
   仅包括发送的那些消息：ClientHello，HelloRetryRequest，ClientHello，
   ServerHello，EncryptedExtensions，server CertificateRequest，
   server Certificate，server CertificateVerify，Server Finish，
   EndOfEarlyData，Client Certificate，Client CertificateVerify，
   Client Finish。

 
   通常，实现可以通过基于协商的散列保持运行的Transcript Hash来实现抄本。然而，
   请注意，后续的握手后身份验证不包括彼此，只包括通过主握手结束的消息。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.4.2.  Certificate
 
   此消息将端点的证书链传递给对等体。
 
   每当商定的密钥交换方法使用证书进行身份验证时，服务器必须发送证书消息(这包括本文档
   中定义的所有密钥交换方法，PSK除外)。
 
   当且仅当服务器通过CertificateRequest消息请求客户端身份验证时，客户端必须发送
   证书消息(第4.3.2节)。如果服务器请求客户端身份验证，但没有合适的证书可用，则客户端
   必须发送不包含证书的证书消息(即，“certificate_list”字段的长度为0)。无论证书
   消息是否为空，都必须发送 Finished 消息。
 
   Structure of this message:
 
      enum {
          X509(0),
          RawPublicKey(2),
          (255)
      } CertificateType;
 
      struct {
          select (certificate_type) {
              case RawPublicKey:
                /* From RFC 7250 ASN.1_subjectPublicKeyInfo */
                opaque ASN1_subjectPublicKeyInfo&lt;1..2^24-1&gt;;
 
              case X509:
                opaque cert_data&lt;1..2^24-1&gt;;
          };
          Extension extensions&lt;0..2^16-1&gt;;
      } CertificateEntry;
 
      struct {
          opaque certificate_request_context&lt;0..2^8-1&gt;;
          CertificateEntry certificate_list&lt;0..2^24-1&gt;;
      } Certificate;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   certificate_request_context:  如果此消息响应CertificateRequest，则为该
      消息中certificate_request_context的值。否则(在服务器身份验证的情况下)，
      此字段应为零长度。
 
   certificate_list:  CertificateEntry结构的序列(链)，每个结构包含一个证书和
      一组扩展。
 
   extensions:  CertificateEntry的一组扩展值。“扩展”格式在4.2节中定义。目前
      服务器证书的有效扩展包括OCSP状态扩展[RFC6066]和
      SignedCertificateTimestamp扩展[RFC6962]；也可以为此消息定义未来的扩展。
      来自服务器的证书消息中的扩展必须对应于ClientHello消息中的扩展。来自客户端
      的证书消息中的扩展必须对应于来自服务器的CertificateRequest消息中的扩展。
      如果扩展应用于整个链，则应将其包括在第一个CertificateEntry中。
 
   如果在EncryptedExtensions中未协商相应的证书类型扩展
   (“server_certificate_type” 或 “client_certificate_type”)，或者协商了
   X.509证书类型，则每个 CertificateEntry 都包含一个 DER 编码的 X.509证书 。
   发送者的证书必须位于列表中的第一个 CertificateEntry 中。每一个紧随其后的证书
   都应直接证明紧接其前的证书。因为证书验证需要独立分发信任锚点，所以可以从链中省略
   指定信任锚点的证书，前提是所支持的对等体已知拥有任何省略的证书。
 
   注意：在TLS 1.3之前，“certificate_list”排序要求每个证书对紧接它之前的证书
   进行认证；然而，一些实现允许一些灵活性。服务器有时会出于过渡目的同时发送当前和
   不推荐使用的中间件，而其他服务器只是配置不正确，但这些情况仍然可以正确地进行验证。
   为了获得最大的兼容性，所有实现都应该准备好处理来自任何TLS版本的可能无关的证书
   和任意顺序，但第一个证书必须是发送者的证书。
 
   如果协商了RawPublicKey证书类型，则certificate_list必须包含不超过一个
   CertificateEntry，其中包含一个 ASN1_SubjectPublicKeyInfo 值，
   如[RFC7250]第3节所定义。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   OpenPGP证书类型[RFC6091]不能与TLS 1.3一起使用。
 
   服务器的certificate_list必须始终为非空。如果客户端没有要发送的适当证书来响应
   服务器的身份验证请求，则它将发送一个空的certificate_list。
 
4.4.2.1.  OCSP Status and SCT Extensions
 
   [RFC6066]和[RFC6961]提供扩展以协商服务器向客户端发送OCSP响应。在TLS 1.2及
   更低版本中，服务器以空扩展回复以指示此扩展的协商，并且在CertificateStatus消息中
   携带OCSP信息。在TLS 1.3中，服务器的OCSP信息在包含相关证书的CertificateEntry
   中的扩展中携带。具体地说，来自服务器的“status_request”扩展的主体必须是
   [RFC6066]中定义的CertificateStatus结构，其解释为[RFC6960]中定义的。
 
   注意：status_request_v2 扩展[RFC6961]已弃用。在处理ClientHello消息时，
   TLS 1.3 服务器不得根据其存在或其中的信息进行操作；尤其是，它们不得在
   EncryptedExtensions、CertificateRequest 或 Certificate消息中发送
   status_request_v2扩展。TLS 1.3 服务器必须能够处理包含它的ClientHello消息，
   因为它可能由在早期协议版本中使用它的客户端发送。
 
   服务器可以通过在其CertificateRequest消息中发送空的“status_request”扩展来
   请求客户端将OCSP响应与其证书一起呈现。如果客户端选择发送OCSP响应，其
   “status_request”扩展的主体必须是[RFC6066]中定义的CertificateStatus结构。
 
   类似地，[RFC6962]为服务器提供了一种机制，用于在TLS 1.2及更低版本的ServerHello
   中发送签名证书时间戳(Signed Certificate Timestamp，SCT)作为扩展。在
   TLS 1.3中，服务器的 SCT 信息在CertificateEntry中的扩展中携带。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.4.2.2.  服务器证书选择
 
   以下规则适用于服务器发送的证书：
 
   -  证书类型必须是X.509v3[RFC5280]，除非明确协商(例如，[RFC7250])。
 
   -  服务器的最终实体证书的公钥(及相关限制)必须与从客户端的
      “signature_algorithms”扩展(当前为RSA、ECDSA或EdDSA)中选择的身份验证
      算法兼容。
 
   -  证书必须允许使用密钥进行签名(即，如果存在密钥使用扩展，则必须设置
      digitalSignature位)，并在客户端的
      “signature_algorithms”/“signature_algorithms_cert”扩展中指定签名方案
      (参见第4.2.3节)。
 
   -  “server_name”[RFC6066]和“certificate_authority”扩展名用于指导证书
      选择。由于服务器可能需要存在“server_name”扩展，因此客户端应发送此扩展
      (如果适用)。
 
   如果服务器能够提供这样的链，则服务器提供的所有证书都必须使用客户端公布的签名算法
   进行签名(见第4.2.3节)。自签名的证书或预期为信任锚的证书不作为链的一部分进行验证，
   因此可以使用任何算法进行签名。
 
   如果服务器不能产生仅通过所指示的支持的算法签名的证书链，则它应该通过向客户端发送
   其选择的证书链来继续握手，该证书链可能包括不知道客户端支持的算法。此回退链一般
   不应使用已弃用的SHA-1哈希算法，但如果客户端的广告允许，则可以这样做，否则不得
   这样做。
 
   如果客户端无法使用提供的证书构建可接受的链，并决定中止握手，则必须使用适当的证书
   相关警报中止握手(默认情况下，为“unsupported_certificate”；有关更多信息，
   请参见第6.2节)。
 
   如果服务器有多个证书，它会根据上述标准(除了其他标准，如传输层端点、本地配置和
   首选项)选择其中一个。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.4.2.3.  客户端证书选择
 
   以下规则适用于客户端发送的证书：
 
   -  证书类型必须是X.509v3[RFC5280]，除非明确协商(例如，[RFC7250])。
 
   -  如果CertificateRequest消息中存在“certificate_authority”扩展，则
      证书链中的至少一个证书应由列出的CA之一颁发。
 
   -  必须使用可接受的签名算法对证书进行签名，如第4.3.2节所述。请注意，这将放宽
      TLS以前版本中对证书签名算法的限制。
 
   -  如果CertificateRequest消息包含非空的“oid_filters”扩展，则最终实体证书
      必须与客户端识别的扩展OID相匹配，如第4.2.5节所述。
 
4.4.2.4.  接收证书消息
 
   一般来说，详细的证书验证程序超出了TLS的范围(参见[RFC5280])。本节提供特定于TLS
   的要求。
 
   如果服务器提供空的证书消息，则客户端必须中止握手并发出“decode_error”警报。
 
   如果客户端不发送任何证书(即，它发送空的证书消息)，则服务器可以在不进行客户端身份
   验证的情况下继续握手，或者使用“certificate_required”警报中止握手。此外，如果
   证书链的某些方面是不可接受的(例如，它不是由已知的、受信任的CA签署的)，则服务器
   可以根据其判断继续握手(考虑到客户端未认证)或中止握手。
 
   任何接收到需要使用任何签名算法(使用MD5散列)验证的证书的端点必须中止握手并发出
   “bad_certificate”警报。SHA-1已弃用，建议接收需要使用SHA-1散列的任何签名算法
   验证的任何证书的任何端点使用“bad_certificate”警报中止握手。为了清楚起见，
   这意味着端点可以接受自签名证书或信任锚证书的这些算法。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   建议所有端点尽快过渡到SHA-256或更好的版本，以保持与当前正在逐步取消SHA-1支持的
   实施的互操作性。
 
   注意，包含一个签名算法的密钥的证书可以使用不同的签名算法(例如，用ECDSA密钥签名
   的RSA密钥)进行签名。
 
4.4.3.  Certificate Verify
 
   此消息用于提供端点拥有与其证书相对应的私钥的明确证明。CertificateVerify 消息
   还为目前为止的握手提供了完整性。服务器在通过证书进行身份验证时必须发送此消息。
   每当通过证书进行身份验证时(即证书消息非空时)，客户端都必须发送此消息。发送时，
   此消息必须立即出现在证书消息之后，并紧接着出现在完成消息之前。
 
   Structure of this message:
 
      struct {
          SignatureScheme algorithm;
          opaque signature&lt;0..2^16-1&gt;;
      } CertificateVerify;
 
   算法字段指定使用的签名算法(有关此类型的定义，请参见第4.2.3节)。签名是使用该算法
   的数字签名。签名所涵盖的内容是第4.4.1节所述的哈希输出，即：
 
      Transcript-Hash(Handshake Context, Certificate)
 
   然后通过以下级联计算数字签名：
 
   -  由重复64次的八位字节32(0x20)组成的字符串。
 
   -  上下文字符串。
 
   -  作为分隔符的单个0字节。
 
   -  要签名的内容</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   此结构旨在防止对以前版本的TLS的攻击，其中ServerKeyExchange格式意味着攻击者
   可以获得具有所选32字节前缀(ClientHello.random)的消息的签名。初始的64字节填充
   清除该前缀以及服务器控制的ServerHello.random。
 
   服务器签名的上下文字符串是“TLS 1.3，server CertificateVerify”。客户端签名的
   上下文字符串是“TLS 1.3，Client CertificateVerify”。它用于提供在不同上下文中
   进行的签名之间的分离，有助于防止潜在的跨协议攻击。
 
   例如，如果记录散列为32字节01(此长度对于SHA-256有意义)，则服务器
   CertificateVerify 的数字签名所涵盖的内容将为：
 
      2020202020202020202020202020202020202020202020202020202020202020
      2020202020202020202020202020202020202020202020202020202020202020
      544c5320312e332c207365727665722043657274696669636174655665726966
      79
      00
      0101010101010101010101010101010101010101010101010101010101010101
 
   在发送方，CertificateVerify消息的签名字段的计算过程作为输入：
 
   -  数字签名覆盖的内容。
 
   -  前一条消息中发送的证书对应的私有签名密钥。
 
   如果CertificateVerify消息是由服务器发送的，则签名算法必须是客户端的
   “Signature_Algorithms”扩展中提供的算法，除非在没有不支持的算法的情况下无法
   生成有效的证书链(参见4.2.3节)。
 
   如果由客户端发送，则签名中使用的签名算法必须是CertificateRequest消息中
   “signature_algorithms”扩展的supported_signature_algorithms字段中存在的
   算法之一。
 
   此外，签名算法必须与发送方的最终实体证书中的密钥兼容。RSA签名必须使用RSASSA-PSS
   算法，无论“signature_algorithms”中是否出现RSASSA-PKCS1-v1_5算法。不能在
   CertificateVerify 消息的任何签名中使用SHA-1算法。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   本规范中的所有SHA-1签名算法都是专为在传统证书中使用而定义的，对于
   CertificateVerify签名无效。
 
   CertificateVerify消息的接收方必须验证签名字段。验证过程采用以下输入：
 
   -  数字签名覆盖的内容。
 
   -  包含在相关证书消息中找到的对方证书中的公钥。
 
   -  CertificateVerify消息的Signature字段中收到的数字签名。
 
   如果验证失败，接收方必须终止握手并发出“decrypt_error”警报。
 
4.4.4.  Finished
 
   Finished消息是身份验证块中的最终消息。它对于提供握手和计算出的密钥的认证是
   必不可少的。
 
   Finished消息的接收者必须验证内容是否正确，如果不正确，则必须使用
   “decrypt_error”警报终止连接。
 
   一旦一方发送了其 Finished 消息并从其对等方接收并验证了 Finished 消息，它就
   可以开始通过连接发送和接收应用程序数据。允许在接收对等体的 Finished 之前发送
   数据的设置有两种：
 
   1.  客户端发送第4.2.10节所述的0-RTT数据。
 
   2.  服务器可在发送第一次飞行后发送数据，但由于握手尚未完成，因此无法保证对等方
       的身份或其活动性（即，ClientHello 可能已被重播）。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   用于计算完成消息的密钥是使用HKDF根据4.4节中定义的基本密钥计算的(参见7.1节)。
   具体而言：
 
   finished_key =
       HKDF-Expand-Label(BaseKey, "finished", "", Hash.length)
 
   Structure of this message:
 
      struct {
          opaque verify_data[Hash.length];
      } Finished;
 
   The verify_data value is computed as follows:
 
      verify_data =
          HMAC(finished_key,
               Transcript-Hash(Handshake Context,
                               Certificate*, CertificateVerify*))
 
      * Only included if present.
 
   HMAC[RFC2104]使用哈希算法进行握手。如上所述，HMAC输入通常可以通过正在运行的
   散列(即，仅在此时的握手散列)来实现。
 
   在TLS的早期版本中，VERIFY_DATA始终是12个八位字节的长度。在TLS 1.3中，它是
   用于握手的哈希的HMAC输出的大小。
 
   注意：警报和任何其他非握手记录类型不是握手消息，不包括在散列计算中。
 
   Finished消息之后的任何记录都必须按照第7.2节所述，在适当的应用流密钥下进行加密。
   特别是，这包括服务器为响应客户端Certificate 和CertificateVerify消息而发送的
   任何警报。
 
4.5.  End of Early Data
 
      struct {} EndOfEarlyData;
 
   如果服务器在EncryptedExtensions中发送了“early_data”扩展，则客户端必须在
   接收服务器 Finished 后发送 EndOfEarlyData 消息。如果服务器不在
   EncryptedExtensions中发送“early_data”扩展，则客户端不能发送EndOfEarlyData
   消息。该消息指示所有 0-RTT application_data 消息(如果有的话)都已被传输，并且
   以下记录在握手业务密钥下受到保护。服务器不能发送此消息，接收此消息的客户端必须终止
   连接，并发出“unexpected_message”警报。此消息在从
   client_early_traffic_secret派生的密钥下加密。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 


 
4.6.  Post-Handshake Messages
 
   TLS还允许在主握手之后发送其他消息。这些消息使用握手内容类型，并在适当的应用流
   密钥下加密。
 
4.6.1.  New Session Ticket Message
 
   At any time after the server has received the client Finished   message, it MAY send a NewSessionTicket message.  This message   creates a unique association between the ticket value and a secret   PSK derived from the resumption master secret (see Section 7).
 
   The client MAY use this PSK for future handshakes by including the   ticket value in the "pre_shared_key" extension in its ClientHello   (Section 4.2.11).  Servers MAY send multiple tickets on a single   connection, either immediately after each other or after specific   events (see Appendix C.4).  For instance, the server might send a new   ticket after post-handshake authentication in order to encapsulate   the additional client authentication state.  Multiple tickets are   useful for clients for a variety of purposes, including:
 
   -  Opening multiple parallel HTTP connections.
 
   -  Performing connection racing across interfaces and address      families via (for example) Happy Eyeballs [RFC8305] or related      techniques.
 
   Any ticket MUST only be resumed with a cipher suite that has the same   KDF hash algorithm as that used to establish the original connection.
 
   Clients MUST only resume if the new SNI value is valid for the server   certificate presented in the original session and SHOULD only resume   if the SNI value matches the one used in the original session.  The   latter is a performance optimization: normally, there is no reason to   expect that different servers covered by a single certificate would   be able to accept each other's tickets; hence, attempting resumption   in that case would waste a single-use ticket.  If such an indication   is provided (externally or by any other means), clients MAY resume   with a different SNI value.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   On resumption, if reporting an SNI value to the calling application,   implementations MUST use the value sent in the resumption ClientHello   rather than the value sent in the previous session.  Note that if a   server implementation declines all PSK identities with different SNI   values, these two values are always the same.
 
   Note: Although the resumption master secret depends on the client's   second flight, a server which does not request client authentication   MAY compute the remainder of the transcript independently and then   send a NewSessionTicket immediately upon sending its Finished rather   than waiting for the client Finished.  This might be appropriate in   cases where the client is expected to open multiple TLS connections   in parallel and would benefit from the reduced overhead of a   resumption handshake, for example.
 
      struct {
          uint32 ticket_lifetime;
          uint32 ticket_age_add;
          opaque ticket_nonce&lt;0..255&gt;;
          opaque ticket&lt;1..2^16-1&gt;;
          Extension extensions&lt;0..2^16-2&gt;;
      } NewSessionTicket;
 
   ticket_lifetime:  Indicates the lifetime in seconds as a 32-bit      unsigned integer in network byte order from the time of ticket      issuance.  Servers MUST NOT use any value greater than      604800 seconds (7 days).  The value of zero indicates that the      ticket should be discarded immediately.  Clients MUST NOT cache      tickets for longer than 7 days, regardless of the ticket_lifetime,      and MAY delete tickets earlier based on local policy.  A server      MAY treat a ticket as valid for a shorter period of time than what      is stated in the ticket_lifetime.
 
   ticket_age_add:  A securely generated, random 32-bit value that is      used to obscure the age of the ticket that the client includes in      the "pre_shared_key" extension.  The client-side ticket age is      added to this value modulo 2^32 to obtain the value that is      transmitted by the client.  The server MUST generate a fresh value      for each ticket it sends.
 
   ticket_nonce:  A per-ticket value that is unique across all tickets      issued on this connection.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   ticket:  The value of the ticket to be used as the PSK identity.  The      ticket itself is an opaque label.  It MAY be either a database      lookup key or a self-encrypted and self-authenticated value.
 
   extensions:  A set of extension values for the ticket.  The      "Extension" format is defined in Section 4.2.  Clients MUST ignore      unrecognized extensions.
 
   The sole extension currently defined for NewSessionTicket is   "early_data", indicating that the ticket may be used to send 0-RTT   data (Section 4.2.10).  It contains the following value:
 
   max_early_data_size:  The maximum amount of 0-RTT data that the      client is allowed to send when using this ticket, in bytes.  Only      Application Data payload (i.e., plaintext but not padding or the      inner content type byte) is counted.  A server receiving more than      max_early_data_size bytes of 0-RTT data SHOULD terminate the      connection with an "unexpected_message" alert.  Note that servers      that reject early data due to lack of cryptographic material will      be unable to differentiate padding from content, so clients      SHOULD NOT depend on being able to send large quantities of      padding in early data records.
 
   The PSK associated with the ticket is computed as:
 
       HKDF-Expand-Label(resumption_master_secret,
                        "resumption", ticket_nonce, Hash.length)
 
   Because the ticket_nonce value is distinct for each NewSessionTicket   message, a different PSK will be derived for each ticket.
 
   Note that in principle it is possible to continue issuing new tickets   which indefinitely extend the lifetime of the keying material   originally derived from an initial non-PSK handshake (which was most   likely tied to the peer's certificate).  It is RECOMMENDED that   implementations place limits on the total lifetime of such keying   material; these limits should take into account the lifetime of the   peer's certificate, the likelihood of intervening revocation, and the   time since the peer's online CertificateVerify signature.
 
4.6.2.  Post-Handshake Authentication
 
   When the client has sent the "post_handshake_auth" extension (see   Section 4.2.6), a server MAY request client authentication at any   time after the handshake has completed by sending a
   CertificateRequest message.  The client MUST respond with the   appropriate Authentication messages (see Section 4.4).  If the client   chooses to authenticate, it MUST send Certificate, CertificateVerify,</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   and Finished.  If it declines, it MUST send a Certificate message   containing no certificates followed by Finished.  All of the client's   messages for a given response MUST appear consecutively on the wire   with no intervening messages of other types.
 
   A client that receives a CertificateRequest message without having   sent the "post_handshake_auth" extension MUST send an   "unexpected_message" fatal alert.
 
   Note: Because client authentication could involve prompting the user,   servers MUST be prepared for some delay, including receiving an   arbitrary number of other messages between sending the   CertificateRequest and receiving a response.  In addition, clients   which receive multiple CertificateRequests in close succession MAY   respond to them in a different order than they were received (the   certificate_request_context value allows the server to disambiguate   the responses).
 
4.6.3.  Key and Initialization Vector Update
 
   The KeyUpdate handshake message is used to indicate that the sender   is updating its sending cryptographic keys.  This message can be sent   by either peer after it has sent a Finished message.  Implementations   that receive a KeyUpdate message prior to receiving a Finished   message MUST terminate the connection with an "unexpected_message"   alert.  After sending a KeyUpdate message, the sender SHALL send all   its traffic using the next generation of keys, computed as described   in Section 7.2.  Upon receiving a KeyUpdate, the receiver MUST update   its receiving keys.
 
      enum {
          update_not_requested(0), update_requested(1), (255)      } KeyUpdateRequest;
 
      struct {
          KeyUpdateRequest request_update;
      } KeyUpdate;
 
   request_update:  Indicates whether the recipient of the KeyUpdate      should respond with its own KeyUpdate.  If an implementation      receives any other value, it MUST terminate the connection with an      "illegal_parameter" alert.
 
   If the request_update field is set to "update_requested", then the   receiver MUST send a KeyUpdate of its own with request_update set to   "update_not_requested" prior to sending its next Application Data   record.  This mechanism allows either side to force an update to the   entire connection, but causes an implementation which receives</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   multiple KeyUpdates while it is silent to respond with a single   update.  Note that implementations may receive an arbitrary number of   messages between sending a KeyUpdate with request_update set to   "update_requested" and receiving the peer's KeyUpdate, because those   messages may already be in flight.  However, because send and receive   keys are derived from independent traffic secrets, retaining the   receive traffic secret does not threaten the forward secrecy of data   sent before the sender changed keys.
 
   If implementations independently send their own KeyUpdates with   request_update set to "update_requested" and they cross in flight,   then each side will also send a response, with the result that each   side increments by two generations.
 
   Both sender and receiver MUST encrypt their KeyUpdate messages with   the old keys.  Additionally, both sides MUST enforce that a KeyUpdate   with the old key is received before accepting any messages encrypted   with the new key.  Failure to do so may allow message truncation   attacks.
 
5.  Record Protocol
 
   The TLS record protocol takes messages to be transmitted, fragments   the data into manageable blocks, protects the records, and transmits   the result.  Received data is verified, decrypted, reassembled, and   then delivered to higher-level clients.
 
   TLS records are typed, which allows multiple higher-level protocols   to be multiplexed over the same record layer.  This document   specifies four content types: handshake, application_data, alert, and   change_cipher_spec.  The change_cipher_spec record is used only for   compatibility purposes (see Appendix D.4).
 
   An implementation may receive an unencrypted record of type   change_cipher_spec consisting of the single byte value 0x01 at any   time after the first ClientHello message has been sent or received   and before the peer's Finished message has been received and MUST   simply drop it without further processing.  Note that this record may   appear at a point at the handshake where the implementation is   expecting protected records, and so it is necessary to detect this   condition prior to attempting to deprotect the record.  An   implementation which receives any other change_cipher_spec value or   which receives a protected change_cipher_spec record MUST abort the   handshake with an "unexpected_message" alert.  If an implementation   detects a change_cipher_spec record received before the first   ClientHello message or after the peer's Finished message, it MUST be   treated as an unexpected record type (though stateless servers may   not be able to distinguish these cases from allowed cases).</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Implementations MUST NOT send record types not defined in this   document unless negotiated by some extension.  If a TLS   implementation receives an unexpected record type, it MUST terminate   the connection with an "unexpected_message" alert.  New record   content type values are assigned by IANA in the TLS ContentType   registry as described in Section 11.
 
5.1.  Record Layer
 
   The record layer fragments information blocks into TLSPlaintext   records carrying data in chunks of 2^14 bytes or less.  Message   boundaries are handled differently depending on the underlying   ContentType.  Any future content types MUST specify appropriate   rules.  Note that these rules are stricter than what was enforced in   TLS 1.2.
 
   Handshake messages MAY be coalesced into a single TLSPlaintext record   or fragmented across several records, provided that:
 
   -  Handshake messages MUST NOT be interleaved with other record      types.  That is, if a handshake message is split over two or more      records, there MUST NOT be any other records between them.
 
   -  Handshake messages MUST NOT span key changes.  Implementations      MUST verify that all messages immediately preceding a key change      align with a record boundary; if not, then they MUST terminate the      connection with an "unexpected_message" alert.  Because the      ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate      messages can immediately precede a key change, implementations      MUST send these messages in alignment with a record boundary.
 
   Implementations MUST NOT send zero-length fragments of Handshake   types, even if those fragments contain padding.
 
   Alert messages (Section 6) MUST NOT be fragmented across records, and   multiple alert messages MUST NOT be coalesced into a single   TLSPlaintext record.  In other words, a record with an Alert type   MUST contain exactly one message.
 
   Application Data messages contain data that is opaque to TLS.   Application Data messages are always protected.  Zero-length   fragments of Application Data MAY be sent, as they are potentially   useful as a traffic analysis countermeasure.  Application Data   fragments MAY be split across multiple records or coalesced into a   single record.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
      enum {
          invalid(0),
          change_cipher_spec(20),
          alert(21),
          handshake(22),
          application_data(23),
          (255)
      } ContentType;
 
      struct {
          ContentType type;
          ProtocolVersion legacy_record_version;
          uint16 length;
          opaque fragment[TLSPlaintext.length];
      } TLSPlaintext;
 
   type:  The higher-level protocol used to process the enclosed      fragment.
 
   legacy_record_version:  MUST be set to 0x0303 for all records      generated by a TLS 1.3 implementation other than an initial      ClientHello (i.e., one not generated after a HelloRetryRequest),      where it MAY also be 0x0301 for compatibility purposes.  This      field is deprecated and MUST be ignored for all purposes.      Previous versions of TLS would use other values in this field      under some circumstances.
 
   length:  The length (in bytes) of the following
      TLSPlaintext.fragment.  The length MUST NOT exceed 2^14 bytes.  An      endpoint that receives a record that exceeds this length MUST      terminate the connection with a "record_overflow" alert.
 
   fragment:  The data being transmitted.  This value is transparent and      is treated as an independent block to be dealt with by the higher-      level protocol specified by the type field.
 
   This document describes TLS 1.3, which uses the version 0x0304.  This   version value is historical, deriving from the use of 0x0301 for   TLS 1.0 and 0x0300 for SSL 3.0.  In order to maximize backward   compatibility, a record containing an initial ClientHello SHOULD have   version 0x0301 (reflecting TLS 1.0) and a record containing a second   ClientHello or a ServerHello MUST have version 0x0303 (reflecting   TLS 1.2).  When negotiating prior versions of TLS, endpoints follow   the procedure and requirements provided in Appendix D.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   When record protection has not yet been engaged, TLSPlaintext   structures are written directly onto the wire.  Once record   protection has started, TLSPlaintext records are protected and sent   as described in the following section.  Note that Application Data   records MUST NOT be written to the wire unprotected (see Section 2   for details).
 
5.2.  Record Payload Protection
 
   The record protection functions translate a TLSPlaintext structure   into a TLSCiphertext structure.  The deprotection functions reverse   the process.  In TLS 1.3, as opposed to previous versions of TLS, all   ciphers are modeled as "Authenticated Encryption with Associated   Data" (AEAD) [RFC5116].  AEAD functions provide a unified encryption   and authentication operation which turns plaintext into authenticated   ciphertext and back again.  Each encrypted record consists of a   plaintext header followed by an encrypted body, which itself contains   a type and optional padding.
 
      struct {
          opaque content[TLSPlaintext.length];
          ContentType type;
          uint8 zeros[length_of_padding];
      } TLSInnerPlaintext;
 
      struct {
          ContentType opaque_type = application_data; /* 23 */          ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */          uint16 length;
          opaque encrypted_record[TLSCiphertext.length];      } TLSCiphertext;
 
   content:  The TLSPlaintext.fragment value, containing the byte      encoding of a handshake or an alert message, or the raw bytes of      the application's data to send.
 
   type:  The TLSPlaintext.type value containing the content type of the      record.
 
   zeros:  An arbitrary-length run of zero-valued bytes may appear in      the cleartext after the type field.  This provides an opportunity      for senders to pad any TLS record by a chosen amount as long as      the total stays within record size limits.  See Section 5.4 for      more details.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   opaque_type:  The outer opaque_type field of a TLSCiphertext record      is always set to the value 23 (application_data) for outward      compatibility with middleboxes accustomed to parsing previous      versions of TLS.  The actual content type of the record is found      in TLSInnerPlaintext.type after decryption.
 
   legacy_record_version:  The legacy_record_version field is always      0x0303.  TLS 1.3 TLSCiphertexts are not generated until after      TLS 1.3 has been negotiated, so there are no historical      compatibility concerns where other values might be received.  Note      that the handshake protocol, including the ClientHello and      ServerHello messages, authenticates the protocol version, so this      value is redundant.
 
   length:  The length (in bytes) of the following
      TLSCiphertext.encrypted_record, which is the sum of the lengths of      the content and the padding, plus one for the inner content type,      plus any expansion added by the AEAD algorithm.  The length      MUST NOT exceed 2^14 + 256 bytes.  An endpoint that receives a      record that exceeds this length MUST terminate the connection with      a "record_overflow" alert.
 
   encrypted_record:  The AEAD-encrypted form of the serialized      TLSInnerPlaintext structure.
 
   AEAD algorithms take as input a single key, a nonce, a plaintext, and   "additional data" to be included in the authentication check, as   described in Section&nbsp;2.1 of [RFC5116].  The key is either the   client_write_key or the server_write_key, the nonce is derived from   the sequence number and the client_write_iv or server_write_iv (see   Section 5.3), and the additional data input is the record header.
 
   I.e.,
 
      additional_data = TLSCiphertext.opaque_type ||
                        TLSCiphertext.legacy_record_version ||
                        TLSCiphertext.length
 
   The plaintext input to the AEAD algorithm is the encoded   TLSInnerPlaintext structure.  Derivation of traffic keys is defined   in Section 7.3.
 
   The AEAD output consists of the ciphertext output from the AEAD   encryption operation.  The length of the plaintext is greater than   the corresponding TLSPlaintext.length due to the inclusion of   TLSInnerPlaintext.type and any padding supplied by the sender.  The   length of the AEAD output will generally be larger than the   plaintext, but by an amount that varies with the AEAD algorithm.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Since the ciphers might incorporate padding, the amount of overhead   could vary with different lengths of plaintext.  Symbolically,
 
      AEADEncrypted =
          AEAD-Encrypt(write_key, nonce, additional_data, plaintext)
 
   The encrypted_record field of TLSCiphertext is set to AEADEncrypted.
 
   In order to decrypt and verify, the cipher takes as input the key,   nonce, additional data, and the AEADEncrypted value.  The output is   either the plaintext or an error indicating that the decryption   failed.  There is no separate integrity check.  Symbolically,
 
      plaintext of encrypted_record =
          AEAD-Decrypt(peer_write_key, nonce,
                       additional_data, AEADEncrypted)
 
   If the decryption fails, the receiver MUST terminate the connection   with a "bad_record_mac" alert.
 
   An AEAD algorithm used in TLS 1.3 MUST NOT produce an expansion   greater than 255 octets.  An endpoint that receives a record from its   peer with TLSCiphertext.length larger than 2^14 + 256 octets MUST   terminate the connection with a "record_overflow" alert.  This limit   is derived from the maximum TLSInnerPlaintext length of 2^14 octets +   1 octet for ContentType + the maximum AEAD expansion of 255 octets.
 
5.3.  Per-Record Nonce
 
   A 64-bit sequence number is maintained separately for reading and   writing records.  The appropriate sequence number is incremented by   one after reading or writing each record.  Each sequence number is   set to zero at the beginning of a connection and whenever the key is   changed; the first record transmitted under a particular traffic key   MUST use sequence number 0.
 
   Because the size of sequence numbers is 64-bit, they should not wrap.   If a TLS implementation would need to wrap a sequence number, it MUST   either rekey (Section 4.6.3) or terminate the connection.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Each AEAD algorithm will specify a range of possible lengths for the   per-record nonce, from N_MIN bytes to N_MAX bytes of input [RFC5116].   The length of the TLS per-record nonce (iv_length) is set to the   larger of 8 bytes and N_MIN for the AEAD algorithm (see [RFC5116],   Section&nbsp;4).  An AEAD algorithm where N_MAX is less than 8 bytes   MUST NOT be used with TLS.  The per-record nonce for the AEAD   construction is formed as follows:
 
   1.  The 64-bit record sequence number is encoded in network byte       order and padded to the left with zeros to iv_length.
 
   2.  The padded sequence number is XORed with either the static       client_write_iv or server_write_iv (depending on the role).
 
   The resulting quantity (of length iv_length) is used as the   per-record nonce.
 
   Note: This is a different construction from that in TLS 1.2, which   specified a partially explicit nonce.
 
5.4.  Record Padding
 
   All encrypted TLS records can be padded to inflate the size of the   TLSCiphertext.  This allows the sender to hide the size of the   traffic from an observer.
 
   When generating a TLSCiphertext record, implementations MAY choose to   pad.  An unpadded record is just a record with a padding length of   zero.  Padding is a string of zero-valued bytes appended to the   ContentType field before encryption.  Implementations MUST set the   padding octets to all zeros before encrypting.
 
   Application Data records may contain a zero-length
   TLSInnerPlaintext.content if the sender desires.  This permits   generation of plausibly sized cover traffic in contexts where the   presence or absence of activity may be sensitive.  Implementations   MUST NOT send Handshake and Alert records that have a zero-length   TLSInnerPlaintext.content; if such a message is received, the   receiving implementation MUST terminate the connection with an   "unexpected_message" alert.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   The padding sent is automatically verified by the record protection   mechanism; upon successful decryption of a
   TLSCiphertext.encrypted_record, the receiving implementation scans   the field from the end toward the beginning until it finds a non-zero   octet.  This non-zero octet is the content type of the message.  This   padding scheme was selected because it allows padding of any   encrypted TLS record by an arbitrary size (from zero up to TLS record   size limits) without introducing new content types.  The design also   enforces all-zero padding octets, which allows for quick detection of   padding errors.
 
   Implementations MUST limit their scanning to the cleartext returned   from the AEAD decryption.  If a receiving implementation does not   find a non-zero octet in the cleartext, it MUST terminate the   connection with an "unexpected_message" alert.
 
   The presence of padding does not change the overall record size   limitations: the full encoded TLSInnerPlaintext MUST NOT exceed 2^14   + 1 octets.  If the maximum fragment length is reduced -- as, for   example, by the record_size_limit extension from [RFC8449] -- then   the reduced limit applies to the full plaintext, including the   content type and padding.
 
   Selecting a padding policy that suggests when and how much to pad is   a complex topic and is beyond the scope of this specification.  If   the application-layer protocol on top of TLS has its own padding, it   may be preferable to pad Application Data TLS records within the   application layer.  Padding for encrypted Handshake or Alert records   must still be handled at the TLS layer, though.  Later documents may   define padding selection algorithms or define a padding policy   request mechanism through TLS extensions or some other means.
 
5.5.  Limits on Key Usage
 
   There are cryptographic limits on the amount of plaintext which can   be safely encrypted under a given set of keys.  [AEAD-LIMITS]   provides an analysis of these limits under the assumption that the   underlying primitive (AES or ChaCha20) has no weaknesses.   Implementations SHOULD do a key update as described in Section 4.6.3   prior to reaching these limits.
 
   For AES-GCM, up to 2^24.5 full-size records (about 24 million) may be   encrypted on a given connection while keeping a safety margin of   approximately 2^-57 for Authenticated Encryption (AE) security.  For   ChaCha20/Poly1305, the record sequence number would wrap before the   safety limit is reached.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
6.  Alert Protocol
 
   TLS provides an Alert content type to indicate closure information   and errors.  Like other messages, alert messages are encrypted as   specified by the current connection state.
 
   Alert messages convey a description of the alert and a legacy field   that conveyed the severity level of the message in previous versions   of TLS.  Alerts are divided into two classes: closure alerts and   error alerts.  In TLS 1.3, the severity is implicit in the type of   alert being sent, and the "level" field can safely be ignored.  The   "close_notify" alert is used to indicate orderly closure of one   direction of the connection.  Upon receiving such an alert, the TLS   implementation SHOULD indicate end-of-data to the application.
 
   Error alerts indicate abortive closure of the connection (see   Section 6.2).  Upon receiving an error alert, the TLS implementation   SHOULD indicate an error to the application and MUST NOT allow any   further data to be sent or received on the connection.  Servers and   clients MUST forget the secret values and keys established in failed   connections, with the exception of the PSKs associated with session   tickets, which SHOULD be discarded if possible.
 
   All the alerts listed in Section 6.2 MUST be sent with
   AlertLevel=fatal and MUST be treated as error alerts when received   regardless of the AlertLevel in the message.  Unknown Alert types   MUST be treated as error alerts.
 
   Note: TLS defines two generic alerts (see Section 6) to use upon   failure to parse a message.  Peers which receive a message which   cannot be parsed according to the syntax (e.g., have a length   extending beyond the message boundary or contain an out-of-range   length) MUST terminate the connection with a "decode_error" alert.   Peers which receive a message which is syntactically correct but   semantically invalid (e.g., a DHE share of p - 1, or an invalid enum)   MUST terminate the connection with an "illegal_parameter" alert.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
      enum { warning(1), fatal(2), (255) } AlertLevel;
 
      enum {
          close_notify(0),
          unexpected_message(10),
          bad_record_mac(20),
          record_overflow(22),
          handshake_failure(40),
          bad_certificate(42),
          unsupported_certificate(43),
          certificate_revoked(44),
          certificate_expired(45),
          certificate_unknown(46),
          illegal_parameter(47),
          unknown_ca(48),
          access_denied(49),
          decode_error(50),
          decrypt_error(51),
          protocol_version(70),
          insufficient_security(71),
          internal_error(80),
          inappropriate_fallback(86),
          user_canceled(90),
          missing_extension(109),
          unsupported_extension(110),
          unrecognized_name(112),
          bad_certificate_status_response(113),
          unknown_psk_identity(115),
          certificate_required(116),
          no_application_protocol(120),
          (255)
      } AlertDescription;
 
      struct {
          AlertLevel level;
          AlertDescription description;
      } Alert;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
6.1.  Closure Alerts
 
   The client and the server must share knowledge that the connection is   ending in order to avoid a truncation attack.
 
   close_notify:  This alert notifies the recipient that the sender will      not send any more messages on this connection.  Any data received      after a closure alert has been received MUST be ignored.
 
   user_canceled:  This alert notifies the recipient that the sender is      canceling the handshake for some reason unrelated to a protocol      failure.  If a user cancels an operation after the handshake is      complete, just closing the connection by sending a "close_notify"      is more appropriate.  This alert SHOULD be followed by a      "close_notify".  This alert generally has AlertLevel=warning.
 
   Either party MAY initiate a close of its write side of the connection   by sending a "close_notify" alert.  Any data received after a closure   alert has been received MUST be ignored.  If a transport-level close   is received prior to a "close_notify", the receiver cannot know that   all the data that was sent has been received.
 
   Each party MUST send a "close_notify" alert before closing its write   side of the connection, unless it has already sent some error alert.   This does not have any effect on its read side of the connection.   Note that this is a change from versions of TLS prior to TLS 1.3 in   which implementations were required to react to a "close_notify" by   discarding pending writes and sending an immediate "close_notify"   alert of their own.  That previous requirement could cause truncation   in the read side.  Both parties need not wait to receive a   "close_notify" alert before closing their read side of the   connection, though doing so would introduce the possibility of   truncation.
 
   If the application protocol using TLS provides that any data may be   carried over the underlying transport after the TLS connection is   closed, the TLS implementation MUST receive a "close_notify" alert   before indicating end-of-data to the application layer.  No part of   this standard should be taken to dictate the manner in which a usage   profile for TLS manages its data transport, including when   connections are opened or closed.
 
   Note: It is assumed that closing the write side of a connection   reliably delivers pending data before destroying the transport.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
6.2.  Error Alerts
 
   Error handling in TLS is very simple.  When an error is detected, the   detecting party sends a message to its peer.  Upon transmission or   receipt of a fatal alert message, both parties MUST immediately close   the connection.
 
   Whenever an implementation encounters a fatal error condition, it   SHOULD send an appropriate fatal alert and MUST close the connection   without sending or receiving any additional data.  In the rest of   this specification, when the phrases "terminate the connection" and   "abort the handshake" are used without a specific alert it means that   the implementation SHOULD send the alert indicated by the   descriptions below.  The phrases "terminate the connection with an X   alert" and "abort the handshake with an X alert" mean that the   implementation MUST send alert X if it sends any alert.  All alerts   defined below in this section, as well as all unknown alerts, are   universally considered fatal as of TLS 1.3 (see Section 6).  The   implementation SHOULD provide a way to facilitate logging the sending   and receiving of alerts.
 
   The following error alerts are defined:
 
   unexpected_message:  An inappropriate message (e.g., the wrong      handshake message, premature Application Data, etc.) was received.      This alert should never be observed in communication between      proper implementations.
 
   bad_record_mac:  This alert is returned if a record is received which      cannot be deprotected.  Because AEAD algorithms combine decryption      and verification, and also to avoid side-channel attacks, this      alert is used for all deprotection failures.  This alert should      never be observed in communication between proper implementations,      except when messages were corrupted in the network.
 
   record_overflow:  A TLSCiphertext record was received that had a      length more than 2^14 + 256 bytes, or a record decrypted to a      TLSPlaintext record with more than 2^14 bytes (or some other      negotiated limit).  This alert should never be observed in      communication between proper implementations, except when messages      were corrupted in the network.
 
   handshake_failure:  Receipt of a "handshake_failure" alert message      indicates that the sender was unable to negotiate an acceptable      set of security parameters given the options available.
 
   bad_certificate:  A certificate was corrupt, contained signatures      that did not verify correctly, etc.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   unsupported_certificate:  A certificate was of an unsupported type.
 
   certificate_revoked:  A certificate was revoked by its signer.
 
   certificate_expired:  A certificate has expired or is not currently      valid.
 
   certificate_unknown:  Some other (unspecified) issue arose in      processing the certificate, rendering it unacceptable.
 
   illegal_parameter:  A field in the handshake was incorrect or      inconsistent with other fields.  This alert is used for errors      which conform to the formal protocol syntax but are otherwise      incorrect.
 
   unknown_ca:  A valid certificate chain or partial chain was received,      but the certificate was not accepted because the CA certificate      could not be located or could not be matched with a known trust      anchor.
 
   access_denied:  A valid certificate or PSK was received, but when      access control was applied, the sender decided not to proceed with      negotiation.
 
   decode_error:  A message could not be decoded because some field was      out of the specified range or the length of the message was      incorrect.  This alert is used for errors where the message does      not conform to the formal protocol syntax.  This alert should      never be observed in communication between proper implementations,      except when messages were corrupted in the network.
 
   decrypt_error:  A handshake (not record layer) cryptographic      operation failed, including being unable to correctly verify a      signature or validate a Finished message or a PSK binder.
 
   protocol_version:  The protocol version the peer has attempted to      negotiate is recognized but not supported (see Appendix D).
 
   insufficient_security:  Returned instead of "handshake_failure" when      a negotiation has failed specifically because the server requires      parameters more secure than those supported by the client.
 
   internal_error:  An internal error unrelated to the peer or the      correctness of the protocol (such as a memory allocation failure)      makes it impossible to continue.
 
   inappropriate_fallback:  Sent by a server in response to an invalid      connection retry attempt from a client (see [RFC7507]).</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   missing_extension:  Sent by endpoints that receive a handshake      message not containing an extension that is mandatory to send for      the offered TLS version or other negotiated parameters.
 
   unsupported_extension:  Sent by endpoints receiving any handshake      message containing an extension known to be prohibited for      inclusion in the given handshake message, or including any      extensions in a ServerHello or Certificate not first offered in      the corresponding ClientHello or CertificateRequest.
 
   unrecognized_name:  Sent by servers when no server exists identified      by the name provided by the client via the "server_name" extension      (see [RFC6066]).
 
   bad_certificate_status_response:  Sent by clients when an invalid or      unacceptable OCSP response is provided by the server via the      "status_request" extension (see [RFC6066]).
 
   unknown_psk_identity:  Sent by servers when PSK key establishment is      desired but no acceptable PSK identity is provided by the client.      Sending this alert is OPTIONAL; servers MAY instead choose to send      a "decrypt_error" alert to merely indicate an invalid PSK      identity.
 
   certificate_required:  Sent by servers when a client certificate is      desired but none was provided by the client.
 
   no_application_protocol:  Sent by servers when a client      "application_layer_protocol_negotiation" extension advertises only      protocols that the server does not support (see [RFC7301]).
 
   New Alert values are assigned by IANA as described in Section 11.
 
7.  Cryptographic Computations
 
   The TLS handshake establishes one or more input secrets which are   combined to create the actual working keying material, as detailed   below.  The key derivation process incorporates both the input   secrets and the handshake transcript.  Note that because the   handshake transcript includes the random values from the Hello   messages, any given handshake will have different traffic secrets,   even if the same input secrets are used, as is the case when the same   PSK is used for multiple connections.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
7.1.  Key Schedule
 
   The key derivation process makes use of the HKDF-Extract and   HKDF-Expand functions as defined for HKDF [RFC5869], as well as the   functions defined below:
 
       HKDF-Expand-Label(Secret, Label, Context, Length) =            HKDF-Expand(Secret, HkdfLabel, Length)
 
       Where HkdfLabel is specified as:
 
       struct {
           uint16 length = Length;
           opaque label&lt;7..255&gt; = "tls13 " + Label;
           opaque context&lt;0..255&gt; = Context;
       } HkdfLabel;
 
       Derive-Secret(Secret, Label, Messages) =
            HKDF-Expand-Label(Secret, Label,
                              Transcript-Hash(Messages), Hash.length)
 
   The Hash function used by Transcript-Hash and HKDF is the cipher   suite hash algorithm.  Hash.length is its output length in bytes.   Messages is the concatenation of the indicated handshake messages,   including the handshake message type and length fields, but not   including record layer headers.  Note that in some cases a zero-   length Context (indicated by "") is passed to HKDF-Expand-Label.  The   labels specified in this document are all ASCII strings and do not   include a trailing NUL byte.
 
   Note: With common hash functions, any label longer than 12 characters   requires an additional iteration of the hash function to compute.   The labels in this specification have all been chosen to fit within   this limit.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Keys are derived from two input secrets using the HKDF-Extract and   Derive-Secret functions.  The general pattern for adding a new secret   is to use HKDF-Extract with the Salt being the current secret state   and the Input Keying Material (IKM) being the new secret to be added.   In this version of TLS 1.3, the two input secrets are:
 
   -  PSK (a pre-shared key established externally or derived from the      resumption_master_secret value from a previous connection)
 
   -  (EC)DHE shared secret (Section 7.4)
 
   This produces a full key derivation schedule shown in the diagram   below.  In this diagram, the following formatting conventions apply:
 
   -  HKDF-Extract is drawn as taking the Salt argument from the top and      the IKM argument from the left, with its output to the bottom and      the name of the output on the right.
 
   -  Derive-Secret's Secret argument is indicated by the incoming      arrow.  For instance, the Early Secret is the Secret for      generating the client_early_traffic_secret.
 
   -  "0" indicates a string of Hash.length bytes set to zero.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
             0
             |
             v
   PSK -&gt;  HKDF-Extract = Early Secret
             |
             +-----&gt; Derive-Secret(., "ext binder" | "res binder", "")             |                     = binder_key
             |
             +-----&gt; Derive-Secret(., "c e traffic", ClientHello)             |                     = client_early_traffic_secret
             |
             +-----&gt; Derive-Secret(., "e exp master", ClientHello)             |                     = early_exporter_master_secret
             v
       Derive-Secret(., "derived", "")
             |
             v
   (EC)DHE -&gt; HKDF-Extract = Handshake Secret
             |
             +-----&gt; Derive-Secret(., "c hs traffic",
             |                     ClientHello...ServerHello)
             |                     = client_handshake_traffic_secret
             |
             +-----&gt; Derive-Secret(., "s hs traffic",
             |                     ClientHello...ServerHello)
             |                     = server_handshake_traffic_secret
             v
       Derive-Secret(., "derived", "")
             |
             v
   0 -&gt; HKDF-Extract = Master Secret
             |
             +-----&gt; Derive-Secret(., "c ap traffic",
             |                     ClientHello...server Finished)
             |                     = client_application_traffic_secret_0
             |
             +-----&gt; Derive-Secret(., "s ap traffic",
             |                     ClientHello...server Finished)
             |                     = server_application_traffic_secret_0
             |
             +-----&gt; Derive-Secret(., "exp master",
             |                     ClientHello...server Finished)
             |                     = exporter_master_secret
             |
             +-----&gt; Derive-Secret(., "res master",
                                   ClientHello...client Finished)
                                   = resumption_master_secret</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   The general pattern here is that the secrets shown down the left side   of the diagram are just raw entropy without context, whereas the   secrets down the right side include Handshake Context and therefore   can be used to derive working keys without additional context.  Note   that the different calls to Derive-Secret may take different Messages   arguments, even with the same secret.  In a 0-RTT exchange,   Derive-Secret is called with four distinct transcripts; in a   1-RTT-only exchange, it is called with three distinct transcripts.
 
   If a given secret is not available, then the 0-value consisting of a   string of Hash.length bytes set to zeros is used.  Note that this   does not mean skipping rounds, so if PSK is not in use, Early Secret   will still be HKDF-Extract(0, 0).  For the computation of the   binder_key, the label is "ext binder" for external PSKs (those   provisioned outside of TLS) and "res binder" for resumption PSKs   (those provisioned as the resumption master secret of a previous   handshake).  The different labels prevent the substitution of one   type of PSK for the other.
 
   There are multiple potential Early Secret values, depending on which   PSK the server ultimately selects.  The client will need to compute   one for each potential PSK; if no PSK is selected, it will then need   to compute the Early Secret corresponding to the zero PSK.
 
   Once all the values which are to be derived from a given secret have   been computed, that secret SHOULD be erased.
 
7.2.  Updating Traffic Secrets
 
   Once the handshake is complete, it is possible for either side to   update its sending traffic keys using the KeyUpdate handshake message   defined in Section 4.6.3.  The next generation of traffic keys is   computed by generating client_/server_application_traffic_secret_N+1   from client_/server_application_traffic_secret_N as described in this   section and then re-deriving the traffic keys as described in   Section 7.3.
 
   The next-generation application_traffic_secret is computed as:
 
       application_traffic_secret_N+1 =
           HKDF-Expand-Label(application_traffic_secret_N,                             "traffic upd", "", Hash.length)
 
   Once client_/server_application_traffic_secret_N+1 and its associated   traffic keys have been computed, implementations SHOULD delete   client_/server_application_traffic_secret_N and its associated   traffic keys.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
7.3.  Traffic Key Calculation
 
   The traffic keying material is generated from the following input   values:
 
   -  A secret value
 
   -  A purpose value indicating the specific value being generated
 
   -  The length of the key being generated
 
   The traffic keying material is generated from an input traffic secret   value using:
 
   [sender]_write_key = HKDF-Expand-Label(Secret, "key", "", key_length)   [sender]_write_iv  = HKDF-Expand-Label(Secret, "iv", "", iv_length)
 
   [sender] denotes the sending side.  The value of Secret for each   record type is shown in the table below.
 
       +-------------------+---------------------------------------+
       | Record Type       | Secret                                |
       +-------------------+---------------------------------------+
       | 0-RTT Application | client_early_traffic_secret           |
       |                   |                                       |
       | Handshake         | [sender]_handshake_traffic_secret     |
       |                   |                                       |
       | Application Data  | [sender]_application_traffic_secret_N |
       +-------------------+---------------------------------------+
 
   All the traffic keying material is recomputed whenever the underlying   Secret changes (e.g., when changing from the handshake to Application   Data keys or upon a key update).
 
7.4.  (EC)DHE Shared Secret Calculation
 
7.4.1.  Finite Field Diffie-Hellman
 
   For finite field groups, a conventional Diffie-Hellman [DH76]   computation is performed.  The negotiated key (Z) is converted to a   byte string by encoding in big-endian form and left-padded with zeros   up to the size of the prime.  This byte string is used as the shared   secret in the key schedule as specified above.
 
   Note that this construction differs from previous versions of TLS   which removed leading zeros.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
7.4.2.  Elliptic Curve Diffie-Hellman
 
   For secp256r1, secp384r1, and secp521r1, ECDH calculations (including   parameter and key generation as well as the shared secret   calculation) are performed according to [IEEE1363] using the   ECKAS-DH1 scheme with the identity map as the key derivation function   (KDF), so that the shared secret is the x-coordinate of the ECDH   shared secret elliptic curve point represented as an octet string.   Note that this octet string ("Z" in IEEE 1363 terminology) as output   by FE2OSP (the Field Element to Octet String Conversion Primitive)   has constant length for any given field; leading zeros found in this   octet string MUST NOT be truncated.
 
   (Note that this use of the identity KDF is a technicality.  The   complete picture is that ECDH is employed with a non-trivial KDF   because TLS does not directly use this secret for anything other than   for computing other secrets.)
 
   For X25519 and X448, the ECDH calculations are as follows:
 
   -  The public key to put into the KeyShareEntry.key_exchange      structure is the result of applying the ECDH scalar multiplication      function to the secret key of appropriate length (into scalar      input) and the standard public basepoint (into u-coordinate point      input).
 
   -  The ECDH shared secret is the result of applying the ECDH scalar      multiplication function to the secret key (into scalar input) and      the peer's public key (into u-coordinate point input).  The output      is used raw, with no processing.
 
   For these curves, implementations SHOULD use the approach specified   in [RFC7748] to calculate the Diffie-Hellman shared secret.   Implementations MUST check whether the computed Diffie-Hellman shared   secret is the all-zero value and abort if so, as described in   Section&nbsp;6 of [RFC7748].  If implementors use an alternative   implementation of these elliptic curves, they SHOULD perform the   additional checks specified in Section&nbsp;7 of [RFC7748].</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
7.5.  Exporters
 
   [RFC5705] defines keying material exporters for TLS in terms of the   TLS pseudorandom function (PRF).  This document replaces the PRF with   HKDF, thus requiring a new construction.  The exporter interface   remains the same.
 
   The exporter value is computed as:
 
   TLS-Exporter(label, context_value, key_length) =       HKDF-Expand-Label(Derive-Secret(Secret, label, ""),                         "exporter", Hash(context_value), key_length)
 
   Where Secret is either the early_exporter_master_secret or the   exporter_master_secret.  Implementations MUST use the   exporter_master_secret unless explicitly specified by the   application.  The early_exporter_master_secret is defined for use in   settings where an exporter is needed for 0-RTT data.  A separate   interface for the early exporter is RECOMMENDED; this avoids the   exporter user accidentally using an early exporter when a regular one   is desired or vice versa.
 
   If no context is provided, the context_value is zero length.   Consequently, providing no context computes the same value as   providing an empty context.  This is a change from previous versions   of TLS where an empty context produced a different output than an   absent context.  As of this document's publication, no allocated   exporter label is used both with and without a context.  Future   specifications MUST NOT define a use of exporters that permit both an   empty context and no context with the same label.  New uses of   exporters SHOULD provide a context in all exporter computations,   though the value could be empty.
 
   Requirements for the format of exporter labels are defined in   Section&nbsp;4 of [RFC5705].</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
8.  0-RTT and Anti-Replay
 
   As noted in Section 2.3 and Appendix E.5, TLS does not provide   inherent replay protections for 0-RTT data.  There are two potential   threats to be concerned with:
 
   -  Network attackers who mount a replay attack by simply duplicating      a flight of 0-RTT data.
 
   -  Network attackers who take advantage of client retry behavior to      arrange for the server to receive multiple copies of an      application message.  This threat already exists to some extent      because clients that value robustness respond to network errors by      attempting to retry requests.  However, 0-RTT adds an additional      dimension for any server system which does not maintain globally      consistent server state.  Specifically, if a server system has      multiple zones where tickets from zone A will not be accepted in      zone B, then an attacker can duplicate a ClientHello and early      data intended for A to both A and B.  At A, the data will be      accepted in 0-RTT, but at B the server will reject 0-RTT data and      instead force a full handshake.  If the attacker blocks the      ServerHello from A, then the client will complete the handshake      with B and probably retry the request, leading to duplication on      the server system as a whole.
 
   The first class of attack can be prevented by sharing state to   guarantee that the 0-RTT data is accepted at most once.  Servers   SHOULD provide that level of replay safety by implementing one of the   methods described in this section or by equivalent means.  It is   understood, however, that due to operational concerns not all   deployments will maintain state at that level.  Therefore, in normal   operation, clients will not know which, if any, of these mechanisms   servers actually implement and hence MUST only send early data which   they deem safe to be replayed.
 
   In addition to the direct effects of replays, there is a class of   attacks where even operations normally considered idempotent could be   exploited by a large number of replays (timing attacks, resource   limit exhaustion and others, as described in Appendix E.5).  Those   can be mitigated by ensuring that every 0-RTT payload can be replayed   only a limited number of times.  The server MUST ensure that any   instance of it (be it a machine, a thread, or any other entity within   the relevant serving infrastructure) would accept 0-RTT for the same   0-RTT handshake at most once; this limits the number of replays to   the number of server instances in the deployment.  Such a guarantee   can be accomplished by locally recording data from recently received   ClientHellos and rejecting repeats, or by any other method that</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   provides the same or a stronger guarantee.  The "at most once per   server instance" guarantee is a minimum requirement; servers SHOULD   limit 0-RTT replays further when feasible.
 
   The second class of attack cannot be prevented at the TLS layer and   MUST be dealt with by any application.  Note that any application   whose clients implement any kind of retry behavior already needs to   implement some sort of anti-replay defense.
 
8.1.  Single-Use Tickets
 
   The simplest form of anti-replay defense is for the server to only   allow each session ticket to be used once.  For instance, the server   can maintain a database of all outstanding valid tickets, deleting   each ticket from the database as it is used.  If an unknown ticket is   provided, the server would then fall back to a full handshake.
 
   If the tickets are not self-contained but rather are database keys,   and the corresponding PSKs are deleted upon use, then connections   established using PSKs enjoy forward secrecy.  This improves security   for all 0-RTT data and PSK usage when PSK is used without (EC)DHE.
 
   Because this mechanism requires sharing the session database between   server nodes in environments with multiple distributed servers, it   may be hard to achieve high rates of successful PSK 0-RTT connections   when compared to self-encrypted tickets.  Unlike session databases,   session tickets can successfully do PSK-based session establishment   even without consistent storage, though when 0-RTT is allowed they   still require consistent storage for anti-replay of 0-RTT data, as   detailed in the following section.
 
8.2.  Client Hello Recording
 
   An alternative form of anti-replay is to record a unique value   derived from the ClientHello (generally either the random value or   the PSK binder) and reject duplicates.  Recording all ClientHellos   causes state to grow without bound, but a server can instead record   ClientHellos within a given time window and use the
   "obfuscated_ticket_age" to ensure that tickets aren't reused outside   that window.
 
   In order to implement this, when a ClientHello is received, the   server first verifies the PSK binder as described in Section 4.2.11.   It then computes the expected_arrival_time as described in the next   section and rejects 0-RTT if it is outside the recording window,   falling back to the 1-RTT handshake.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   If the expected_arrival_time is in the window, then the server checks   to see if it has recorded a matching ClientHello.  If one is found,   it either aborts the handshake with an "illegal_parameter" alert or   accepts the PSK but rejects 0-RTT.  If no matching ClientHello is   found, then it accepts 0-RTT and then stores the ClientHello for as   long as the expected_arrival_time is inside the window.  Servers MAY   also implement data stores with false positives, such as Bloom   filters, in which case they MUST respond to apparent replay by   rejecting 0-RTT but MUST NOT abort the handshake.
 
   The server MUST derive the storage key only from validated sections   of the ClientHello.  If the ClientHello contains multiple PSK   identities, then an attacker can create multiple ClientHellos with   different binder values for the less-preferred identity on the   assumption that the server will not verify it (as recommended by   Section 4.2.11).  I.e., if the client sends PSKs A and B but the   server prefers A, then the attacker can change the binder for B   without affecting the binder for A.  If the binder for B is part of   the storage key, then this ClientHello will not appear as a   duplicate, which will cause the ClientHello to be accepted, and may   cause side effects such as replay cache pollution, although any 0-RTT   data will not be decryptable because it will use different keys.  If   the validated binder or the ClientHello.random is used as the storage   key, then this attack is not possible.
 
   Because this mechanism does not require storing all outstanding   tickets, it may be easier to implement in distributed systems with   high rates of resumption and 0-RTT, at the cost of potentially weaker   anti-replay defense because of the difficulty of reliably storing and   retrieving the received ClientHello messages.  In many such systems,   it is impractical to have globally consistent storage of all the   received ClientHellos.  In this case, the best anti-replay protection   is provided by having a single storage zone be authoritative for a   given ticket and refusing 0-RTT for that ticket in any other zone.   This approach prevents simple replay by the attacker because only one   zone will accept 0-RTT data.  A weaker design is to implement   separate storage for each zone but allow 0-RTT in any zone.  This   approach limits the number of replays to once per zone.  Application   message duplication of course remains possible with either design.
 
   When implementations are freshly started, they SHOULD reject 0-RTT as   long as any portion of their recording window overlaps the startup   time.  Otherwise, they run the risk of accepting replays which were   originally sent during that period.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Note: If the client's clock is running much faster than the server's,   then a ClientHello may be received that is outside the window in the   future, in which case it might be accepted for 1-RTT, causing a   client retry, and then acceptable later for 0-RTT.  This is another   variant of the second form of attack described in Section 8.
 
8.3.  Freshness Checks
 
   Because the ClientHello indicates the time at which the client sent   it, it is possible to efficiently determine whether a ClientHello was   likely sent reasonably recently and only accept 0-RTT for such a   ClientHello, otherwise falling back to a 1-RTT handshake.  This is   necessary for the ClientHello storage mechanism described in   Section 8.2 because otherwise the server needs to store an unlimited   number of ClientHellos, and is a useful optimization for self-   contained single-use tickets because it allows efficient rejection of   ClientHellos which cannot be used for 0-RTT.
 
   In order to implement this mechanism, a server needs to store the   time that the server generated the session ticket, offset by an   estimate of the round-trip time between client and server.  I.e.,
 
       adjusted_creation_time = creation_time + estimated_RTT
 
   This value can be encoded in the ticket, thus avoiding the need to   keep state for each outstanding ticket.  The server can determine the   client's view of the age of the ticket by subtracting the ticket's   "ticket_age_add" value from the "obfuscated_ticket_age" parameter in   the client's "pre_shared_key" extension.  The server can determine   the expected_arrival_time of the ClientHello as:
 
     expected_arrival_time = adjusted_creation_time + clients_ticket_age
 
   When a new ClientHello is received, the expected_arrival_time is then   compared against the current server wall clock time and if they   differ by more than a certain amount, 0-RTT is rejected, though the   1-RTT handshake can be allowed to complete.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   There are several potential sources of error that might cause   mismatches between the expected_arrival_time and the measured time.   Variations in client and server clock rates are likely to be minimal,   though potentially the absolute times may be off by large values.   Network propagation delays are the most likely causes of a mismatch   in legitimate values for elapsed time.  Both the NewSessionTicket and   ClientHello messages might be retransmitted and therefore delayed,   which might be hidden by TCP.  For clients on the Internet, this   implies windows on the order of ten seconds to account for errors in   clocks and variations in measurements; other deployment scenarios may   have different needs.  Clock skew distributions are not symmetric, so   the optimal tradeoff may involve an asymmetric range of permissible   mismatch values.
 
   Note that freshness checking alone is not sufficient to prevent   replays because it does not detect them during the error window,   which -- depending on bandwidth and system capacity -- could include   billions of replays in real-world settings.  In addition, this   freshness checking is only done at the time the ClientHello is   received and not when subsequent early Application Data records are   received.  After early data is accepted, records may continue to be   streamed to the server over a longer time period.
 
9.  Compliance Requirements
 
9.1.  Mandatory-to-Implement Cipher Suites
 
   In the absence of an application profile standard specifying   otherwise:
 
   A TLS-compliant application MUST implement the TLS_AES_128_GCM_SHA256   [GCM] cipher suite and SHOULD implement the TLS_AES_256_GCM_SHA384   [GCM] and TLS_CHACHA20_POLY1305_SHA256 [RFC8439] cipher suites (see   Appendix B.4).
 
   A TLS-compliant application MUST support digital signatures with   rsa_pkcs1_sha256 (for certificates), rsa_pss_rsae_sha256 (for   CertificateVerify and certificates), and ecdsa_secp256r1_sha256.  A   TLS-compliant application MUST support key exchange with secp256r1   (NIST P-256) and SHOULD support key exchange with X25519 [RFC7748].</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
9.2.  Mandatory-to-Implement Extensions
 
   In the absence of an application profile standard specifying   otherwise, a TLS-compliant application MUST implement the following   TLS extensions:
 
   -  Supported Versions ("supported_versions"; Section 4.2.1)
 
   -  Cookie ("cookie"; Section 4.2.2)
 
   -  Signature Algorithms ("signature_algorithms"; Section 4.2.3)
 
   -  Signature Algorithms Certificate ("signature_algorithms_cert";      Section 4.2.3)
 
   -  Negotiated Groups ("supported_groups"; Section 4.2.7)
 
   -  Key Share ("key_share"; Section 4.2.8)
 
   -  Server Name Indication ("server_name"; Section&nbsp;3 of [RFC6066])
 
   All implementations MUST send and use these extensions when offering   applicable features:
 
   -  "supported_versions" is REQUIRED for all ClientHello, ServerHello,      and HelloRetryRequest messages.
 
   -  "signature_algorithms" is REQUIRED for certificate authentication.
 
   -  "supported_groups" is REQUIRED for ClientHello messages using DHE      or ECDHE key exchange.
 
   -  "key_share" is REQUIRED for DHE or ECDHE key exchange.
 
   -  "pre_shared_key" is REQUIRED for PSK key agreement.
 
   -  "psk_key_exchange_modes" is REQUIRED for PSK key agreement.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   A client is considered to be attempting to negotiate using this   specification if the ClientHello contains a "supported_versions"   extension with 0x0304 contained in its body.  Such a ClientHello   message MUST meet the following requirements:
 
   -  If not containing a "pre_shared_key" extension, it MUST contain      both a "signature_algorithms" extension and a "supported_groups"      extension.
 
   -  If containing a "supported_groups" extension, it MUST also contain      a "key_share" extension, and vice versa.  An empty
      KeyShare.client_shares vector is permitted.
 
   Servers receiving a ClientHello which does not conform to these   requirements MUST abort the handshake with a "missing_extension"   alert.
 
   Additionally, all implementations MUST support the use of the   "server_name" extension with applications capable of using it.   Servers MAY require clients to send a valid "server_name" extension.   Servers requiring this extension SHOULD respond to a ClientHello   lacking a "server_name" extension by terminating the connection with   a "missing_extension" alert.
 
9.3.  Protocol Invariants
 
   This section describes invariants that TLS endpoints and middleboxes   MUST follow.  It also applies to earlier versions of TLS.
 
   TLS is designed to be securely and compatibly extensible.  Newer   clients or servers, when communicating with newer peers, should   negotiate the most preferred common parameters.  The TLS handshake   provides downgrade protection: Middleboxes passing traffic between a   newer client and newer server without terminating TLS should be   unable to influence the handshake (see Appendix E.1).  At the same   time, deployments update at different rates, so a newer client or   server MAY continue to support older parameters, which would allow it   to interoperate with older endpoints.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   For this to work, implementations MUST correctly handle extensible   fields:
 
   -  A client sending a ClientHello MUST support all parameters      advertised in it.  Otherwise, the server may fail to interoperate      by selecting one of those parameters.
 
   -  A server receiving a ClientHello MUST correctly ignore all      unrecognized cipher suites, extensions, and other parameters.      Otherwise, it may fail to interoperate with newer clients.  In      TLS 1.3, a client receiving a CertificateRequest or
      NewSessionTicket MUST also ignore all unrecognized extensions.
 
   -  A middlebox which terminates a TLS connection MUST behave as a      compliant TLS server (to the original client), including having a      certificate which the client is willing to accept, and also as a      compliant TLS client (to the original server), including verifying      the original server's certificate.  In particular, it MUST      generate its own ClientHello containing only parameters it      understands, and it MUST generate a fresh ServerHello random      value, rather than forwarding the endpoint's value.
 
      Note that TLS's protocol requirements and security analysis only      apply to the two connections separately.  Safely deploying a TLS      terminator requires additional security considerations which are      beyond the scope of this document.
 
   -  A middlebox which forwards ClientHello parameters it does not      understand MUST NOT process any messages beyond that ClientHello.      It MUST forward all subsequent traffic unmodified.  Otherwise, it      may fail to interoperate with newer clients and servers.
 
      Forwarded ClientHellos may contain advertisements for features not      supported by the middlebox, so the response may include future TLS      additions the middlebox does not recognize.  These additions MAY      change any message beyond the ClientHello arbitrarily.  In      particular, the values sent in the ServerHello might change, the      ServerHello format might change, and the TLSCiphertext format      might change.
 
   The design of TLS 1.3 was constrained by widely deployed   non-compliant TLS middleboxes (see Appendix D.4); however, it does   not relax the invariants.  Those middleboxes continue to be   non-compliant.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
10.  Security Considerations
 
   Security issues are discussed throughout this memo, especially in   Appendices C, D, and E.
 
11.  IANA Considerations
 
   This document uses several registries that were originally created in   [RFC4346] and updated in [RFC8447].  IANA has updated these to   reference this document.  The registries and their allocation   policies are below:
 
   -  TLS Cipher Suites registry: values with the first byte in the      range 0-254 (decimal) are assigned via Specification Required      [RFC8126].  Values with the first byte 255 (decimal) are reserved      for Private Use [RFC8126].
 
      IANA has added the cipher suites listed in Appendix B.4 to the      registry.  The "Value" and "Description" columns are taken from      the table.  The "DTLS-OK" and "Recommended" columns are both      marked as "Y" for each new cipher suite.
 
   -  TLS ContentType registry: Future values are allocated via      Standards Action [RFC8126].
 
   -  TLS Alerts registry: Future values are allocated via Standards      Action [RFC8126].  IANA has populated this registry with the      values from Appendix B.2.  The "DTLS-OK" column is marked as "Y"      for all such values.  Values marked as "_RESERVED" have comments      describing their previous usage.
 
   -  TLS HandshakeType registry: Future values are allocated via      Standards Action [RFC8126].  IANA has updated this registry to      rename item 4 from "NewSessionTicket" to "new_session_ticket" and      populated this registry with the values from Appendix B.3.  The      "DTLS-OK" column is marked as "Y" for all such values.  Values      marked "_RESERVED" have comments describing their previous or      temporary usage.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   This document also uses the TLS ExtensionType Values registry   originally created in [RFC4366].  IANA has updated it to reference   this document.  Changes to the registry follow:
 
   -  IANA has updated the registration policy as follows:
 
      Values with the first byte in the range 0-254 (decimal) are      assigned via Specification Required [RFC8126].  Values with the      first byte 255 (decimal) are reserved for Private Use [RFC8126].
 
   -  IANA has updated this registry to include the "key_share",      "pre_shared_key", "psk_key_exchange_modes", "early_data",      "cookie", "supported_versions", "certificate_authorities",      "oid_filters", "post_handshake_auth", and
      "signature_algorithms_cert" extensions with the values defined in      this document and the "Recommended" value of "Y".
 
   -  IANA has updated this registry to include a "TLS 1.3" column which      lists the messages in which the extension may appear.  This column      has been initially populated from the table in Section 4.2, with      any extension not listed there marked as "-" to indicate that it      is not used by TLS 1.3.
 
   This document updates an entry in the TLS Certificate Types registry   originally created in [RFC6091] and updated in [RFC8447].  IANA has   updated the entry for value 1 to have the name "OpenPGP_RESERVED",   "Recommended" value "N", and comment "Used in TLS versions prior   to 1.3."
 
   This document updates an entry in the TLS Certificate Status Types   registry originally created in [RFC6961].  IANA has updated the entry   for value 2 to have the name "ocsp_multi_RESERVED" and comment "Used   in TLS versions prior to 1.3".
 
   This document updates two entries in the TLS Supported Groups   registry (created under a different name by [RFC4492]; now maintained   by [RFC8422]) and updated by [RFC7919] and [RFC8447].  The entries   for values 29 and 30 (x25519 and x448) have been updated to also   refer to this document.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   In addition, this document defines two new registries that are   maintained by IANA:
 
   -  TLS SignatureScheme registry: Values with the first byte in the      range 0-253 (decimal) are assigned via Specification Required      [RFC8126].  Values with the first byte 254 or 255 (decimal) are      reserved for Private Use [RFC8126].  Values with the first byte in      the range 0-6 or with the second byte in the range 0-3 that are      not currently allocated are reserved for backward compatibility.      This registry has a "Recommended" column.  The registry has been      initially populated with the values described in Section 4.2.3.      The following values are marked as "Recommended":
      ecdsa_secp256r1_sha256, ecdsa_secp384r1_sha384,      rsa_pss_rsae_sha256, rsa_pss_rsae_sha384, rsa_pss_rsae_sha512,      rsa_pss_pss_sha256, rsa_pss_pss_sha384, rsa_pss_pss_sha512, and      ed25519.  The "Recommended" column is assigned a value of "N"      unless explicitly requested, and adding a value with a      "Recommended" value of "Y" requires Standards Action [RFC8126].      IESG Approval is REQUIRED for a Y-&gt;N transition.
 
   -  TLS PskKeyExchangeMode registry: Values in the range 0-253      (decimal) are assigned via Specification Required [RFC8126].      The values 254 and 255 (decimal) are reserved for Private Use      [RFC8126].  This registry has a "Recommended" column.  The      registry has been initially populated with psk_ke (0) and      psk_dhe_ke (1).  Both are marked as "Recommended".  The      "Recommended" column is assigned a value of "N" unless explicitly      requested, and adding a value with a "Recommended" value of "Y"      requires Standards Action [RFC8126].  IESG Approval is REQUIRED      for a Y-&gt;N transition.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
12.  References
 
12.1.  Normative References
 
   [DH76]     Diffie, W. and M. Hellman, "New directions in
              cryptography", IEEE Transactions on Information
              Theory, Vol. 22 No. 6, pp. 644-654,
              DOI 10.1109/TIT.1976.1055638, November 1976.
 
   [ECDSA]    American National Standards Institute, "Public Key              Cryptography for the Financial Services Industry: The              Elliptic Curve Digital Signature Algorithm (ECDSA)",              ANSI ANS X9.62-2005, November 2005.
 
   [GCM]      Dworkin, M., "Recommendation for Block Cipher Modes of              Operation: Galois/Counter Mode (GCM) and GMAC",
              NIST Special Publication 800-38D,
              DOI 10.6028/NIST.SP.800-38D, November 2007.
 
   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-              Hashing for Message Authentication", RFC 2104,
              DOI 10.17487/RFC2104, February 1997,
              <https: www.rfc-editor.org="" info="" rfc2104="">.
 
   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https: www.rfc-editor.org="" info="" rfc2119="">.
 
   [RFC5116]  McGrew, D., "An Interface and Algorithms for Authenticated              Encryption", RFC 5116, DOI 10.17487/RFC5116, January 2008,              <https: www.rfc-editor.org="" info="" rfc5116="">.
 
   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List              (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May 2008,              <https: www.rfc-editor.org="" info="" rfc5280="">.
 
   [RFC5705]  Rescorla, E., "Keying Material Exporters for Transport              Layer Security (TLS)", RFC 5705, DOI 10.17487/RFC5705,              March 2010, <https: www.rfc-editor.org="" info="" rfc5705="">.
 
   [RFC5756]  Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk,              "Updates for RSAES-OAEP and RSASSA-PSS Algorithm
              Parameters", RFC 5756, DOI 10.17487/RFC5756, January 2010,              <https: www.rfc-editor.org="" info="" rfc5756="">.</https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [RFC5869]  Krawczyk, H. and P. Eronen, "HMAC-based Extract-and-Expand              Key Derivation Function (HKDF)", RFC 5869,
              DOI 10.17487/RFC5869, May 2010,
              <https: www.rfc-editor.org="" info="" rfc5869="">.
 
   [RFC6066]  Eastlake 3rd, D., "Transport Layer Security (TLS)              Extensions: Extension Definitions", RFC 6066,
              DOI 10.17487/RFC6066, January 2011,
              <https: www.rfc-editor.org="" info="" rfc6066="">.
 
   [RFC6655]  McGrew, D. and D. Bailey, "AES-CCM Cipher Suites for              Transport Layer Security (TLS)", RFC 6655,
              DOI 10.17487/RFC6655, July 2012,
              <https: www.rfc-editor.org="" info="" rfc6655="">.
 
   [RFC6960]  Santesson, S., Myers, M., Ankney, R., Malpani, A.,              Galperin, S., and C. Adams, "X.509 Internet Public Key              Infrastructure Online Certificate Status Protocol - OCSP",              RFC 6960, DOI 10.17487/RFC6960, June 2013,
              <https: www.rfc-editor.org="" info="" rfc6960="">.
 
   [RFC6961]  Pettersen, Y., "The Transport Layer Security (TLS)              Multiple Certificate Status Request Extension", RFC 6961,              DOI 10.17487/RFC6961, June 2013,
              <https: www.rfc-editor.org="" info="" rfc6961="">.
 
   [RFC6962]  Laurie, B., Langley, A., and E. Kasper, "Certificate              Transparency", RFC 6962, DOI 10.17487/RFC6962, June 2013,              <https: www.rfc-editor.org="" info="" rfc6962="">.
 
   [RFC6979]  Pornin, T., "Deterministic Usage of the Digital Signature              Algorithm (DSA) and Elliptic Curve Digital Signature              Algorithm (ECDSA)", RFC 6979, DOI 10.17487/RFC6979,              August 2013, <https: www.rfc-editor.org="" info="" rfc6979="">.
 
   [RFC7301]  Friedl, S., Popov, A., Langley, A., and E. Stephan,              "Transport Layer Security (TLS) Application-Layer Protocol              Negotiation Extension", RFC 7301, DOI 10.17487/RFC7301,              July 2014, <https: www.rfc-editor.org="" info="" rfc7301="">.
 
   [RFC7507]  Moeller, B. and A. Langley, "TLS Fallback Signaling Cipher              Suite Value (SCSV) for Preventing Protocol Downgrade              Attacks", RFC 7507, DOI 10.17487/RFC7507, April 2015,              <https: www.rfc-editor.org="" info="" rfc7507="">.
 
   [RFC7748]  Langley, A., Hamburg, M., and S. Turner, "Elliptic Curves              for Security", RFC 7748, DOI 10.17487/RFC7748,
              January 2016, <https: www.rfc-editor.org="" info="" rfc7748="">.</https:></https:></https:></https:></https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [RFC7919]  Gillmor, D., "Negotiated Finite Field Diffie-Hellman              Ephemeral Parameters for Transport Layer Security (TLS)",              RFC 7919, DOI 10.17487/RFC7919, August 2016,
              <https: www.rfc-editor.org="" info="" rfc7919="">.
 
   [RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,              "PKCS #1: RSA Cryptography Specifications Version 2.2",              RFC 8017, DOI 10.17487/RFC8017, November 2016,
              <https: www.rfc-editor.org="" info="" rfc8017="">.
 
   [RFC8032]  Josefsson, S. and I. Liusvaara, "Edwards-Curve Digital              Signature Algorithm (EdDSA)", RFC 8032,
              DOI 10.17487/RFC8032, January 2017,
              <https: www.rfc-editor.org="" info="" rfc8032="">.
 
   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for              Writing an IANA Considerations Section in RFCs", BCP 26,              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https: www.rfc-editor.org="" info="" rfc8126="">.
 
   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in              RFC 2119 Key Words", BCP 14, RFC 8174,
              DOI 10.17487/RFC8174, May 2017,
              <https: www.rfc-editor.org="" info="" rfc8174="">.
 
   [RFC8439]  Nir, Y. and A. Langley, "ChaCha20 and Poly1305 for IETF              Protocols", RFC 8439, DOI 10.17487/RFC8439, June 2018,              <https: www.rfc-editor.org="" info="" rfc8439="">.
 
   [SHS]      Dang, Q., "Secure Hash Standard (SHS)", National Institute              of Standards and Technology report,
              DOI 10.6028/NIST.FIPS.180-4, August 2015.
 
   [X690]     ITU-T, "Information technology -- ASN.1 encoding rules:              Specification of Basic Encoding Rules (BER), Canonical              Encoding Rules (CER) and Distinguished Encoding Rules              (DER)", ISO/IEC 8825-1:2015, November 2015.</https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
12.2.  Informative References
 
   [AEAD-LIMITS]
              Luykx, A. and K. Paterson, "Limits on Authenticated
              Encryption Use in TLS", August 2017,
              <http: www.isg.rhul.ac.uk="" ~kp="" tls-aebounds.pdf="">.
 
   [BBFGKZ16]
              Bhargavan, K., Brzuska, C., Fournet, C., Green, M.,
              Kohlweiss, M., and S. Zanella-Beguelin, "Downgrade              Resilience in Key-Exchange Protocols", Proceedings of IEEE              Symposium on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.37, May 2016.
 
   [BBK17]    Bhargavan, K., Blanchet, B., and N. Kobeissi, "Verified              Models and Reference Implementations for the TLS 1.3              Standard Candidate", Proceedings of IEEE Symposium on              Security and Privacy (San Jose), DOI 10.1109/SP.2017.26,              May 2017.
 
   [BDFKPPRSZZ16]
              Bhargavan, K., Delignat-Lavaud, A., Fournet, C.,
              Kohlweiss, M., Pan, J., Protzenko, J., Rastogi, A., Swamy,              N., Zanella-Beguelin, S., and J. Zinzindohoue,
              "Implementing and Proving the TLS 1.3 Record Layer",              Proceedings of IEEE Symposium on Security and Privacy (San              Jose), May 2017, <https: eprint.iacr.org="" 2016="" 1178="">.
 
   [Ben17a]   Benjamin, D., "Presentation before the TLS WG at              IETF 100", November 2017,
              <https: datatracker.ietf.org="" meeting="" 100="" materials="" slides-100-tls-sessa-tls13=""></https:>.
 
   [Ben17b]   Benjamin, D., "Additional TLS 1.3 results from Chrome",              message to the TLS mailing list, 18 December 2017,
              <https: www.ietf.org="" mail-archive="" web="" tls="" current="" msg25168.html="">.
 
   [Blei98]   Bleichenbacher, D., "Chosen Ciphertext Attacks against              Protocols Based on RSA Encryption Standard PKCS #1",              Proceedings of CRYPTO '98, 1998.
 
   [BMMRT15]  Badertscher, C., Matt, C., Maurer, U., Rogaway, P., and B.              Tackmann, "Augmented Secure Channels and the Goal of the              TLS 1.3 Record Layer", ProvSec 2015, September 2015,              <https: eprint.iacr.org="" 2015="" 394="">.</https:></https:></https:></http:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [BT16]     Bellare, M. and B. Tackmann, "The Multi-User Security of              Authenticated Encryption: AES-GCM in TLS 1.3", Proceedings              of CRYPTO 2016, July 2016,
              <https: eprint.iacr.org="" 2016="" 564="">.
 
   [CCG16]    Cohn-Gordon, K., Cremers, C., and L. Garratt, "On              Post-compromise Security", IEEE Computer Security              Foundations Symposium, DOI 10.1109/CSF.2016.19, July 2015.
 
   [CHECKOWAY]
              Checkoway, S., Maskiewicz, J., Garman, C., Fried, J.,              Cohney, S., Green, M., Heninger, N., Weinmann, R.,
              Rescorla, E., and H. Shacham, "A Systematic Analysis of              the Juniper Dual EC Incident", Proceedings of the 2016 ACM              SIGSAC Conference on Computer and Communications Security              - CCS '16, DOI 10.1145/2976749.2978395, October 2016.
 
   [CHHSV17]  Cremers, C., Horvat, M., Hoyland, J., Scott, S., and T.              van der Merwe, "Awkward Handshake: Possible mismatch of              client/server view on client authentication in
              post-handshake mode in Revision 18", message to the TLS              mailing list, 10 February 2017, <https: www.ietf.org="" mail-archive="" web="" tls="" current="" msg22382.html="">.
 
   [CHSV16]   Cremers, C., Horvat, M., Scott, S., and T. van der Merwe,              "Automated Analysis and Verification of TLS 1.3: 0-RTT,              Resumption and Delayed Authentication", Proceedings of              IEEE Symposium on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.35, May 2016,
              <https: ieeexplore.ieee.org="" document="" 7546518=""></https:>.
 
   [CK01]     Canetti, R. and H. Krawczyk, "Analysis of Key-Exchange              Protocols and Their Use for Building Secure Channels",              Proceedings of Eurocrypt 2001,
              DOI 10.1007/3-540-44987-6_28, April 2001.
 
   [CLINIC]   Miller, B., Huang, L., Joseph, A., and J. Tygar, "I Know              Why You Went to the Clinic: Risks and Realization of HTTPS              Traffic Analysis", Privacy Enhancing Technologies, pp.              143-163, DOI 10.1007/978-3-319-08506-7_8, 2014.
 
   [DFGS15]   Dowling, B., Fischlin, M., Guenther, F., and D. Stebila,              "A Cryptographic Analysis of the TLS 1.3 Handshake
              Protocol Candidates", Proceedings of ACM CCS 2015,
              October 2015, <https: eprint.iacr.org="" 2015="" 914="">.</https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [DFGS16]   Dowling, B., Fischlin, M., Guenther, F., and D. Stebila,              "A Cryptographic Analysis of the TLS 1.3 Full and
              Pre-shared Key Handshake Protocol", TRON 2016,
              February 2016, <https: eprint.iacr.org="" 2016="" 081="">.
 
   [DOW92]    Diffie, W., van Oorschot, P., and M. Wiener,
              "Authentication and authenticated key exchanges", Designs,              Codes and Cryptography, DOI 10.1007/BF00124891, June 1992.
 
   [DSS]      National Institute of Standards and Technology, U.S.              Department of Commerce, "Digital Signature Standard              (DSS)", NIST FIPS PUB 186-4, DOI 10.6028/NIST.FIPS.186-4,              July 2013.
 
   [FG17]     Fischlin, M. and F. Guenther, "Replay Attacks on Zero              Round-Trip Time: The Case of the TLS 1.3 Handshake
              Candidates", Proceedings of EuroS&amp;P 2017, April 2017,              <https: eprint.iacr.org="" 2017="" 082="">.
 
   [FGSW16]   Fischlin, M., Guenther, F., Schmidt, B., and B. Warinschi,              "Key Confirmation in Key Exchange: A Formal Treatment and              Implications for TLS 1.3", Proceedings of IEEE Symposium              on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.34, May 2016,
              <https: ieeexplore.ieee.org="" document="" 7546517=""></https:>.
 
   [FW15]     Weimer, F., "Factoring RSA Keys With TLS Perfect Forward              Secrecy", September 2015.
 
   [HCJC16]   Husak, M., Cermak, M., Jirsik, T., and P. Celeda, "HTTPS              traffic analysis and client identification using passive              SSL/TLS fingerprinting", EURASIP Journal on Information              Security, Vol. 2016, DOI 10.1186/s13635-016-0030-7,              February 2016.
 
   [HGFS15]   Hlauschek, C., Gruber, M., Fankhauser, F., and C. Schanes,              "Prying Open Pandora's Box: KCI Attacks against TLS",              Proceedings of USENIX Workshop on Offensive Technologies,              August 2015.
 
   [IEEE1363]
              IEEE, "IEEE Standard Specifications for Public Key
              Cryptography", IEEE Std. 1363-2000,
              DOI 10.1109/IEEESTD.2000.92292.</https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [JSS15]    Jager, T., Schwenk, J., and J. Somorovsky, "On the              Security of TLS 1.3 and QUIC Against Weaknesses in PKCS#1              v1.5 Encryption", Proceedings of ACM CCS 2015,
              DOI 10.1145/2810103.2813657, October 2015,
              <https: www.nds.rub.de="" media="" nds="" veroeffentlichungen="" 2015="" 08="" 21="" tls13quicattacks.pdf="">.
 
   [KEYAGREEMENT]
              Barker, E., Chen, L., Roginsky, A., Vassilev, A., and R.              Davis, "Recommendation for Pair-Wise Key Establishment              Schemes Using Discrete Logarithm Cryptography", National              Institute of Standards and Technology,
              DOI 10.6028/NIST.SP.800-56Ar3, April 2018.
 
   [Kraw10]   Krawczyk, H., "Cryptographic Extraction and Key              Derivation: The HKDF Scheme", Proceedings of CRYPTO 2010,              August 2010, <https: eprint.iacr.org="" 2010="" 264="">.
 
   [Kraw16]   Krawczyk, H., "A Unilateral-to-Mutual Authentication              Compiler for Key Exchange (with Applications to Client              Authentication in TLS 1.3", Proceedings of ACM CCS 2016,              October 2016, <https: eprint.iacr.org="" 2016="" 711="">.
 
   [KW16]     Krawczyk, H. and H. Wee, "The OPTLS Protocol and TLS 1.3",              Proceedings of EuroS&amp;P 2016, March 2016,
              <https: eprint.iacr.org="" 2015="" 978="">.
 
   [LXZFH16]  Li, X., Xu, J., Zhang, Z., Feng, D., and H. Hu, "Multiple              Handshakes Security of TLS 1.3 Candidates", Proceedings of              IEEE Symposium on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.36, May 2016,
              <https: ieeexplore.ieee.org="" document="" 7546519=""></https:>.
 
   [Mac17]    MacCarthaigh, C., "Security Review of TLS1.3 0-RTT",              March 2017, <https: github.com="" tlswg="" tls13-spec="" issues="" 1001="">.
 
   [PS18]     Patton, C. and T. Shrimpton, "Partially specified              channels: The TLS 1.3 record layer without elision", 2018,              <https: eprint.iacr.org="" 2018="" 634="">.
 
   [PSK-FINISHED]
              Scott, S., Cremers, C., Horvat, M., and T. van der Merwe,              "Revision 10: possible attack if client authentication is              allowed during PSK", message to the TLS mailing list,              31 October 2015, <https: www.ietf.org="" mail-archive="" web="" tls="" current="" msg18215.html="">.</https:></https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [REKEY]    Abdalla, M. and M. Bellare, "Increasing the Lifetime of a              Key: A Comparative Analysis of the Security of Re-keying              Techniques", ASIACRYPT 2000, DOI 10.1007/3-540-44448-3_42,              October 2000.
 
   [Res17a]   Rescorla, E., "Preliminary data on Firefox TLS 1.3              Middlebox experiment", message to the TLS mailing list,              5 December 2017, <https: www.ietf.org="" mail-archive="" web="" tls="" current="" msg25091.html="">.
 
   [Res17b]   Rescorla, E., "More compatibility measurement results",              message to the TLS mailing list, 22 December 2017,
              <https: www.ietf.org="" mail-archive="" web="" tls="" current="" msg25179.html="">.
 
   [RFC3552]  Rescorla, E. and B. Korver, "Guidelines for Writing RFC              Text on Security Considerations", BCP 72, RFC 3552,
              DOI 10.17487/RFC3552, July 2003,
              <https: www.rfc-editor.org="" info="" rfc3552="">.
 
   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,              "Randomness Requirements for Security", BCP 106, RFC 4086,              DOI 10.17487/RFC4086, June 2005,
              <https: www.rfc-editor.org="" info="" rfc4086="">.
 
   [RFC4346]  Dierks, T. and E. Rescorla, "The Transport Layer Security              (TLS) Protocol Version 1.1", RFC 4346,
              DOI 10.17487/RFC4346, April 2006,
              <https: www.rfc-editor.org="" info="" rfc4346="">.
 
   [RFC4366]  Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J.,              and T. Wright, "Transport Layer Security (TLS)
              Extensions", RFC 4366, DOI 10.17487/RFC4366, April 2006,              <https: www.rfc-editor.org="" info="" rfc4366="">.
 
   [RFC4492]  Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B.              Moeller, "Elliptic Curve Cryptography (ECC) Cipher Suites              for Transport Layer Security (TLS)", RFC 4492,
              DOI 10.17487/RFC4492, May 2006,
              <https: www.rfc-editor.org="" info="" rfc4492="">.
 
   [RFC5077]  Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig,              "Transport Layer Security (TLS) Session Resumption without              Server-Side State", RFC 5077, DOI 10.17487/RFC5077,              January 2008, <https: www.rfc-editor.org="" info="" rfc5077="">.</https:></https:></https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security              (TLS) Protocol Version 1.2", RFC 5246,
              DOI 10.17487/RFC5246, August 2008,
              <https: www.rfc-editor.org="" info="" rfc5246="">.
 
   [RFC5764]  McGrew, D. and E. Rescorla, "Datagram Transport Layer              Security (DTLS) Extension to Establish Keys for the Secure              Real-time Transport Protocol (SRTP)", RFC 5764,
              DOI 10.17487/RFC5764, May 2010,
              <https: www.rfc-editor.org="" info="" rfc5764="">.
 
   [RFC5929]  Altman, J., Williams, N., and L. Zhu, "Channel Bindings              for TLS", RFC 5929, DOI 10.17487/RFC5929, July 2010,              <https: www.rfc-editor.org="" info="" rfc5929="">.
 
   [RFC6091]  Mavrogiannopoulos, N. and D. Gillmor, "Using OpenPGP Keys              for Transport Layer Security (TLS) Authentication",              RFC 6091, DOI 10.17487/RFC6091, February 2011,
              <https: www.rfc-editor.org="" info="" rfc6091="">.
 
   [RFC6101]  Freier, A., Karlton, P., and P. Kocher, "The Secure              Sockets Layer (SSL) Protocol Version 3.0", RFC 6101,              DOI 10.17487/RFC6101, August 2011,
              <https: www.rfc-editor.org="" info="" rfc6101="">.
 
   [RFC6176]  Turner, S. and T. Polk, "Prohibiting Secure Sockets Layer              (SSL) Version 2.0", RFC 6176, DOI 10.17487/RFC6176,              March 2011, <https: www.rfc-editor.org="" info="" rfc6176="">.
 
   [RFC6347]  Rescorla, E. and N. Modadugu, "Datagram Transport Layer              Security Version 1.2", RFC 6347, DOI 10.17487/RFC6347,              January 2012, <https: www.rfc-editor.org="" info="" rfc6347="">.
 
   [RFC6520]  Seggelmann, R., Tuexen, M., and M. Williams, "Transport              Layer Security (TLS) and Datagram Transport Layer Security              (DTLS) Heartbeat Extension", RFC 6520,
              DOI 10.17487/RFC6520, February 2012,
              <https: www.rfc-editor.org="" info="" rfc6520="">.
 
   [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer              Protocol (HTTP/1.1): Message Syntax and Routing",
              RFC 7230, DOI 10.17487/RFC7230, June 2014,
              <https: www.rfc-editor.org="" info="" rfc7230="">.</https:></https:></https:></https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [RFC7250]  Wouters, P., Ed., Tschofenig, H., Ed., Gilmore, J.,              Weiler, S., and T. Kivinen, "Using Raw Public Keys in
              Transport Layer Security (TLS) and Datagram Transport              Layer Security (DTLS)", RFC 7250, DOI 10.17487/RFC7250,              June 2014, <https: www.rfc-editor.org="" info="" rfc7250="">.
 
   [RFC7465]  Popov, A., "Prohibiting RC4 Cipher Suites", RFC 7465,              DOI 10.17487/RFC7465, February 2015,
              <https: www.rfc-editor.org="" info="" rfc7465="">.
 
   [RFC7568]  Barnes, R., Thomson, M., Pironti, A., and A. Langley,              "Deprecating Secure Sockets Layer Version 3.0", RFC 7568,              DOI 10.17487/RFC7568, June 2015,
              <https: www.rfc-editor.org="" info="" rfc7568="">.
 
   [RFC7627]  Bhargavan, K., Ed., Delignat-Lavaud, A., Pironti, A.,              Langley, A., and M. Ray, "Transport Layer Security (TLS)              Session Hash and Extended Master Secret Extension",              RFC 7627, DOI 10.17487/RFC7627, September 2015,
              <https: www.rfc-editor.org="" info="" rfc7627="">.
 
   [RFC7685]  Langley, A., "A Transport Layer Security (TLS) ClientHello              Padding Extension", RFC 7685, DOI 10.17487/RFC7685,              October 2015, <https: www.rfc-editor.org="" info="" rfc7685="">.
 
   [RFC7924]  Santesson, S. and H. Tschofenig, "Transport Layer Security              (TLS) Cached Information Extension", RFC 7924,
              DOI 10.17487/RFC7924, July 2016,
              <https: www.rfc-editor.org="" info="" rfc7924="">.
 
   [RFC8305]  Schinazi, D. and T. Pauly, "Happy Eyeballs Version 2:              Better Connectivity Using Concurrency", RFC 8305,
              DOI 10.17487/RFC8305, December 2017,
              <https: www.rfc-editor.org="" info="" rfc8305="">.
 
   [RFC8422]  Nir, Y., Josefsson, S., and M. Pegourie-Gonnard, "Elliptic              Curve Cryptography (ECC) Cipher Suites for Transport Layer              Security (TLS) Versions 1.2 and Earlier", RFC 8422,
              DOI 10.17487/RFC8422, August 2018,
              <https: www.rfc-editor.org="" info="" rfc8422="">.
 
   [RFC8447]  Salowey, J. and S. Turner, "IANA Registry Updates for TLS              and DTLS", RFC 8447, DOI 10.17487/RFC8447, August 2018,              <https: www.rfc-editor.org="" info="" rfc8447="">.
 
   [RFC8449]  Thomson, M., "Record Size Limit Extension for TLS",              RFC 8449, DOI 10.17487/RFC8449, August 2018,
              <https: www.rfc-editor.org="" info="" rfc8449="">.</https:></https:></https:></https:></https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [RSA]      Rivest, R., Shamir, A., and L. Adleman, "A Method for              Obtaining Digital Signatures and Public-Key
              Cryptosystems", Communications of the ACM, Vol. 21 No. 2,              pp. 120-126, DOI 10.1145/359340.359342, February 1978.
 
   [SIGMA]    Krawczyk, H., "SIGMA: The 'SIGn-and-MAc' Approach to              Authenticated Diffie-Hellman and its Use in the IKE
              Protocols", Proceedings of CRYPTO 2003,
              DOI 10.1007/978-3-540-45146-4_24, August 2003.
 
   [SLOTH]    Bhargavan, K. and G. Leurent, "Transcript Collision              Attacks: Breaking Authentication in TLS, IKE, and SSH",              Network and Distributed System Security
              Symposium (NDSS 2016), DOI 10.14722/ndss.2016.23418,              February 2016.
 
   [SSL2]     Hickman, K., "The SSL Protocol", February 1995.
 
   [TIMING]   Boneh, D. and D. Brumley, "Remote Timing Attacks Are              Practical", USENIX Security Symposium, August 2003.
 
   [TLS13-TRACES]
              Thomson, M., "Example Handshake Traces for TLS 1.3", Work              in Progress, draft-ietf-tls-tls13-vectors-06, July 2018.
 
   [X501]     ITU-T, "Information Technology - Open Systems              Interconnection - The Directory: Models", ITU-T X.501,              October 2016, <https: www.itu.int="" rec="" t-rec-x.501="" en="">.</https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
Appendix A.  State Machine
 
   This appendix provides a summary of the legal state transitions for   the client and server handshakes.  State names (in all capitals,   e.g., START) have no formal meaning but are provided for ease of   comprehension.  Actions which are taken only in certain circumstances   are indicated in [].  The notation "K_{send,recv} = foo" means "set   the send/recv key to the given key".
 
A.1.  Client
 
                              START &lt;----+
               Send ClientHello |        | Recv HelloRetryRequest
          [K_send = early data] |        |
                                v        |
           /                 WAIT_SH ----+
           |                    | Recv ServerHello
           |                    | K_recv = handshake
       Can |                    V
      send |                 WAIT_EE
     early |                    | Recv EncryptedExtensions
      data |           +--------+--------+
           |     Using |                 | Using certificate
           |       PSK |                 v
           |           |            WAIT_CERT_CR
           |           |        Recv |       | Recv CertificateRequest
           |           | Certificate |       v
           |           |             |    WAIT_CERT
           |           |             |       | Recv Certificate
           |           |             v       v
           |           |              WAIT_CV
           |           |                 | Recv CertificateVerify
           |           +&gt; WAIT_FINISHED &lt;+
           |                  | Recv Finished
           \                  | [Send EndOfEarlyData]
                              | K_send = handshake
                              | [Send Certificate [+ CertificateVerify]]
    Can send                  | Send Finished
    app data   --&gt;            | K_send = K_recv = application
    after here                v
                          CONNECTED
 
   Note that with the transitions as shown above, clients may send   alerts that derive from post-ServerHello messages in the clear or   with the early data keys.  If clients need to send such alerts, they   SHOULD first rekey to the handshake keys if possible.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
A.2.  Server
 
                              START &lt;-----+
               Recv ClientHello |         | Send HelloRetryRequest
                                v         |
                             RECVD_CH ----+
                                | Select parameters
                                v
                             NEGOTIATED
                                | Send ServerHello
                                | K_send = handshake
                                | Send EncryptedExtensions
                                | [Send CertificateRequest]
 Can send                       | [Send Certificate + CertificateVerify]
 app data                       | Send Finished
 after   --&gt;                    | K_send = application
 here                  +--------+--------+
              No 0-RTT |                 | 0-RTT
                       |                 |
   K_recv = handshake  |                 | K_recv = early data
 [Skip decrypt errors] |    +------&gt; WAIT_EOED -+
                       |    |       Recv |      | Recv EndOfEarlyData
                       |    | early data |      | K_recv = handshake
                       |    +------------+      |
                       |                        |
                       +&gt; WAIT_FLIGHT2 &lt;--------+
                                |
                       +--------+--------+
               No auth |                 | Client auth
                       |                 |
                       |                 v
                       |             WAIT_CERT
                       |        Recv |       | Recv Certificate
                       |       empty |       v
                       | Certificate |    WAIT_CV
                       |             |       | Recv
                       |             v       | CertificateVerify
                       +-&gt; WAIT_FINISHED &lt;---+
                                | Recv Finished
                                | K_recv = application
                                v
                            CONNECTED</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
Appendix B.  Protocol Data Structures and Constant Values
 
   This appendix provides the normative protocol types and the   definitions for constants.  Values listed as "_RESERVED" were used in   previous versions of TLS and are listed here for completeness.   TLS 1.3 implementations MUST NOT send them but might receive them   from older TLS implementations.
 
B.1.  Record Layer
 
      enum {
          invalid(0),
          change_cipher_spec(20),
          alert(21),
          handshake(22),
          application_data(23),
          heartbeat(24),  /* RFC 6520 */
          (255)
      } ContentType;
 
      struct {
          ContentType type;
          ProtocolVersion legacy_record_version;
          uint16 length;
          opaque fragment[TLSPlaintext.length];
      } TLSPlaintext;
 
      struct {
          opaque content[TLSPlaintext.length];
          ContentType type;
          uint8 zeros[length_of_padding];
      } TLSInnerPlaintext;
 
      struct {
          ContentType opaque_type = application_data; /* 23 */          ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */          uint16 length;
          opaque encrypted_record[TLSCiphertext.length];      } TLSCiphertext;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.2.  Alert Messages
 
      enum { warning(1), fatal(2), (255) } AlertLevel;
 
      enum {
          close_notify(0),
          unexpected_message(10),
          bad_record_mac(20),
          decryption_failed_RESERVED(21),
          record_overflow(22),
          decompression_failure_RESERVED(30),
          handshake_failure(40),
          no_certificate_RESERVED(41),
          bad_certificate(42),
          unsupported_certificate(43),
          certificate_revoked(44),
          certificate_expired(45),
          certificate_unknown(46),
          illegal_parameter(47),
          unknown_ca(48),
          access_denied(49),
          decode_error(50),
          decrypt_error(51),
          export_restriction_RESERVED(60),
          protocol_version(70),
          insufficient_security(71),
          internal_error(80),
          inappropriate_fallback(86),
          user_canceled(90),
          no_renegotiation_RESERVED(100),
          missing_extension(109),
          unsupported_extension(110),
          certificate_unobtainable_RESERVED(111),
          unrecognized_name(112),
          bad_certificate_status_response(113),
          bad_certificate_hash_value_RESERVED(114),
          unknown_psk_identity(115),
          certificate_required(116),
          no_application_protocol(120),
          (255)
      } AlertDescription;
 
      struct {
          AlertLevel level;
          AlertDescription description;
      } Alert;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.  Handshake Protocol
 
      enum {
          hello_request_RESERVED(0),
          client_hello(1),
          server_hello(2),
          hello_verify_request_RESERVED(3),
          new_session_ticket(4),
          end_of_early_data(5),
          hello_retry_request_RESERVED(6),
          encrypted_extensions(8),
          certificate(11),
          server_key_exchange_RESERVED(12),
          certificate_request(13),
          server_hello_done_RESERVED(14),
          certificate_verify(15),
          client_key_exchange_RESERVED(16),
          finished(20),
          certificate_url_RESERVED(21),
          certificate_status_RESERVED(22),
          supplemental_data_RESERVED(23),
          key_update(24),
          message_hash(254),
          (255)
      } HandshakeType;
 
      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* bytes in message */
          select (Handshake.msg_type) {
              case client_hello:          ClientHello;
              case server_hello:          ServerHello;
              case end_of_early_data:     EndOfEarlyData;
              case encrypted_extensions:  EncryptedExtensions;              case certificate_request:   CertificateRequest;
              case certificate:           Certificate;
              case certificate_verify:    CertificateVerify;
              case finished:              Finished;
              case new_session_ticket:    NewSessionTicket;
              case key_update:            KeyUpdate;
          };
      } Handshake;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.1.  Key Exchange Messages
 
    uint16 ProtocolVersion;
    opaque Random[32];
 
    uint8 CipherSuite[2];    /* Cryptographic suite selector */
 
    struct {
        ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */        Random random;
        opaque legacy_session_id&lt;0..32&gt;;
        CipherSuite cipher_suites&lt;2..2^16-2&gt;;
        opaque legacy_compression_methods&lt;1..2^8-1&gt;;
        Extension extensions&lt;8..2^16-1&gt;;
    } ClientHello;
 
    struct {
        ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */        Random random;
        opaque legacy_session_id_echo&lt;0..32&gt;;
        CipherSuite cipher_suite;
        uint8 legacy_compression_method = 0;
        Extension extensions&lt;6..2^16-1&gt;;
    } ServerHello;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
    struct {
        ExtensionType extension_type;
        opaque extension_data&lt;0..2^16-1&gt;;
    } Extension;
 
    enum {
        server_name(0),                             /* RFC 6066 */
        max_fragment_length(1),                     /* RFC 6066 */
        status_request(5),                          /* RFC 6066 */
        supported_groups(10),                       /* RFC 8422, 7919 */
        signature_algorithms(13),                   /* RFC 8446 */
        use_srtp(14),                               /* RFC 5764 */
        heartbeat(15),                              /* RFC 6520 */
        application_layer_protocol_negotiation(16), /* RFC 7301 */        signed_certificate_timestamp(18),           /* RFC 6962 */
        client_certificate_type(19),                /* RFC 7250 */
        server_certificate_type(20),                /* RFC 7250 */
        padding(21),                                /* RFC 7685 */
        RESERVED(40),                               /* Used but never
                                                       assigned */
        pre_shared_key(41),                         /* RFC 8446 */
        early_data(42),                             /* RFC 8446 */
        supported_versions(43),                     /* RFC 8446 */
        cookie(44),                                 /* RFC 8446 */
        psk_key_exchange_modes(45),                 /* RFC 8446 */
        RESERVED(46),                               /* Used but never
                                                       assigned */
        certificate_authorities(47),                /* RFC 8446 */
        oid_filters(48),                            /* RFC 8446 */
        post_handshake_auth(49),                    /* RFC 8446 */
        signature_algorithms_cert(50),              /* RFC 8446 */
        key_share(51),                              /* RFC 8446 */
        (65535)
    } ExtensionType;
 
    struct {
        NamedGroup group;
        opaque key_exchange&lt;1..2^16-1&gt;;
    } KeyShareEntry;
 
    struct {
        KeyShareEntry client_shares&lt;0..2^16-1&gt;;
    } KeyShareClientHello;
 
    struct {
        NamedGroup selected_group;
    } KeyShareHelloRetryRequest;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
    struct {
        KeyShareEntry server_share;
    } KeyShareServerHello;
 
    struct {
        uint8 legacy_form = 4;
        opaque X[coordinate_length];
        opaque Y[coordinate_length];
    } UncompressedPointRepresentation;
 
    enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;
 
    struct {
        PskKeyExchangeMode ke_modes&lt;1..255&gt;;
    } PskKeyExchangeModes;
 
    struct {} Empty;
 
    struct {
        select (Handshake.msg_type) {
            case new_session_ticket:   uint32 max_early_data_size;            case client_hello:         Empty;
            case encrypted_extensions: Empty;
        };
    } EarlyDataIndication;
 
    struct {
        opaque identity&lt;1..2^16-1&gt;;
        uint32 obfuscated_ticket_age;
    } PskIdentity;
 
    opaque PskBinderEntry&lt;32..255&gt;;
 
    struct {
        PskIdentity identities&lt;7..2^16-1&gt;;
        PskBinderEntry binders&lt;33..2^16-1&gt;;
    } OfferedPsks;
 
    struct {
        select (Handshake.msg_type) {
            case client_hello: OfferedPsks;
            case server_hello: uint16 selected_identity;
        };
    } PreSharedKeyExtension;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.1.1.  Version Extension
 
      struct {
          select (Handshake.msg_type) {
              case client_hello:
                   ProtocolVersion versions&lt;2..254&gt;;
 
              case server_hello: /* and HelloRetryRequest */
                   ProtocolVersion selected_version;
          };
      } SupportedVersions;
 
B.3.1.2.  Cookie Extension
 
      struct {
          opaque cookie&lt;1..2^16-1&gt;;
      } Cookie;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.1.3.  Signature Algorithm Extension
 
      enum {
          /* RSASSA-PKCS1-v1_5 algorithms */
          rsa_pkcs1_sha256(0x0401),
          rsa_pkcs1_sha384(0x0501),
          rsa_pkcs1_sha512(0x0601),
 
          /* ECDSA algorithms */
          ecdsa_secp256r1_sha256(0x0403),
          ecdsa_secp384r1_sha384(0x0503),
          ecdsa_secp521r1_sha512(0x0603),
 
          /* RSASSA-PSS algorithms with public key OID rsaEncryption */          rsa_pss_rsae_sha256(0x0804),
          rsa_pss_rsae_sha384(0x0805),
          rsa_pss_rsae_sha512(0x0806),
 
          /* EdDSA algorithms */
          ed25519(0x0807),
          ed448(0x0808),
 
          /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */          rsa_pss_pss_sha256(0x0809),
          rsa_pss_pss_sha384(0x080a),
          rsa_pss_pss_sha512(0x080b),
 
          /* Legacy algorithms */
          rsa_pkcs1_sha1(0x0201),
          ecdsa_sha1(0x0203),
 
          /* Reserved Code Points */
          obsolete_RESERVED(0x0000..0x0200),
          dsa_sha1_RESERVED(0x0202),
          obsolete_RESERVED(0x0204..0x0400),
          dsa_sha256_RESERVED(0x0402),
          obsolete_RESERVED(0x0404..0x0500),
          dsa_sha384_RESERVED(0x0502),
          obsolete_RESERVED(0x0504..0x0600),
          dsa_sha512_RESERVED(0x0602),
          obsolete_RESERVED(0x0604..0x06FF),
          private_use(0xFE00..0xFFFF),
          (0xFFFF)
      } SignatureScheme;
 
      struct {
          SignatureScheme supported_signature_algorithms&lt;2..2^16-2&gt;;      } SignatureSchemeList;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.1.4.  Supported Groups Extension
 
      enum {
          unallocated_RESERVED(0x0000),
 
          /* Elliptic Curve Groups (ECDHE) */
          obsolete_RESERVED(0x0001..0x0016),
          secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),          obsolete_RESERVED(0x001A..0x001C),
          x25519(0x001D), x448(0x001E),
 
          /* Finite Field Groups (DHE) */
          ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),          ffdhe6144(0x0103), ffdhe8192(0x0104),
 
          /* Reserved Code Points */
          ffdhe_private_use(0x01FC..0x01FF),
          ecdhe_private_use(0xFE00..0xFEFF),
          obsolete_RESERVED(0xFF01..0xFF02),
          (0xFFFF)
      } NamedGroup;
 
      struct {
          NamedGroup named_group_list&lt;2..2^16-1&gt;;
      } NamedGroupList;
 
   Values within "obsolete_RESERVED" ranges are used in previous   versions of TLS and MUST NOT be offered or negotiated by TLS 1.3   implementations.  The obsolete curves have various known/theoretical   weaknesses or have had very little usage, in some cases only due to   unintentional server configuration issues.  They are no longer   considered appropriate for general use and should be assumed to be   potentially unsafe.  The set of curves specified here is sufficient   for interoperability with all currently deployed and properly   configured TLS implementations.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.2.  Server Parameters Messages
 
      opaque DistinguishedName&lt;1..2^16-1&gt;;
 
      struct {
          DistinguishedName authorities&lt;3..2^16-1&gt;;
      } CertificateAuthoritiesExtension;
 
      struct {
          opaque certificate_extension_oid&lt;1..2^8-1&gt;;
          opaque certificate_extension_values&lt;0..2^16-1&gt;;      } OIDFilter;
 
      struct {
          OIDFilter filters&lt;0..2^16-1&gt;;
      } OIDFilterExtension;
 
      struct {} PostHandshakeAuth;
 
      struct {
          Extension extensions&lt;0..2^16-1&gt;;
      } EncryptedExtensions;
 
      struct {
          opaque certificate_request_context&lt;0..2^8-1&gt;;
          Extension extensions&lt;2..2^16-1&gt;;
      } CertificateRequest;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.3.  Authentication Messages
 
      enum {
          X509(0),
          OpenPGP_RESERVED(1),
          RawPublicKey(2),
          (255)
      } CertificateType;
 
      struct {
          select (certificate_type) {
              case RawPublicKey:
                /* From RFC 7250 ASN.1_subjectPublicKeyInfo */
                opaque ASN1_subjectPublicKeyInfo&lt;1..2^24-1&gt;;
 
              case X509:
                opaque cert_data&lt;1..2^24-1&gt;;
          };
          Extension extensions&lt;0..2^16-1&gt;;
      } CertificateEntry;
 
      struct {
          opaque certificate_request_context&lt;0..2^8-1&gt;;
          CertificateEntry certificate_list&lt;0..2^24-1&gt;;
      } Certificate;
 
      struct {
          SignatureScheme algorithm;
          opaque signature&lt;0..2^16-1&gt;;
      } CertificateVerify;
 
      struct {
          opaque verify_data[Hash.length];
      } Finished;
 
B.3.4.  Ticket Establishment
 
      struct {
          uint32 ticket_lifetime;
          uint32 ticket_age_add;
          opaque ticket_nonce&lt;0..255&gt;;
          opaque ticket&lt;1..2^16-1&gt;;
          Extension extensions&lt;0..2^16-2&gt;;
      } NewSessionTicket;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.5.  Updating Keys
 
      struct {} EndOfEarlyData;
 
      enum {
          update_not_requested(0), update_requested(1), (255)      } KeyUpdateRequest;
 
      struct {
          KeyUpdateRequest request_update;
      } KeyUpdate;
 
B.4.  Cipher Suites
 
   A symmetric cipher suite defines the pair of the AEAD algorithm and   hash algorithm to be used with HKDF.  Cipher suite names follow the   naming convention:
 
      CipherSuite TLS_AEAD_HASH = VALUE;
 
      +-----------+------------------------------------------------+
      | Component | Contents                                       |
      +-----------+------------------------------------------------+
      | TLS       | The string "TLS"                               |
      |           |                                                |
      | AEAD      | The AEAD algorithm used for record protection  |
      |           |                                                |
      | HASH      | The hash algorithm used with HKDF              |
      |           |                                                |
      | VALUE     | The two-byte ID assigned for this cipher suite |
      +-----------+------------------------------------------------+
 
   This specification defines the following cipher suites for use with   TLS 1.3.
 
              +------------------------------+-------------+
              | Description                  | Value       |
              +------------------------------+-------------+
              | TLS_AES_128_GCM_SHA256       | {0x13,0x01} |
              |                              |             |
              | TLS_AES_256_GCM_SHA384       | {0x13,0x02} |
              |                              |             |
              | TLS_CHACHA20_POLY1305_SHA256 | {0x13,0x03} |
              |                              |             |
              | TLS_AES_128_CCM_SHA256       | {0x13,0x04} |
              |                              |             |
              | TLS_AES_128_CCM_8_SHA256     | {0x13,0x05} |
              +------------------------------+-------------+</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   The corresponding AEAD algorithms AEAD_AES_128_GCM, AEAD_AES_256_GCM,   and AEAD_AES_128_CCM are defined in [RFC5116].
   AEAD_CHACHA20_POLY1305 is defined in [RFC8439].  AEAD_AES_128_CCM_8   is defined in [RFC6655].  The corresponding hash algorithms are   defined in [SHS].
 
   Although TLS 1.3 uses the same cipher suite space as previous   versions of TLS, TLS 1.3 cipher suites are defined differently, only   specifying the symmetric ciphers, and cannot be used for TLS 1.2.   Similarly, cipher suites for TLS 1.2 and lower cannot be used with   TLS 1.3.
 
   New cipher suite values are assigned by IANA as described in   Section 11.
 
Appendix C.  Implementation Notes
 
   The TLS protocol cannot prevent many common security mistakes.  This   appendix provides several recommendations to assist implementors.   [TLS13-TRACES] provides test vectors for TLS 1.3 handshakes.
 
C.1.  Random Number Generation and Seeding
 
   TLS requires a cryptographically secure pseudorandom number generator   (CSPRNG).  In most cases, the operating system provides an   appropriate facility such as /dev/urandom, which should be used   absent other (e.g., performance) concerns.  It is RECOMMENDED to use   an existing CSPRNG implementation in preference to crafting a new   one.  Many adequate cryptographic libraries are already available   under favorable license terms.  Should those prove unsatisfactory,   [RFC4086] provides guidance on the generation of random values.
 
   TLS uses random values (1) in public protocol fields such as the   public Random values in the ClientHello and ServerHello and (2) to   generate keying material.  With a properly functioning CSPRNG, this   does not present a security problem, as it is not feasible to   determine the CSPRNG state from its output.  However, with a broken   CSPRNG, it may be possible for an attacker to use the public output   to determine the CSPRNG internal state and thereby predict the keying   material, as documented in [CHECKOWAY].  Implementations can provide   extra security against this form of attack by using separate CSPRNGs   to generate public and private values.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
C.2.  Certificates and Authentication
 
   Implementations are responsible for verifying the integrity of   certificates and should generally support certificate revocation   messages.  Absent a specific indication from an application profile,   certificates should always be verified to ensure proper signing by a   trusted certificate authority (CA).  The selection and addition of   trust anchors should be done very carefully.  Users should be able to   view information about the certificate and trust anchor.   Applications SHOULD also enforce minimum and maximum key sizes.  For   example, certification paths containing keys or signatures weaker   than 2048-bit RSA or 224-bit ECDSA are not appropriate for secure   applications.
 
C.3.  Implementation Pitfalls
 
   Implementation experience has shown that certain parts of earlier TLS   specifications are not easy to understand and have been a source of   interoperability and security problems.  Many of these areas have   been clarified in this document, but this appendix contains a short   list of the most important things that require special attention from   implementors.
 
   TLS protocol issues:
 
   -  Do you correctly handle handshake messages that are fragmented to      multiple TLS records (see Section 5.1)?  Do you correctly handle      corner cases like a ClientHello that is split into several small      fragments?  Do you fragment handshake messages that exceed the      maximum fragment size?  In particular, the Certificate and      CertificateRequest handshake messages can be large enough to      require fragmentation.
 
   -  Do you ignore the TLS record layer version number in all      unencrypted TLS records (see Appendix D)?
 
   -  Have you ensured that all support for SSL, RC4, EXPORT ciphers,      and MD5 (via the "signature_algorithms" extension) is completely      removed from all possible configurations that support TLS 1.3 or      later, and that attempts to use these obsolete capabilities fail      correctly (see Appendix D)?
 
   -  Do you handle TLS extensions in ClientHellos correctly, including      unknown extensions?</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   -  When the server has requested a client certificate but no suitable      certificate is available, do you correctly send an empty      Certificate message, instead of omitting the whole message (see      Section 4.4.2)?
 
   -  When processing the plaintext fragment produced by AEAD-Decrypt      and scanning from the end for the ContentType, do you avoid      scanning past the start of the cleartext in the event that the      peer has sent a malformed plaintext of all zeros?
 
   -  Do you properly ignore unrecognized cipher suites (Section 4.1.2),      hello extensions (Section 4.2), named groups (Section 4.2.7), key      shares (Section 4.2.8), supported versions (Section 4.2.1), and      signature algorithms (Section 4.2.3) in the ClientHello?
 
   -  As a server, do you send a HelloRetryRequest to clients which      support a compatible (EC)DHE group but do not predict it in the      "key_share" extension?  As a client, do you correctly handle a      HelloRetryRequest from the server?
 
   Cryptographic details:
 
   -  What countermeasures do you use to prevent timing attacks      [TIMING]?
 
   -  When using Diffie-Hellman key exchange, do you correctly preserve      leading zero bytes in the negotiated key (see Section 7.4.1)?
 
   -  Does your TLS client check that the Diffie-Hellman parameters sent      by the server are acceptable (see Section 4.2.8.1)?
 
   -  Do you use a strong and, most importantly, properly seeded random      number generator (see Appendix C.1) when generating Diffie-Hellman      private values, the ECDSA "k" parameter, and other security-      critical values?  It is RECOMMENDED that implementations implement      "deterministic ECDSA" as specified in [RFC6979].
 
   -  Do you zero-pad Diffie-Hellman public key values and shared      secrets to the group size (see Section 4.2.8.1 and Section 7.4.1)?
 
   -  Do you verify signatures after making them, to protect against      RSA-CRT key leaks [FW15]?</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
C.4.  Client Tracking Prevention
 
   Clients SHOULD NOT reuse a ticket for multiple connections.  Reuse of   a ticket allows passive observers to correlate different connections.   Servers that issue tickets SHOULD offer at least as many tickets as   the number of connections that a client might use; for example, a web   browser using HTTP/1.1 [RFC7230] might open six connections to a   server.  Servers SHOULD issue new tickets with every connection.   This ensures that clients are always able to use a new ticket when   creating a new connection.
 
C.5.  Unauthenticated Operation
 
   Previous versions of TLS offered explicitly unauthenticated cipher   suites based on anonymous Diffie-Hellman.  These modes have been   deprecated in TLS 1.3.  However, it is still possible to negotiate   parameters that do not provide verifiable server authentication by   several methods, including:
 
   -  Raw public keys [RFC7250].
 
   -  Using a public key contained in a certificate but without      validation of the certificate chain or any of its contents.
 
   Either technique used alone is vulnerable to man-in-the-middle   attacks and therefore unsafe for general use.  However, it is also   possible to bind such connections to an external authentication   mechanism via out-of-band validation of the server's public key,   trust on first use, or a mechanism such as channel bindings (though   the channel bindings described in [RFC5929] are not defined for   TLS 1.3).  If no such mechanism is used, then the connection has no   protection against active man-in-the-middle attack; applications   MUST NOT use TLS in such a way absent explicit configuration or a   specific application profile.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
Appendix D.  Backward Compatibility
 
   The TLS protocol provides a built-in mechanism for version   negotiation between endpoints potentially supporting different   versions of TLS.
 
   TLS 1.x and SSL 3.0 use compatible ClientHello messages.  Servers can   also handle clients trying to use future versions of TLS as long as   the ClientHello format remains compatible and there is at least one   protocol version supported by both the client and the server.
 
   Prior versions of TLS used the record layer version number   (TLSPlaintext.legacy_record_version and
   TLSCiphertext.legacy_record_version) for various purposes.  As of   TLS 1.3, this field is deprecated.  The value of
   TLSPlaintext.legacy_record_version MUST be ignored by all   implementations.  The value of TLSCiphertext.legacy_record_version is   included in the additional data for deprotection but MAY otherwise be   ignored or MAY be validated to match the fixed constant value.   Version negotiation is performed using only the handshake versions   (ClientHello.legacy_version and ServerHello.legacy_version, as well   as the ClientHello, HelloRetryRequest, and ServerHello   "supported_versions" extensions).  In order to maximize   interoperability with older endpoints, implementations that negotiate   the use of TLS 1.0-1.2 SHOULD set the record layer version number to   the negotiated version for the ServerHello and all records   thereafter.
 
   For maximum compatibility with previously non-standard behavior and   misconfigured deployments, all implementations SHOULD support   validation of certification paths based on the expectations in this   document, even when handling prior TLS versions' handshakes (see   Section 4.4.2.2).
 
   TLS 1.2 and prior supported an "Extended Master Secret" [RFC7627]   extension which digested large parts of the handshake transcript into   the master secret.  Because TLS 1.3 always hashes in the transcript   up to the server Finished, implementations which support both TLS 1.3   and earlier versions SHOULD indicate the use of the Extended Master   Secret extension in their APIs whenever TLS 1.3 is used.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
D.1.  Negotiating with an Older Server
 
   A TLS 1.3 client who wishes to negotiate with servers that do not   support TLS 1.3 will send a normal TLS 1.3 ClientHello containing   0x0303 (TLS 1.2) in ClientHello.legacy_version but with the correct   version(s) in the "supported_versions" extension.  If the server does   not support TLS 1.3, it will respond with a ServerHello containing an   older version number.  If the client agrees to use this version, the   negotiation will proceed as appropriate for the negotiated protocol.   A client using a ticket for resumption SHOULD initiate the connection   using the version that was previously negotiated.
 
   Note that 0-RTT data is not compatible with older servers and   SHOULD NOT be sent absent knowledge that the server supports TLS 1.3.   See Appendix D.3.
 
   If the version chosen by the server is not supported by the client   (or is not acceptable), the client MUST abort the handshake with a   "protocol_version" alert.
 
   Some legacy server implementations are known to not implement the TLS   specification properly and might abort connections upon encountering   TLS extensions or versions which they are not aware of.   Interoperability with buggy servers is a complex topic beyond the   scope of this document.  Multiple connection attempts may be required   in order to negotiate a backward-compatible connection; however, this   practice is vulnerable to downgrade attacks and is NOT RECOMMENDED.
 
D.2.  Negotiating with an Older Client
 
   A TLS server can also receive a ClientHello indicating a version   number smaller than its highest supported version.  If the   "supported_versions" extension is present, the server MUST negotiate   using that extension as described in Section 4.2.1.  If the   "supported_versions" extension is not present, the server MUST   negotiate the minimum of ClientHello.legacy_version and TLS 1.2.  For   example, if the server supports TLS 1.0, 1.1, and 1.2, and   legacy_version is TLS 1.0, the server will proceed with a TLS 1.0   ServerHello.  If the "supported_versions" extension is absent and the   server only supports versions greater than
   ClientHello.legacy_version, the server MUST abort the handshake with   a "protocol_version" alert.
 
   Note that earlier versions of TLS did not clearly specify the record   layer version number value in all cases
   (TLSPlaintext.legacy_record_version).  Servers will receive various   TLS 1.x versions in this field, but its value MUST always be ignored.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
D.3.  0-RTT Backward Compatibility
 
   0-RTT data is not compatible with older servers.  An older server   will respond to the ClientHello with an older ServerHello, but it   will not correctly skip the 0-RTT data and will fail to complete the   handshake.  This can cause issues when a client attempts to use   0-RTT, particularly against multi-server deployments.  For example, a   deployment could deploy TLS 1.3 gradually with some servers   implementing TLS 1.3 and some implementing TLS 1.2, or a TLS 1.3   deployment could be downgraded to TLS 1.2.
 
   A client that attempts to send 0-RTT data MUST fail a connection if   it receives a ServerHello with TLS 1.2 or older.  It can then retry   the connection with 0-RTT disabled.  To avoid a downgrade attack, the   client SHOULD NOT disable TLS 1.3, only 0-RTT.
 
   To avoid this error condition, multi-server deployments SHOULD ensure   a uniform and stable deployment of TLS 1.3 without 0-RTT prior to   enabling 0-RTT.
 
D.4.  Middlebox Compatibility Mode
 
   Field measurements [Ben17a] [Ben17b] [Res17a] [Res17b] have found   that a significant number of middleboxes misbehave when a TLS   client/server pair negotiates TLS 1.3.  Implementations can increase   the chance of making connections through those middleboxes by making   the TLS 1.3 handshake look more like a TLS 1.2 handshake:
 
   -  The client always provides a non-empty session ID in the      ClientHello, as described in the legacy_session_id section of      Section 4.1.2.
 
   -  If not offering early data, the client sends a dummy
      change_cipher_spec record (see the third paragraph of Section 5)      immediately before its second flight.  This may either be before      its second ClientHello or before its encrypted handshake flight.      If offering early data, the record is placed immediately after the      first ClientHello.
 
   -  The server sends a dummy change_cipher_spec record immediately      after its first handshake message.  This may either be after a      ServerHello or a HelloRetryRequest.
 
   When put together, these changes make the TLS 1.3 handshake resemble   TLS 1.2 session resumption, which improves the chance of successfully   connecting through middleboxes.  This "compatibility mode" is   partially negotiated: the client can opt to provide a session ID or   not, and the server has to echo it.  Either side can send</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   change_cipher_spec at any time during the handshake, as they must be   ignored by the peer, but if the client sends a non-empty session ID,   the server MUST send the change_cipher_spec as described in this   appendix.
 
D.5.  Security Restrictions Related to Backward Compatibility
 
   Implementations negotiating the use of older versions of TLS SHOULD   prefer forward secret and AEAD cipher suites, when available.
 
   The security of RC4 cipher suites is considered insufficient for the   reasons cited in [RFC7465].  Implementations MUST NOT offer or   negotiate RC4 cipher suites for any version of TLS for any reason.
 
   Old versions of TLS permitted the use of very low strength ciphers.   Ciphers with a strength less than 112 bits MUST NOT be offered or   negotiated for any version of TLS for any reason.
 
   The security of SSL 3.0 [RFC6101] is considered insufficient for the   reasons enumerated in [RFC7568], and it MUST NOT be negotiated for   any reason.
 
   The security of SSL 2.0 [SSL2] is considered insufficient for the   reasons enumerated in [RFC6176], and it MUST NOT be negotiated for   any reason.
 
   Implementations MUST NOT send an SSL version 2.0 compatible   CLIENT-HELLO.  Implementations MUST NOT negotiate TLS 1.3 or later   using an SSL version 2.0 compatible CLIENT-HELLO.  Implementations   are NOT RECOMMENDED to accept an SSL version 2.0 compatible   CLIENT-HELLO in order to negotiate older versions of TLS.
 
   Implementations MUST NOT send a ClientHello.legacy_version or   ServerHello.legacy_version set to 0x0300 or less.  Any endpoint   receiving a Hello message with ClientHello.legacy_version or   ServerHello.legacy_version set to 0x0300 MUST abort the handshake   with a "protocol_version" alert.
 
   Implementations MUST NOT send any records with a version less than   0x0300.  Implementations SHOULD NOT accept any records with a version   less than 0x0300 (but may inadvertently do so if the record version   number is ignored completely).
 
   Implementations MUST NOT use the Truncated HMAC extension, defined in   Section&nbsp;7 of [RFC6066], as it is not applicable to AEAD algorithms   and has been shown to be insecure in some scenarios.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
Appendix E.  Overview of Security Properties
 
   A complete security analysis of TLS is outside the scope of this   document.  In this appendix, we provide an informal description of   the desired properties as well as references to more detailed work in   the research literature which provides more formal definitions.
 
   We cover properties of the handshake separately from those of the   record layer.
 
E.1.  Handshake
 
   The TLS handshake is an Authenticated Key Exchange (AKE) protocol   which is intended to provide both one-way authenticated (server-only)   and mutually authenticated (client and server) functionality.  At the   completion of the handshake, each side outputs its view of the   following values:
 
   -  A set of "session keys" (the various secrets derived from the      master secret) from which can be derived a set of working keys.
 
   -  A set of cryptographic parameters (algorithms, etc.).
 
   -  The identities of the communicating parties.
 
   We assume the attacker to be an active network attacker, which means   it has complete control over the network used to communicate between   the parties [RFC3552].  Even under these conditions, the handshake   should provide the properties listed below.  Note that these   properties are not necessarily independent, but reflect the protocol   consumers' needs.
 
   Establishing the same session keys:  The handshake needs to output      the same set of session keys on both sides of the handshake,      provided that it completes successfully on each endpoint (see      [CK01], Definition 1, part 1).
 
   Secrecy of the session keys:  The shared session keys should be known      only to the communicating parties and not to the attacker (see      [CK01], Definition 1, part 2).  Note that in a unilaterally      authenticated connection, the attacker can establish its own      session keys with the server, but those session keys are distinct      from those established by the client.
 
   Peer authentication:  The client's view of the peer identity should      reflect the server's identity.  If the client is authenticated,      the server's view of the peer identity should match the client's      identity.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Uniqueness of the session keys:  Any two distinct handshakes should      produce distinct, unrelated session keys.  Individual session keys      produced by a handshake should also be distinct and independent.
 
   Downgrade protection:  The cryptographic parameters should be the      same on both sides and should be the same as if the peers had been      communicating in the absence of an attack (see [BBFGKZ16],      Definitions 8 and 9).
 
   Forward secret with respect to long-term keys:  If the long-term      keying material (in this case the signature keys in certificate-      based authentication modes or the external/resumption PSK in PSK      with (EC)DHE modes) is compromised after the handshake is      complete, this does not compromise the security of the session key      (see [DOW92]), as long as the session key itself has been erased.      The forward secrecy property is not satisfied when PSK is used in      the "psk_ke" PskKeyExchangeMode.
 
   Key Compromise Impersonation (KCI) resistance:  In a mutually      authenticated connection with certificates, compromising the      long-term secret of one actor should not break that actor's      authentication of their peer in the given connection (see      [HGFS15]).  For example, if a client's signature key is      compromised, it should not be possible to impersonate arbitrary      servers to that client in subsequent handshakes.
 
   Protection of endpoint identities:  The server's identity      (certificate) should be protected against passive attackers.  The      client's identity should be protected against both passive and      active attackers.
 
   Informally, the signature-based modes of TLS 1.3 provide for the   establishment of a unique, secret, shared key established by an   (EC)DHE key exchange and authenticated by the server's signature over   the handshake transcript, as well as tied to the server's identity by   a MAC.  If the client is authenticated by a certificate, it also   signs over the handshake transcript and provides a MAC tied to both   identities.  [SIGMA] describes the design and analysis of this type   of key exchange protocol.  If fresh (EC)DHE keys are used for each   connection, then the output keys are forward secret.
 
   The external PSK and resumption PSK bootstrap from a long-term shared   secret into a unique per-connection set of short-term session keys.   This secret may have been established in a previous handshake.  If   PSK with (EC)DHE key establishment is used, these session keys will   also be forward secret.  The resumption PSK has been designed so that   the resumption master secret computed by connection N and needed to   form connection N+1 is separate from the traffic keys used by</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   connection N, thus providing forward secrecy between the connections.   In addition, if multiple tickets are established on the same   connection, they are associated with different keys, so compromise of   the PSK associated with one ticket does not lead to the compromise of   connections established with PSKs associated with other tickets.   This property is most interesting if tickets are stored in a database   (and so can be deleted) rather than if they are self-encrypted.
 
   The PSK binder value forms a binding between a PSK and the current   handshake, as well as between the session where the PSK was   established and the current session.  This binding transitively   includes the original handshake transcript, because that transcript   is digested into the values which produce the resumption master   secret.  This requires that both the KDF used to produce the   resumption master secret and the MAC used to compute the binder be   collision resistant.  See Appendix E.1.1 for more on this.  Note: The   binder does not cover the binder values from other PSKs, though they   are included in the Finished MAC.
 
   TLS does not currently permit the server to send a
   certificate_request message in non-certificate-based handshakes   (e.g., PSK).  If this restriction were to be relaxed in future, the   client's signature would not cover the server's certificate directly.   However, if the PSK was established through a NewSessionTicket, the   client's signature would transitively cover the server's certificate   through the PSK binder.  [PSK-FINISHED] describes a concrete attack   on constructions that do not bind to the server's certificate (see   also [Kraw16]).  It is unsafe to use certificate-based client   authentication when the client might potentially share the same   PSK/key-id pair with two different endpoints.  Implementations   MUST NOT combine external PSKs with certificate-based authentication   of either the client or the server unless negotiated by some   extension.
 
   If an exporter is used, then it produces values which are unique and   secret (because they are generated from a unique session key).   Exporters computed with different labels and contexts are   computationally independent, so it is not feasible to compute one   from another or the session secret from the exported value.   Note: Exporters can produce arbitrary-length values; if exporters are   to be used as channel bindings, the exported value MUST be large   enough to provide collision resistance.  The exporters provided in   TLS 1.3 are derived from the same Handshake Contexts as the early   traffic keys and the application traffic keys, respectively, and thus   have similar security properties.  Note that they do not include the   client's certificate; future applications which wish to bind to the   client's certificate may need to define a new exporter that includes   the full handshake transcript.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   For all handshake modes, the Finished MAC (and, where present, the   signature) prevents downgrade attacks.  In addition, the use of   certain bytes in the random nonces as described in Section 4.1.3   allows the detection of downgrade to previous TLS versions.  See   [BBFGKZ16] for more details on TLS 1.3 and downgrade.
 
   As soon as the client and the server have exchanged enough   information to establish shared keys, the remainder of the handshake   is encrypted, thus providing protection against passive attackers,   even if the computed shared key is not authenticated.  Because the   server authenticates before the client, the client can ensure that if   it authenticates to the server, it only reveals its identity to an   authenticated server.  Note that implementations must use the   provided record-padding mechanism during the handshake to avoid   leaking information about the identities due to length.  The client's   proposed PSK identities are not encrypted, nor is the one that the   server selects.
 
E.1.1.  Key Derivation and HKDF
 
   Key derivation in TLS 1.3 uses HKDF as defined in [RFC5869] and its   two components, HKDF-Extract and HKDF-Expand.  The full rationale for   the HKDF construction can be found in [Kraw10] and the rationale for   the way it is used in TLS 1.3 in [KW16].  Throughout this document,   each application of HKDF-Extract is followed by one or more   invocations of HKDF-Expand.  This ordering should always be followed   (including in future revisions of this document); in particular, one   SHOULD NOT use an output of HKDF-Extract as an input to another   application of HKDF-Extract without an HKDF-Expand in between.   Multiple applications of HKDF-Expand to some of the same inputs are   allowed as long as these are differentiated via the key and/or the   labels.
 
   Note that HKDF-Expand implements a pseudorandom function (PRF) with   both inputs and outputs of variable length.  In some of the uses of   HKDF in this document (e.g., for generating exporters and the   resumption_master_secret), it is necessary that the application of   HKDF-Expand be collision resistant; namely, it should be infeasible   to find two different inputs to HKDF-Expand that output the same   value.  This requires the underlying hash function to be collision   resistant and the output length from HKDF-Expand to be of size at   least 256 bits (or as much as needed for the hash function to prevent   finding collisions).</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
E.1.2.  Client Authentication
 
   A client that has sent authentication data to a server, either during   the handshake or in post-handshake authentication, cannot be sure   whether the server afterwards considers the client to be   authenticated or not.  If the client needs to determine if the server   considers the connection to be unilaterally or mutually   authenticated, this has to be provisioned by the application layer.   See [CHHSV17] for details.  In addition, the analysis of   post-handshake authentication from [Kraw16] shows that the client   identified by the certificate sent in the post-handshake phase   possesses the traffic key.  This party is therefore the client that   participated in the original handshake or one to whom the original   client delegated the traffic key (assuming that the traffic key has   not been compromised).
 
E.1.3.  0-RTT
 
   The 0-RTT mode of operation generally provides security properties   similar to those of 1-RTT data, with the two exceptions that the   0-RTT encryption keys do not provide full forward secrecy and that   the server is not able to guarantee uniqueness of the handshake   (non-replayability) without keeping potentially undue amounts of   state.  See Section 8 for mechanisms to limit the exposure to replay.
 
E.1.4.  Exporter Independence
 
   The exporter_master_secret and early_exporter_master_secret are   derived to be independent of the traffic keys and therefore do not   represent a threat to the security of traffic encrypted with those   keys.  However, because these secrets can be used to compute any   exporter value, they SHOULD be erased as soon as possible.  If the   total set of exporter labels is known, then implementations SHOULD   pre-compute the inner Derive-Secret stage of the exporter computation   for all those labels, then erase the [early_]exporter_master_secret,   followed by each inner value as soon as it is known that it will not   be needed again.
 
E.1.5.  Post-Compromise Security
 
   TLS does not provide security for handshakes which take place after   the peer's long-term secret (signature key or external PSK) is   compromised.  It therefore does not provide post-compromise security   [CCG16], sometimes also referred to as backward or future secrecy.   This is in contrast to KCI resistance, which describes the security   guarantees that a party has after its own long-term secret has been   compromised.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
E.1.6.  External References
 
   The reader should refer to the following references for analysis of   the TLS handshake: [DFGS15], [CHSV16], [DFGS16], [KW16], [Kraw16],   [FGSW16], [LXZFH16], [FG17], and [BBK17].
 
E.2.  Record Layer
 
   The record layer depends on the handshake producing strong traffic   secrets which can be used to derive bidirectional encryption keys and   nonces.  Assuming that is true, and the keys are used for no more   data than indicated in Section 5.5, then the record layer should   provide the following guarantees:
 
   Confidentiality:  An attacker should not be able to determine the      plaintext contents of a given record.
 
   Integrity:  An attacker should not be able to craft a new record      which is different from an existing record which will be accepted      by the receiver.
 
   Order protection/non-replayability:  An attacker should not be able      to cause the receiver to accept a record which it has already      accepted or cause the receiver to accept record N+1 without having      first processed record N.
 
   Length concealment:  Given a record with a given external length, the      attacker should not be able to determine the amount of the record      that is content versus padding.
 
   Forward secrecy after key change:  If the traffic key update      mechanism described in Section 4.6.3 has been used and the      previous generation key is deleted, an attacker who compromises      the endpoint should not be able to decrypt traffic encrypted with      the old key.
 
   Informally, TLS 1.3 provides these properties by AEAD-protecting the   plaintext with a strong key.  AEAD encryption [RFC5116] provides   confidentiality and integrity for the data.  Non-replayability is   provided by using a separate nonce for each record, with the nonce   being derived from the record sequence number (Section 5.3), with the   sequence number being maintained independently at both sides; thus,   records which are delivered out of order result in AEAD deprotection   failures.  In order to prevent mass cryptanalysis when the same   plaintext is repeatedly encrypted by different users under the same   key (as is commonly the case for HTTP), the nonce is formed by mixing</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   the sequence number with a secret per-connection initialization   vector derived along with the traffic keys.  See [BT16] for analysis   of this construction.
 
   The rekeying technique in TLS 1.3 (see Section 7.2) follows the   construction of the serial generator as discussed in [REKEY], which   shows that rekeying can allow keys to be used for a larger number of   encryptions than without rekeying.  This relies on the security of   the HKDF-Expand-Label function as a pseudorandom function (PRF).  In   addition, as long as this function is truly one way, it is not   possible to compute traffic keys from prior to a key change (forward   secrecy).
 
   TLS does not provide security for data which is communicated on a   connection after a traffic secret of that connection is compromised.   That is, TLS does not provide post-compromise security/future   secrecy/backward secrecy with respect to the traffic secret.  Indeed,   an attacker who learns a traffic secret can compute all future   traffic secrets on that connection.  Systems which want such   guarantees need to do a fresh handshake and establish a new   connection with an (EC)DHE exchange.
 
E.2.1.  External References
 
   The reader should refer to the following references for analysis of   the TLS record layer: [BMMRT15], [BT16], [BDFKPPRSZZ16], [BBK17], and   [PS18].
 
E.3.  Traffic Analysis
 
   TLS is susceptible to a variety of traffic analysis attacks based on   observing the length and timing of encrypted packets [CLINIC]   [HCJC16].  This is particularly easy when there is a small set of   possible messages to be distinguished, such as for a video server   hosting a fixed corpus of content, but still provides usable   information even in more complicated scenarios.
 
   TLS does not provide any specific defenses against this form of   attack but does include a padding mechanism for use by applications:   The plaintext protected by the AEAD function consists of content plus   variable-length padding, which allows the application to produce   arbitrary-length encrypted records as well as padding-only cover   traffic to conceal the difference between periods of transmission and   periods of silence.  Because the padding is encrypted alongside the   actual content, an attacker cannot directly determine the length of   the padding but may be able to measure it indirectly by the use of   timing channels exposed during record processing (i.e., seeing how   long it takes to process a record or trickling in records to see</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   which ones elicit a response from the server).  In general, it is not   known how to remove all of these channels because even a   constant-time padding removal function will likely feed the content   into data-dependent functions.  At minimum, a fully constant-time   server or client would require close cooperation with the   application-layer protocol implementation, including making that   higher-level protocol constant time.
 
   Note: Robust traffic analysis defenses will likely lead to inferior   performance due to delays in transmitting packets and increased   traffic volume.
 
E.4.  Side-Channel Attacks
 
   In general, TLS does not have specific defenses against side-channel   attacks (i.e., those which attack the communications via secondary   channels such as timing), leaving those to the implementation of the   relevant cryptographic primitives.  However, certain features of TLS   are designed to make it easier to write side-channel resistant code:
 
   -  Unlike previous versions of TLS which used a composite MAC-then-      encrypt structure, TLS 1.3 only uses AEAD algorithms, allowing      implementations to use self-contained constant-time      implementations of those primitives.
 
   -  TLS uses a uniform "bad_record_mac" alert for all decryption      errors, which is intended to prevent an attacker from gaining      piecewise insight into portions of the message.  Additional      resistance is provided by terminating the connection on such      errors; a new connection will have different cryptographic      material, preventing attacks against the cryptographic primitives      that require multiple trials.
 
   Information leakage through side channels can occur at layers above   TLS, in application protocols and the applications that use them.   Resistance to side-channel attacks depends on applications and   application protocols separately ensuring that confidential   information is not inadvertently leaked.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
E.5.  Replay Attacks on 0-RTT
 
   Replayable 0-RTT data presents a number of security threats to TLS-   using applications, unless those applications are specifically   engineered to be safe under replay (minimally, this means idempotent,   but in many cases may also require other stronger conditions, such as   constant-time response).  Potential attacks include:
 
   -  Duplication of actions which cause side effects (e.g., purchasing      an item or transferring money) to be duplicated, thus harming the      site or the user.
 
   -  Attackers can store and replay 0-RTT messages in order to reorder      them with respect to other messages (e.g., moving a delete to      after a create).
 
   -  Exploiting cache timing behavior to discover the content of 0-RTT      messages by replaying a 0-RTT message to a different cache node      and then using a separate connection to measure request latency,      to see if the two requests address the same resource.
 
   If data can be replayed a large number of times, additional attacks   become possible, such as making repeated measurements of the speed of   cryptographic operations.  In addition, they may be able to overload   rate-limiting systems.  For a further description of these attacks,   see [Mac17].
 
   Ultimately, servers have the responsibility to protect themselves   against attacks employing 0-RTT data replication.  The mechanisms   described in Section 8 are intended to prevent replay at the TLS   layer but do not provide complete protection against receiving   multiple copies of client data.  TLS 1.3 falls back to the 1-RTT   handshake when the server does not have any information about the   client, e.g., because it is in a different cluster which does not   share state or because the ticket has been deleted as described in   Section 8.1.  If the application-layer protocol retransmits data in   this setting, then it is possible for an attacker to induce message   duplication by sending the ClientHello to both the original cluster   (which processes the data immediately) and another cluster which will   fall back to 1-RTT and process the data upon application-layer   replay.  The scale of this attack is limited by the client's   willingness to retry transactions and therefore only allows a limited   amount of duplication, with each copy appearing as a new connection   at the server.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   If implemented correctly, the mechanisms described in Sections 8.1   and 8.2 prevent a replayed ClientHello and its associated 0-RTT data   from being accepted multiple times by any cluster with consistent   state; for servers which limit the use of 0-RTT to one cluster for a   single ticket, then a given ClientHello and its associated 0-RTT data   will only be accepted once.  However, if state is not completely   consistent, then an attacker might be able to have multiple copies of   the data be accepted during the replication window.  Because clients   do not know the exact details of server behavior, they MUST NOT send   messages in early data which are not safe to have replayed and which   they would not be willing to retry across multiple 1-RTT connections.
 
   Application protocols MUST NOT use 0-RTT data without a profile that   defines its use.  That profile needs to identify which messages or   interactions are safe to use with 0-RTT and how to handle the   situation when the server rejects 0-RTT and falls back to 1-RTT.
 
   In addition, to avoid accidental misuse, TLS implementations MUST NOT   enable 0-RTT (either sending or accepting) unless specifically   requested by the application and MUST NOT automatically resend 0-RTT   data if it is rejected by the server unless instructed by the   application.  Server-side applications may wish to implement special   processing for 0-RTT data for some kinds of application traffic   (e.g., abort the connection, request that data be resent at the   application layer, or delay processing until the handshake   completes).  In order to allow applications to implement this kind of   processing, TLS implementations MUST provide a way for the   application to determine if the handshake has completed.
 
E.5.1.  Replay and Exporters
 
   Replays of the ClientHello produce the same early exporter, thus   requiring additional care by applications which use these exporters.   In particular, if these exporters are used as an authentication   channel binding (e.g., by signing the output of the exporter), an   attacker who compromises the PSK can transplant authenticators   between connections without compromising the authentication key.
 
   In addition, the early exporter SHOULD NOT be used to generate   server-to-client encryption keys because that would entail the reuse   of those keys.  This parallels the use of the early application   traffic keys only in the client-to-server direction.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
E.6.  PSK Identity Exposure
 
   Because implementations respond to an invalid PSK binder by aborting   the handshake, it may be possible for an attacker to verify whether a   given PSK identity is valid.  Specifically, if a server accepts both   external-PSK handshakes and certificate-based handshakes, a valid PSK   identity will result in a failed handshake, whereas an invalid   identity will just be skipped and result in a successful certificate   handshake.  Servers which solely support PSK handshakes may be able   to resist this form of attack by treating the cases where there is no   valid PSK identity and where there is an identity but it has an   invalid binder identically.
 
E.7.  Sharing PSKs
 
   TLS 1.3 takes a conservative approach to PSKs by binding them to a   specific KDF.  By contrast, TLS 1.2 allows PSKs to be used with any   hash function and the TLS 1.2 PRF.  Thus, any PSK which is used with   both TLS 1.2 and TLS 1.3 must be used with only one hash in TLS 1.3,   which is less than optimal if users want to provision a single PSK.   The constructions in TLS 1.2 and TLS 1.3 are different, although they   are both based on HMAC.  While there is no known way in which the   same PSK might produce related output in both versions, only limited   analysis has been done.  Implementations can ensure safety from   cross-protocol related output by not reusing PSKs between TLS 1.3 and   TLS 1.2.
 
E.8.  Attacks on Static RSA
 
   Although TLS 1.3 does not use RSA key transport and so is not   directly susceptible to Bleichenbacher-type attacks [Blei98], if TLS   1.3 servers also support static RSA in the context of previous   versions of TLS, then it may be possible to impersonate the server   for TLS 1.3 connections [JSS15].  TLS 1.3 implementations can prevent   this attack by disabling support for static RSA across all versions   of TLS.  In principle, implementations might also be able to separate   certificates with different keyUsage bits for static RSA decryption   and RSA signature, but this technique relies on clients refusing to   accept signatures using keys in certificates that do not have the   digitalSignature bit set, and many clients do not enforce this   restriction.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
Contributors
 
   Martin Abadi
   University of California, Santa Cruz
   abadi@cs.ucsc.edu
 
   Christopher Allen
   (co-editor of TLS 1.0)
   Alacrity Ventures
   ChristopherA@AlacrityManagement.com
 
   Richard Barnes
   Cisco
   rlb@ipv.sx
 
   Steven M. Bellovin
   Columbia University
   smb@cs.columbia.edu
 
   David Benjamin
   Google
   davidben@google.com
 
   Benjamin Beurdouche
   INRIA &amp; Microsoft Research
   benjamin.beurdouche@ens.fr
 
   Karthikeyan Bhargavan
   (editor of [RFC7627])
   INRIA
   karthikeyan.bhargavan@inria.fr
 
   Simon Blake-Wilson
   (co-author of [RFC4492])
   BCI
   sblakewilson@bcisse.com
 
   Nelson Bolyard
   (co-author of [RFC4492])
   Sun Microsystems, Inc.
   nelson@bolyard.com
 
   Ran Canetti
   IBM
   canetti@watson.ibm.com</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Matt Caswell
   OpenSSL
   matt@openssl.org
 
   Stephen Checkoway
   University of Illinois at Chicago
   sfc@uic.edu
 
   Pete Chown
   Skygate Technology Ltd
   pc@skygate.co.uk
 
   Katriel Cohn-Gordon
   University of Oxford
   me@katriel.co.uk
 
   Cas Cremers
   University of Oxford
   cas.cremers@cs.ox.ac.uk
 
   Antoine Delignat-Lavaud
   (co-author of [RFC7627])
   INRIA
   antdl@microsoft.com
 
   Tim Dierks
   (co-author of TLS 1.0, co-editor of TLS 1.1 and 1.2)
   Independent
   tim@dierks.org
 
   Roelof DuToit
   Symantec Corporation
   roelof_dutoit@symantec.com
 
   Taher Elgamal
   Securify
   taher@securify.com
 
   Pasi Eronen
   Nokia
   pasi.eronen@nokia.com
 
   Cedric Fournet
   Microsoft
   fournet@microsoft.com</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Anil Gangolli
   anil@busybuddha.org
 
   David M. Garrett
   dave@nulldereference.com
 
   Illya Gerasymchuk
   Independent
   illya@iluxonchik.me
 
   Alessandro Ghedini
   Cloudflare Inc.
   alessandro@cloudflare.com
 
   Daniel Kahn Gillmor
   ACLU
   dkg@fifthhorseman.net
 
   Matthew Green
   Johns Hopkins University
   mgreen@cs.jhu.edu
 
   Jens Guballa
   ETAS
   jens.guballa@etas.com
 
   Felix Guenther
   TU Darmstadt
   mail@felixguenther.info
 
   Vipul Gupta
   (co-author of [RFC4492])
   Sun Microsystems Laboratories
   vipul.gupta@sun.com
 
   Chris Hawk
   (co-author of [RFC4492])
   Corriente Networks LLC
   chris@corriente.net
 
   Kipp Hickman
 
   Alfred Hoenes
 
   David Hopwood
   Independent Consultant
   david.hopwood@blueyonder.co.uk</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Marko Horvat
   MPI-SWS
   mhorvat@mpi-sws.org
 
   Jonathan Hoyland
   Royal Holloway, University of London
   jonathan.hoyland@gmail.com
 
   Subodh Iyengar
   Facebook
   subodh@fb.com
 
   Benjamin Kaduk
   Akamai Technologies
   kaduk@mit.edu
 
   Hubert Kario
   Red Hat Inc.
   hkario@redhat.com
 
   Phil Karlton
   (co-author of SSL 3.0)
 
   Leon Klingele
   Independent
   mail@leonklingele.de
 
   Paul Kocher
   (co-author of SSL 3.0)
   Cryptography Research
   paul@cryptography.com
 
   Hugo Krawczyk
   IBM
   hugokraw@us.ibm.com
 
   Adam Langley
   (co-author of [RFC7627])
   Google
   agl@google.com
 
   Olivier Levillain
   ANSSI
   olivier.levillain@ssi.gouv.fr</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Xiaoyin Liu
   University of North Carolina at Chapel Hill
   xiaoyin.l@outlook.com
 
   Ilari Liusvaara
   Independent
   ilariliusvaara@welho.com
 
   Atul Luykx
   K.U. Leuven
   atul.luykx@kuleuven.be
 
   Colm MacCarthaigh
   Amazon Web Services
   colm@allcosts.net
 
   Carl Mehner
   USAA
   carl.mehner@usaa.com
 
   Jan Mikkelsen
   Transactionware
   janm@transactionware.com
 
   Bodo Moeller
   (co-author of [RFC4492])
   Google
   bodo@acm.org
 
   Kyle Nekritz
   Facebook
   knekritz@fb.com
 
   Erik Nygren
   Akamai Technologies
   erik+ietf@nygren.org
 
   Magnus Nystrom
   Microsoft
   mnystrom@microsoft.com
 
   Kazuho Oku
   DeNA Co., Ltd.
   kazuhooku@gmail.com</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Kenny Paterson
   Royal Holloway, University of London
   kenny.paterson@rhul.ac.uk
 
   Christopher Patton
   University of Florida
   cjpatton@ufl.edu
 
   Alfredo Pironti
   (co-author of [RFC7627])
   INRIA
   alfredo.pironti@inria.fr
 
   Andrei Popov
   Microsoft
   andrei.popov@microsoft.com
 
   Marsh Ray
   (co-author of [RFC7627])
   Microsoft
   maray@microsoft.com
 
   Robert Relyea
   Netscape Communications
   relyea@netscape.com
 
   Kyle Rose
   Akamai Technologies
   krose@krose.org
 
   Jim Roskind
   Amazon
   jroskind@amazon.com
 
   Michael Sabin
 
   Joe Salowey
   Tableau Software
   joe@salowey.net
 
   Rich Salz
   Akamai
   rsalz@akamai.com
 
   David Schinazi
   Apple Inc.
   dschinazi@apple.com</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Sam Scott
   Royal Holloway, University of London
   me@samjs.co.uk
 
   Thomas Shrimpton
   University of Florida
   teshrim@ufl.edu
 
   Dan Simon
   Microsoft, Inc.
   dansimon@microsoft.com
 
   Brian Smith
   Independent
   brian@briansmith.org
 
   Brian Sniffen
   Akamai Technologies
   ietf@bts.evenmere.org
 
   Nick Sullivan
   Cloudflare Inc.
   nick@cloudflare.com
 
   Bjoern Tackmann
   University of California, San Diego
   btackmann@eng.ucsd.edu
 
   Tim Taubert
   Mozilla
   ttaubert@mozilla.com
 
   Martin Thomson
   Mozilla
   mt@mozilla.com
 
   Hannes Tschofenig
   Arm Limited
   Hannes.Tschofenig@arm.com
 
   Sean Turner
   sn3rd
   sean@sn3rd.com
 
   Steven Valdez
   Google
   svaldez@google.com</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Filippo Valsorda
   Cloudflare Inc.
   filippo@cloudflare.com
 
   Thyla van der Merwe
   Royal Holloway, University of London
   tjvdmerwe@gmail.com
 
   Victor Vasiliev
   Google
   vasilvv@google.com
 
   Hoeteck Wee
   Ecole Normale Superieure, Paris
   hoeteck@alum.mit.edu
 
   Tom Weinstein
 
   David Wong
   NCC Group
   david.wong@nccgroup.trust
 
   Christopher A. Wood
   Apple Inc.
   cawood@apple.com
 
   Tim Wright
   Vodafone
   timothy.wright@vodafone.com
 
   Peter Wu
   Independent
   peter@lekensteyn.nl
 
   Kazu Yamamoto
   Internet Initiative Japan Inc.
   kazu@iij.ad.jp
 
Author's Address
 
   Eric Rescorla
   Mozilla
 
   Email: ekr@rtfm.com
 

 

 

 
</pre><br>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.129c, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>
