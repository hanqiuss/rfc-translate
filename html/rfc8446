<div class="content" style="float: left; margin: 0px 30%; width: 579px; font-size: 10pt;">
   <div style="height: 13px;">
      <div onmouseover="this.style.cursor='pointer';" onclick="showElem('legend');" onmouseout="hideElem('legend')" style="height: 6px; position: absolute; cursor: pointer;" class="pre noprint docinfo bgblue" title="Click for colour legend.">                                                                        </div>
      <div id="legend" class="docinfo noprint pre legend" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; " onmouseover="showElem('legend');" onmouseout="hideElem('legend');">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="../html/" title="Document search and retrieval page">Docs</a>] [<a href="/rfc/rfc8446.txt" title="Plaintext version of this document">txt</a>|<a href="/pdf/rfc8446" title="PDF version of this document">pdf</a>] [<a href="./draft-ietf-tls-tls13" title="draft-ietf-tls-tls13">draft-ietf-tls-...</a>] [<a href="https://datatracker.ietf.org/doc/rfc8446" title="IESG Datatracker information for this document">Tracker</a>] [<a href="/rfcdiff?difftype=--hwdiff&amp;url2=rfc8446" title="Inline diff (wdiff)">Diff1</a>] [<a href="/rfcdiff?url2=rfc8446" title="Side-by-side diff">Diff2</a>] [<a href="https://datatracker.ietf.org/ipr/search/?rfc=8446&amp;submit=rfc" title="IPR disclosures related to this document">IPR</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=8446">Errata</a>]</span><br>
<span class="pre noprint docinfo">                                                                        </span><br>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br>
<pre style="height: 780px; white-space: pre-wrap;">Internet Engineering Task Force (IETF)                       E. Rescorla
Request for Comments: 8446                                       Mozilla
Obsoletes: 5077, 5246, 6961                                  August 2018
Updates: 5705, 6066
类别: 标准跟踪
ISSN: 2070-1721
 

        The Transport Layer Security (TLS) Protocol Version 1.3
 
摘要
 
   本文档规定了传输层安全(TLS)协议的1.3版。TLS允许客户端/服务器应用程序通过
   Internet以一种旨在防止窃听、篡改和消息伪造的方式进行通信。
 
   本文档更新了RFC 5705和6066，并废弃了RFC 5077、5246和6961。本文档还指定了
   TLS 1.2实现的新要求。
 
备忘录状态
 
   这是Internet标准跟踪文档。
 
   本文档是Internet工程任务组(IETF)的产品。它代表了IETF社区的共识。它已经接受了
   公众的审查，并已被互联网工程指导小组(IESG)批准出版。有关Internet标准的更多信息，
   请参阅 RFC 7841 的第2节。
 
   有关本文档的当前状态、任何勘误表以及如何提供反馈的信息，请访问。
   https://www.rfc-editor.org/info/rfc8446.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
Copyright Notice

   Copyright (c) 2018 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (https://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
目录
 <p style="font-family: 新宋体;">
   1. 简介         ....................................................6
      1.1. 公约和术语                  ................................7
      1.2. 与 TLS 1.2 的主要区别          .............................8
      1.3. 影响 TLS 1.2 的更新       ..................................9
   2. 协议概述          ..............................................10
      2.1. 不正确的 DHE 共享   .......................................14
      2.2. 恢复和预共享密钥(PSK)               .......................15
      2.3. 0-RTT数据  ................................................17
   3. 演示语言              ..........................................19
      3.1. 基本块大小       ..........................................19
      3.2. 杂项          .............................................20
      3.3. 数字    ...................................................20
      3.4. 向量    ...................................................20
      3.5. 枚举        ...............................................21
      3.6. 构造类型          .........................................22
      3.7. 常量      .................................................23
      3.8. 变体     ..................................................23
   4. 握手协议           .............................................24
      4.1. 密钥交换消息          .....................................25
           4.1.1. 加密协商                  ..........................26
           4.1.2. Client Hello .......................................27
           4.1.3. Server Hello .......................................31
           4.1.4. Hello重试请求       ................................33
      4.2. 扩展       ................................................35
           4.2.1. 支持的版本         .................................39
           4.2.2. Cookie .............................................40
           4.2.3. 签名算法             ...............................41
           4.2.4. 证书颁发机构            ............................45
           4.2.5. OID过滤器   ........................................45
           4.2.6. 握手后客户端身份验证                 ...............47
           4.2.7. 支持的组         ...................................47
           4.2.8. 密钥共享  ..........................................48
           4.2.9. 预共享密钥交换模式            ......................51
           4.2.10. 早期数据指示          .............................52
           4.2.11. 预共享密钥扩展           ..........................55
      4.3. 服务器参数        .........................................59
           4.3.1. 加密扩展             ...............................60
           4.3.2. 证书请求            ................................60
      4.4. 身份验证消息            ...................................61
           4.4.1. The Transcript Hash ................................63
           4.4.2. Certificate ........................................64
           4.4.3. Certificate Verify .................................69
           4.4.4. Finished ...........................................71
      4.5. 早期数据结束      .........................................72
</p></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

  <p style="font-family: 新宋体;">
      4.6. 握手后消息              ...................................73
           4.6.1. 新会话票证消息             .........................73
           4.6.2. 握手后身份验证                ......................75
           4.6.3. 密钥和初始化矢量更新                 ...............76
   5. 记录协议        ................................................77
      5.1. 记录层       ..............................................78
      5.2. 记录有效负载保护          .................................80
      5.3. Per-Record随机数 ..........................................82
      5.4. Record 填充    ............................................83
      5.5. 密钥使用限制        .......................................84
   6. 警报协议       .................................................85
      6.1. 关闭警报       ............................................87
      6.2. 错误警报     ..............................................88
   7. 密码计算                   .....................................90
      7.1. 密钥明细表   ..............................................91
      7.2. 更新流通密码             ..................................94
      7.3. 流通密码计算            ...................................95
      7.4. (EC)DHE共享密钥计算               .........................95
           7.4.1. 有限域Diffie-Hellman        ........................95
           7.4.2. 椭圆曲线Diffie-Hellman        ......................96
      7.5. 导出器    .................................................97
   8. 0-RTT 和防重放        ..........................................98
      8.1. 单次票据           ........................................99
      8.2. Client Hello Recording ....................................99
      8.3. Freshness Checks .........................................101
   9. 合规要求                .......................................102
      9.1. 强制实施密码套件                     .....................102
      9.2. 强制实施扩展                      ........................103
      9.3. 协议不变量          ......................................104
   10. 安全注意事项            ......................................106
   11. IANA 注意事项       ..........................................106
   12. 参考       ...................................................109
      12.1. 标准参考             ....................................109
      12.2. 信息参考               ..................................112
   附录 A. 状态机            ........................................120
     A.1. Client ....................................................120
     A.2. Server ....................................................121
   附录B. 协议数据结构和常量值                              .........122
     B.1. Record Layer ..............................................122
     B.2. Alert Messages ............................................123
     B.3. Handshake Protocol ........................................124
       B.3.1. Key Exchange Messages .................................125
       B.3.2. Server Parameters Messages ............................131
       B.3.3. Authentication Messages ...............................132
       B.3.4. Ticket Establishment ..................................132
       B.3.5. Updating Keys .........................................133
     B.4. Cipher Suites .............................................133
</p></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

  <p style="font-family: 新宋体;">
   附录C. 实施说明                  .................................134
     C.1. 随机数生成和种子                     ......................134
     C.2. 证书和身份验证                  ...........................135
     C.3. 实施陷阱                ...................................135
     C.4. 客户跟踪预防               ................................137
     C.5. 未经认证的操作            .................................137
   附录D. 向后兼容性                  ...............................138
     D.1. 与旧服务器协商                   ..........................139
     D.2. 与旧客户端协商                   ..........................139
     D.3. 0-RTT 向后兼容性             ..............................140
     D.4. 中间盒兼容模式               ..............................140
     D.5. 与向后兼容性相关的安全限制                    .............141
   附录E. 安全属性概述                         ......................142
     E.1. 握手      .................................................142
       E.1.1. 密钥推导和HKDF          ...............................145
       E.1.2. 客户端身份验证        .................................146
       E.1.3. 0-RTT .................................................146
       E.1.4. Exporter Independence .................................146
       E.1.5. 妥协后的安全             ..............................146
       E.1.6. 外部参考            ...................................147
     E.2. 记录层       ..............................................147
       E.2.1. 外部参考            ...................................148
     E.3. 流量分析         ..........................................148
     E.4. 旁路攻击             ......................................149
     E.5. 0-RTT上的重播攻击       ...................................150
       E.5.1. 回放和导出器         ..................................151
     E.6. PSK身份暴露           .....................................152
     E.7. 共享PSK      ..............................................152
     E.8. 对静态 RSA 的攻击     .....................................152
   贡献者       .....................................................153
   Author's Address .................................................160
</p></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
1.  简介
 
   TLS的主要目标是在两个通信对等体之间提供安全通道；底层传输的唯一要求是可靠、有序的
   数据流。具体地说，安全通道应提供以下属性：
 
   -  身份验证: 通道的服务器端始终经过身份验证;客户端是可选的身份验证。身份验证可以
      通过非对称加密（例如，RSA [RSA]、椭圆曲线数字签名算法 （ECDSA） [ECDSA] 或
      Edwards-Curve曲线数字签名算法 （EdSA） [RFC8032]） 或对称预共享密钥
     （PSK） 进行。
 
   -  机密性: 建立后通过通道发送的数据只对端点可见。TLS不会隐藏它传输的数据的长度，
      尽管端点可以填充TLS记录，以掩盖长度并改进针对流量分析技术的保护。
 
   -  完整性: 在建立后通过通道发送的数据，攻击者对其进行修改会被发现。
 
   即使面对完全控制网络的攻击者，这些属性也应该是正确的，如[RFC3552]中所述。有关安全
   属性的更完整声明，请参见附录E。
 
   TLS由两个主要组件组成：
 
   -  握手协议(第4节)，用于验证通信方，协商加密模式和参数，并建立共享密钥材料。握手
      协议旨在抵抗篡改；主动攻击者不应能够强制对等协商与未受到攻击时协商的连接参数
     不同的参数。
 
   -  记录协议(第5节)，使用握手协议建立的参数来保护通信对等体之间的流量。记录协议
      将流量划分为一系列记录，每个记录使用流量密钥独立保护。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   TLS是独立于应用协议的；更高级别的协议可以透明地叠加在TLS之上。然而，TLS标准没有
   指定协议如何使用TLS增加安全性；如何启动TLS握手以及如何解释交换的认证证书，留给
   运行在TLS之上的协议的设计者和实现者来判断。
 
   本文档定义了 TLS 1.3 版。虽然 TLS 1.3 不直接与以前的版本兼容，但TLS的所有版本
   都包含了一个版本控制机制，该机制允许客户端和服务器互操作地协商一个共同的版本(如果
   两个对等体都支持一个版本)。
 
   本文档取代并废弃了TLS的以前版本，包括版本 1.2[RFC5246]。它还废弃了[RFC5077]中
   定义的TLS票证机制，并用2.2节中定义的机制取代了它。由于 TLS 1.3 更改了派生密钥的
   方式，因此它会更新[RFC5705]，如7.5节所述。它还改变了在线证书状态协议(OCSP)消息
   的携带方式，因此更新[RFC6066]并废弃[RFC6961]，如第4.4.2.1节所述。
 
1.1.  约定和术语
 
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and   "OPTIONAL" in this document are to be interpreted as described in   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all   capitals, as shown here.
 
   使用以下术语：
 
   客户端：发起TLS连接的端点。
 
   连接：两个端点之间的传输层连接。
 
   端点：连接的客户端或服务器。
 
   握手：客户端和服务器之间的初始协商，用于在TLS内建立其后续交互的参数。
 
   Peer：端点。当讨论特定端点时，“对等”指的是非主要讨论主题的端点。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   接收方：接收记录的端点。
 
   发送方：正在传输记录的端点。
 
   服务器：非启动TLS连接的端点。
 
1.2.  与TLS 1.2的主要区别
 
   以下是 TLS 1.2 和 TLS 1.3 之间主要功能差异的列表。 它不是详尽无遗的，还有许多
   细微的差别。
 
   -  已删除支持的对称加密算法列表中所有被视为遗留的算法。剩下的都是带关联数据的认证
      加密(AEAD)算法。密码套件的概念已经改变，以将认证和密钥交换机制与记录保护算法
     (包括秘密密钥长度)和散列分开，以便与密钥导出函数和握手消息认证码(MAC)一起使用。
 
   -  添加了零往返时间(0-RTT)模式，节省了某些应用数据的连接建立时的往返行程，但代价
      是某些安全属性。
 
   -  静态RSA和Diffie-Hellman密码套件已被删除；所有基于公钥的密钥交换机制现在都
      提供向前保密。
 
   -  ServerHello之后的所有握手消息现在都已加密。新引入的加密扩展消息允许以前在
      ServerHello中明文发送的各种扩展也享有机密性保护。
 
   -  重新设计了密钥派生函数。由于其改进的密钥分离特性，新的设计允许密码学家更容易
      进行分析。基于HMAC的提取和扩展密钥导出函数(HKDF)用作底层原语。
 
   -  握手状态机进行了显著的重构，使其更加一致，并去除了ChangeCipherSpec等多余的
      消息(中间盒兼容性需要时除外)。
 
   -  椭圆曲线算法现在基础规范中，并且包括了新的签名算法，例如EdDSA。TLS 1.3 删除
      了点格式协商，支持每条曲线的单点格式。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   -  进行了其他加密改进，包括更改RSA填充以使用RSA概率签名方案(RSASSA-PSS)，以及
      删除压缩、数字签名算法(DSA)和自定义临时Diffie-Hellman(DHE)组。
 
   -  TLS 1.2版本协商机制已被弃用，取而代之的是扩展中的版本列表。这增加了与不正确
      实现版本协商的现有服务器的兼容性。
 
   -  具有服务器端状态和无服务器端状态的会话恢复以及早期 TLS 版本的基于 PSK 的密码
      套件已被单个新的 PSK 交换所取代。
 
   -  参考资料已适当更新，指向RFC的更新版本(例如，RFC 5280而不是RFC 3280)。
 
1.3.  影响TLS 1.2的更新
 
   本文档定义了几个有选择地影响TLS 1.2实现的更改，包括那些也不支持TLS 1.3的更改：
 
   -  版本降级保护机制在第 4.1.3 节中介绍。
 
   -  RSASSA-PSS 签名方案在第 4.2.3 节中定义。
 
   -  “Supported_Versions”ClientHello扩展可用于协商要使用的TLS版本，优先于
      ClientHello的Legacy_Version字段。
 
   -  “Signature_Algorithms_cert”扩展允许客户端指明它可以在X.509证书中验证
      哪些签名算法。
 
   此外，本文档还澄清了TLS早期版本的一些合规性要求；参见第9.3节。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
2.  协议概述
 
   安全通道使用的加密参数由 TLS 握手协议生成。 此 TLS 子协议由客户端和服务器在首次
   相互通信时使用。 握手协议允许对等方协商协议版本、选择加密算法、选择相互验证以及
   建立共享密钥材料。 握手完成后，对等方将使用已建立的密钥来保护应用程序层流量。
 
   握手失败或其他协议错误会触发连接终止，可选择在此之前发送警告消息(第6节)。
 
   TLS支持三种基本的密钥交换模式：
 
   -  (EC)DHE(有限域或椭圆曲线上的Diffie-Hellman)。
 
   -  PSK-only
 
   -  PSK with (EC)DHE</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Figure 1 below shows the basic full TLS handshake:

       Client                                           Server

Key  ^ ClientHello
Exch | + key_share*
     | + signature_algorithms*
     | + psk_key_exchange_modes*
     v + pre_shared_key*       --------&gt;
                                                  ServerHello  ^ Key
                                                 + key_share*  | Exch
                                            + pre_shared_key*  v
                                        {EncryptedExtensions}  ^  Server
                                        {CertificateRequest*}  v  Params
                                               {Certificate*}  ^
                                         {CertificateVerify*}  | Auth
                                                   {Finished}  v
                               &lt;--------  [Application Data*]
     ^ {Certificate*}
Auth | {CertificateVerify*}
     v {Finished}              --------&gt;
       [Application Data]      &lt;-------&gt;  [Application Data]
 
              +  表示在前面的消息中发送的值得注意的扩展。
 
              *  表示并非总是发送的可选或依赖于情况的消息/扩展。
 
              {} 握手阶段加密消息
 
              [] 握手完成后的加密消息
 
                  图 1：完整的 TLS 握手消息流
 
   握手可视为具有三个阶段（如上图所示）：
 
   -  密钥交换：建立共享密钥材料并选择加密参数。 此阶段后的所有内容都已加密。
 
   -  服务器参数：建立其他握手参数（客户端是否经过身份验证、应用程序层协议支持等）。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   -  身份验证：对服务器（以及（可选）的客户端进行身份验证，并提供密钥确认和握手
      完整性。
 
   在密钥交换阶段，客户端发送ClientHello(第4.1.2节)消息，其中包含随机
   nonce(ClientHello.random)；其提供的协议版本；对称密码/HKDF散列对的列表；一组
   Diffie-Hellman密钥共享(在“KEY_SHARE”(第4.2.8节)扩展中)；一组预共享密钥标签
   (在“PRE_SHARED_KEY”(第4.2.11节)扩展中)，或两者；以及潜在的附加扩展。也可以
   存在额外的字段和/或消息以实现中间盒兼容性。
 
   服务器处理ClientHello并为连接确定适当的加密参数。然后，它用自己的ServerHello
   (第4.1.3节)进行响应，指示协商的连接参数。ClientHello和ServerHello的组合确定
   共享密钥。如果正在使用(EC)DHE密钥建立，则ServerHello包含带有服务器短暂
   Diffie-Hellman共享的“key_share”扩展；服务器共享必须与客户端共享之一在同一组
   中。如果正在使用PSK密钥建立，则ServerHello包含“pre_shared_key”扩展，指示
   选择了客户端提供的PSK中的哪一个。请注意，实现可以同时使用(EC)DHE和PSK，在这种
   情况下，将同时提供这两个扩展。
 
   然后，服务器发送两条消息以建立服务器参数：
 
   EncryptedExtensions：对ClientHello扩展的响应，这些扩展不是确定加密参数所必需
      的，特定于单个证书的参数除外。[第4.3.1条]。
 
   CertificateRequest：如果需要基于证书的客户端身份验证，则需要该证书的所需参数。
      如果不需要客户端身份验证，则省略此消息。[第4.3.2条]</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   最后，客户端和服务器交换身份验证消息。每次需要基于证书的身份验证时，TLS都使用
   相同的消息集。(基于PSK的身份验证是密钥交换的副作用。)。具体而言：
 
   Certificate：端点的证书和任何每个证书扩展。如果服务器未使用证书进行身份验证，
      则此消息将被服务器省略；如果服务器未发送CertificateRequest，则客户端将省略
      此消息(从而表明客户端不应使用证书进行身份验证)。请注意，如果原始公钥[RFC7250]
      或缓存信息扩展[RFC7924]正在使用中，则此消息将不包含证书，而是包含与服务器的
      长期密钥相对应的其他值。[第4.4.2条]。
 
   CertificateVerify:  在整个握手过程中使用与证书消息中的公钥对应的私钥进行签名。
      如果端点不是通过证书进行身份验证，则忽略此消息。[第4.4.3条]。
 
   Finished:  整个握手过程中的MAC(消息验证码)。此消息提供密钥确认，将端点的身份
      绑定到交换的密钥，并且在PSK模式下还会验证握手。[第4.4.4条]。
 
   在接收到服务器的消息后，客户端用其身份验证消息(Certificate和CertificateVerify
   (如果请求)进行响应，并 Finished 。
 
   此时，握手完成，客户端和服务器导出记录层所需的密钥材料，以交换通过身份验证加密保护
   的应用层数据。除第2.3节规定外，在发送 Finished 消息之前不得发送应用程序数据。请
   注意，虽然服务器可能在接收客户端的身份验证消息之前发送应用程序数据，但此时发送的
   任何数据当然是发送给未经过身份验证的对等体。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
2.1.  不正确的 DHE 共享
 
   如果客户端没有提供足够的“key_share”扩展(例如，它只包括服务器不能接受或不支持的
   DHE 或 ECDHE 组)，则服务器用 HelloRetryRequest 纠正不匹配，并且客户端需要用
   适当的 “key_share” 扩展重新启动握手，如图2所示。如果无法协商公共密码参数，则
   服务器必须中止握手并发出适当的警报。
 
        Client                                               Server

        ClientHello
        + key_share             --------&gt;
                                                  HelloRetryRequest
                                &lt;--------               + key_share
        ClientHello
        + key_share             --------&gt;
                                                        ServerHello
                                                        + key_share
                                              {EncryptedExtensions}
                                              {CertificateRequest*}
                                                     {Certificate*}
                                               {CertificateVerify*}
                                                         {Finished}
                                &lt;--------       [Application Data*]
        {Certificate*}
        {CertificateVerify*}
        {Finished}              --------&gt;
        [Application Data]      &lt;-------&gt;        [Application Data]
 
                 图 2：具有不匹配参数的完整握手的消息流
 
   注意：握手记录包含初始ClientHello/HelloRetryRequest交换；它不会使用新的
   ClientHello重置。
 
   TLS还允许基本握手的几个优化变体，如以下各节所述。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
2.2.  恢复和预共享密钥(PSK)
 
   虽然TLS PSK可以在带外建立，但是PSK也可以在以前的连接中建立，然后用于建立新的连接
   (使用PSK“会话恢复”或“恢复”)。一旦握手完成，服务器就可以向客户端发送一个PSK身份，
   该PSK身份对应于从初始握手导出的唯一密钥(参见4.6.1节)。然后，客户端可以在将来的
   握手中使用该PSK身份来协商相关PSK的使用。如果服务器接受PSK，则新连接的安全上下文被
   加密地绑定到原始连接，并且从初始握手导出的密钥被用于引导加密状态而不是完全握手。在
   TLS 1.2 及更低版本中，此功能由“session IDs”和“session tickets”[RFC5077]
   提供。这两种机制在TLS 1.3中都已过时。
 
   PSK可以与(EC)DHE密钥交换一起使用，以便结合共享密钥提供前向保密性，或者可以单独
   使用，但代价是失去应用数据的前向保密性。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   图3显示了一对握手，其中第一次握手建立PSK，第二次握手使用PSK：
 
          Client                                               Server

   Initial Handshake:
          ClientHello
          + key_share               --------&gt;
                                                          ServerHello
                                                          + key_share
                                                {EncryptedExtensions}
                                                {CertificateRequest*}
                                                       {Certificate*}
                                                 {CertificateVerify*}
                                                           {Finished}
                                    &lt;--------     [Application Data*]
          {Certificate*}
          {CertificateVerify*}
          {Finished}                --------&gt;
                                    &lt;--------      [NewSessionTicket]
          [Application Data]        &lt;-------&gt;      [Application Data]


   Subsequent Handshake:
          ClientHello
          + key_share*
          + pre_shared_key          --------&gt;
                                                          ServerHello
                                                     + pre_shared_key
                                                         + key_share*
                                                {EncryptedExtensions}
                                                           {Finished}
                                    &lt;--------     [Application Data*]
          {Finished}                --------&gt;
          [Application Data]        &lt;-------&gt;      [Application Data]
 
                          图3：恢复和PSK的消息流
 
   由于服务器通过PSK进行身份验证，因此它不会发送Certificate或CertificateVerify
   消息。当客户端通过PSK提供恢复时，它还应该向服务器提供“KEY_SHARE”扩展，以允许
   服务器拒绝恢复并回退到完全握手(如果需要)。服务器用“PRE_SHARED_KEY”扩展响应以
   协商PSK密钥建立的使用，并且可以(如此处所示)用“KEY_SHARE”扩展响应以进行(EC)DHE
   密钥建立，从而提供前向保密性。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   当 PSK 在带外预配时，还必须预配要与 PSK 一起使用的 PSK 标识和 KDF 哈希算法。
 
   注意：当使用带外预配的预共享密钥时，一个关键的考虑因素是在密钥生成期间使用足够的
   熵，如 [RFC4086] 中所述。 从密码或其他低熵源派生共享密钥不安全。 低熵机密或密码
   会根据 PSK 活页夹进行字典攻击。 指定的 PSK 身份验证不是强基于密码的身份验证密钥
   交换，即使与 Diffie-Hellman 密钥建立一起使用也是如此。 具体而言，它不会阻止可以
   观察握手的攻击者对密码/预共享密钥执行暴力攻击。
 
2.3.  0-RTT Data
 
   当客户端和服务器共享PSK(通过外部获取或通过先前的握手获得)时，TLS 1.3允许客户端
   在第一波发送时发送数据(“早期数据”)。客户端使用PSK对服务器进行身份验证，并对早期
   数据进行加密。
 
   如图4所示，0-RTT数据只是添加到第一波发送中的1-RTT握手。握手的其余部分使用与具有
   PSK恢复的1-RTT握手相同的消息。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
         Client                                               Server

         ClientHello
         + early_data
         + key_share*
         + psk_key_exchange_modes
         + pre_shared_key
         (Application Data*)     --------&gt;
                                                         ServerHello
                                                    + pre_shared_key
                                                        + key_share*
                                               {EncryptedExtensions}
                                                       + early_data*
                                                          {Finished}
                                 &lt;--------       [Application Data*]
         (EndOfEarlyData)
         {Finished}              --------&gt;
         [Application Data]      &lt;-------&gt;        [Application Data]
 
              +  表示在前面的消息中发送的值得注意的扩展。
 
              *  表示并非总是发送的可选或依赖于情况的消息/扩展。

              ()表示使用从client_early_traffic_secret派生的密钥保护的消息。
 
              {} 握手阶段加密消息
 
              [] 握手完成后的加密消息
 
                            图4：0-RTT握手的消息流</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   重要说明：0-RTT数据的安全属性比其他类型的TLS数据的安全属性弱。具体而言：
 
   1.  此数据不是前向秘密，因为它仅在使用所提供的PSK导出的密钥下加密。
 
   2.  连接之间不能保证不重放。普通 TLS 1.3 1-RTT 数据的重放保护通过服务器的
       Random值提供，但 0-RTT 数据不依赖于 ServerHello ，因此具有较弱的保证。
       如果使用TLS客户端身份验证或在应用程序协议内部对数据进行身份验证，则这一点
       尤其重要。同样的警告也适用于 early_exporter_master_secret 的任何用法。
 
   0-RTT 数据不能在一个连接内复制(即，服务器不会为相同的连接处理相同的数据两次)，
   并且攻击者将无法使 0-RTT 数据看起来是 1-RTT 数据(因为它受到不同密钥的保护)。
   附录E.5 包含对潜在攻击的描述，第8节描述了服务器可用于限制重放影响的机制。
 
3.  演示语言
 
   本文档处理外部表示中的数据格式。将使用以下非常基本且有些随意定义的表示语法。
 
3.1.  基本块大小
 
   明确指定所有数据项的表示。基本数据块大小是一个字节(即，8位)。多字节数据项是字节
   的串联，从左到右，从上到下。从字节流中，多字节项(以下示例中的数字)通过以下方式
   形成(使用C表示法)：
 
      value = (byte[0] &lt;&lt; 8*(n-1)) | (byte[1] &lt;&lt; 8*(n-2)) |
              ... | byte[n-1];
 
   多字节值的字节排序是常见的网络字节顺序或大字节格式。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
3.2.  杂项
 
   注释以“/*”开头，以“*/”结尾。
 
   可选组件通过将其括在“[[]]”(双括号)中来表示。
 
   包含未解释数据的单字节实体属于不透明类型。
 
   现有类型T的类型别名T‘定义如下：
 
      T T';
 
3.3.  数字
 
   基本的数字数据类型是无符号字节(Uint8)。所有较大的数值数据类型都是由固定长度的
   字节序列构造的，这些字节序列按照3.1节中的描述连接起来，并且也是无符号的。以下数值
   类型是预定义的。
 
      uint8 uint16[2];
      uint8 uint24[3];
      uint8 uint32[4];
      uint8 uint64[8];
 
   所有值（此处和规范中的其他地方）均按网络字节（大端）顺序传输;由十六进制 
   01 02 03 04 表示的 uint32 等效于十进制值 16909060。
 
3.4.  向量
 
   向量(一维数组)是同构数据元素的流。矢量的大小可以在文档编制时指定，或者直到运行时
   才指定。在任何一种情况下，长度都声明向量中的字节数，而不是元素数。用于指定新类型
   T‘(即T类型的定长向量)的语法是。
 
      T T'[n];
 
   这里，T‘占据数据流中的n个字节，其中 n 是T的大小的倍数。向量的长度不包括在
   编码流中。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   在下面的示例中，Datum 被定义为协议不解释的三个连续字节，而 Data 是三个连续的
   Datum，总共消耗九个字节。
 
      opaque Datum[3];      /* three uninterpreted bytes */
      Datum Data[9];        /* three consecutive 3-byte vectors */
 
   可变长度向量是通过指定合法长度的子范围来定义的，使用表示法 &lt;下限..上限&gt; 。
   当这些被编码时，实际长度在字节流中的向量内容之前。长度将采用数字的形式，消耗的
   字节数与保持矢量指定的最大(上限)长度所需的字节数相同。实际长度字段为零的可变长度
   向量称为空向量。
 
      T T'&lt;floor..ceiling&gt;;
 
   在下面的示例中，“mandatory” 是一个必须包含300到400个不透明类型的字节的向量。
   它永远不会是空的。“实际长度”字段消耗两个字节，即uint16，这足以表示值400(参见
   第3.3节)。类似地，“longer”可以表示多达800字节的数据，或400个uint16元素，并且
   它可以是空的。它的编码将包括两个字节的实际长度字段，放在向量的前面。编码向量的长度必须是单个元素长度的精确倍数(例如，uint16的17字节向量是非法的)。
 
      opaque mandatory&lt;300..400&gt;;
            /* length field is two bytes, cannot be empty */
      uint16 longer&lt;0..800&gt;;
            /* zero to 400 16-bit unsigned integers */
 
3.5.  枚举
 
   其他稀疏数据类型（称为 "枚举"）。 每个定义都是不同的类型。 只能分配或比较相同类型
   的枚举。 枚举的每个元素都必须分配一个值，如以下示例所示。 由于枚举的元素不排序，
   因此可以按任意顺序为其分配任何唯一值。
 
      enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;
 
   将来对协议的扩展或添加可以定义新值。实现需要能够解析和忽略未知值，除非字段的定义
   另有说明。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   枚举在字节流中占用的空间与其定义的最大序数值一样多。下面的定义将使用一个字节
   携带Color类型的字段。
 
      enum { red(3), blue(5), white(7) } Color;
 
   可以任选地指定一个没有其关联标签的值，以强制宽度定义，而不定义多余的元素。
 
   在下面的示例中，Taste将占用数据流中的两个字节，但只能在协议的当前版本中取值
   1、2或4。
 
      enum { sweet(1), sour(2), bitter(4), (32000) } Taste;
 
   枚举元素的名称在定义的类型中限定作用域。在第一个示例中，对枚举的第二个元素的完全
   限定引用将是Color.blue。如果指定的目标明确，则不需要这种资格。
 
      Color color = Color.blue;     /* overspecified, legal */
      Color color = blue;           /* correct, type implicit */
 
   枚举元素的名称在定义的类型中限定作用域。在第一个示例中，对枚举的第二个元素的完全
   限定引用将是Color.blue。如果指定的目标明确，则不需要这种限制。
 
      enum { sad(0), meh(1..254), happy(255) } Mood;
 
3.6.  结构类型

   为方便起见，可以从基元类型构造结构类型。每个规范都声明了一个新的、唯一的类型。
   用于定义的语法非常类似于C。
 
      struct {
          T1 f1;
          T2 f2;
          ...
          Tn fn;
      } T;
 
   使用标准向量语法允许固定和可变长度向量域。变体示例(3.8节)中的结构V1和V2证明了
   这一点。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   结构中的字段可以使用类型的名称进行指定，其语法非常类似于枚举可用的语法。例如，
   T.f2是指前一个声明的第二个字段。
 
3.7.  常量
 
   可以使用“=”为字段和变量分配固定值，如：
 
      struct {
          T1 f1 = 8;  /* T.f1 must always be 8 */
          T2 f2;
      } T;
 
3.8.  变体
 
   定义的结构可能具有基于环境中可用的某些知识的变体。选择器必须是枚举类型，用于定义
   结构定义的可能变体。SELECT的每个分支(见下图)都指定了该变量的字段类型和可选的字段
   标签。在运行时选择变体的机制不是由表示语言规定的。
 
      struct {
          T1 f1;
          T2 f2;
          ....
          Tn fn;
          select (E) {
              case e1: Te1 [[fe1]];
              case e2: Te2 [[fe2]];
              ....
              case en: Ten [[fen]];
          };
      } Tv;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   For example:
 
      enum { apple(0), orange(1) } VariantTag;
 
      struct {
          uint16 number;
          opaque string&lt;0..10&gt;; /* variable length */
      } V1;
 
      struct {
          uint32 number;
          opaque string[10];    /* fixed length */
      } V2;
 
      struct {
          VariantTag type;
          select (VariantRecord.type) {
              case apple:  V1;
              case orange: V2;
          };
      } VariantRecord;
 
4.  握手协议
 
   握手协议用于协商连接的安全参数。握手消息被提供给TLS记录层，在那里它们被封装在一个
   或多个 TLSPlaintext 或 TLSCiphertext 结构中，这些结构按照当前活动连接的状态
   进行处理和传输。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
      enum {
          client_hello(1),
          server_hello(2),
          new_session_ticket(4),
          end_of_early_data(5),
          encrypted_extensions(8),
          certificate(11),
          certificate_request(13),
          certificate_verify(15),
          finished(20),
          key_update(24),
          message_hash(254),
          (255)
      } HandshakeType;
 
      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* remaining bytes in message */
          select (Handshake.msg_type) {
              case client_hello:          ClientHello;
              case server_hello:          ServerHello;
              case end_of_early_data:     EndOfEarlyData;
              case encrypted_extensions:  EncryptedExtensions;
              case certificate_request:   CertificateRequest;
              case certificate:           Certificate;
              case certificate_verify:    CertificateVerify;
              case finished:              Finished;
              case new_session_ticket:    NewSessionTicket;
              case key_update:            KeyUpdate;
          };
      } Handshake;
 
   协议消息必须按照第4.4.1节中定义的顺序发送，并在第2节的图表中显示。以意外顺序接收
   握手消息的对等体必须中止握手并发出 “unexpected_message” 警报。
 
   新的握手消息类型由IANA分配，如第11节所述。
 
4.1.  Key Exchange 消息
 
   密钥交换消息用于确定客户端和服务器的安全能力，并建立共享密钥，包括用于保护其余
   握手和数据的业务密钥。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.1.1.  加密协商
 
   在TLS中，加密协商通过客户端在 ClientHello 中提供以下四组选项来进行：
 
   -  密码套件列表，指示客户端支持的 AEAD算法/HKDF散列对。
 
   -  “supported_groups”(4.2.7节)扩展，表示客户端支持的(EC)DHE组；
      “key_share”(4.2.8节)扩展，包含部分或所有这些组的(EC)DHE共享。
 
   -  “signature_algorithms”(第4.2.3节)扩展，表示客户端可以接受的签名算法。
      还可以添加“signature_algorithms_cert”扩展(第4.2.3节)，以指示证书特定的
      签名算法。
 
   -  “pre_shared_key”(第4.2.11节)扩展，其中包含客户端已知的对称密钥身份列表，
      以及“psk_key_exchange_modes”(第4.2.9节)扩展，该扩展指示可与PSK一起
      使用的密钥交换模式。
 
   如果服务器不选择PSK，则这些选项中的前三个选项完全正交：服务器独立地选择密码组、
   (EC)DHE组和密钥共享用于密钥建立，以及签名算法/证书对以向客户端验证其自身。如果
   接收到的“supported_groups”与服务器支持的组之间没有重叠，则服务器必须中止握手，
   并发出“handshake_failure”或“insufficient_security”警报。
 
   如果服务器选择PSK，则它还必须从客户端的“psk_key_exchange_modes”扩展所指示的
   集合中选择密钥建立模式(目前，PSK单独或与(EC)DHE一起)。请注意，如果PSK可以在没有
   (EC)DHE的情况下使用，则“supported_groups”参数中的不重叠不一定是致命的，就像
   上一段中讨论的非PSK情况一样。
 
   如果服务器选择(EC)DHE组，并且客户端没有在初始 ClientHello 中提供兼容的
   “key_share”扩展，则服务器必须使用 HelloRetryRequest(第4.1.4节)消息进行
   响应。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   如果服务器成功选择参数且不需要 HelloRetryRequest，则ServerHello中选择的参数
   如下：
 
   -  如果正在使用PSK，则服务器将发送“pre_shared_key”扩展，指示所选密钥。
 
   -  使用(EC)DHE时，服务器还将提供“key_share”扩展。如果未使用PSK，则始终使用
      (EC)DHE和基于证书的身份验证。
 
   -  在进行证书身份验证时，服务器将发送 Certificate (第4.4.2节)和
      CertificateVerify(第4.4.3节)消息。在本文档定义的TLS 1.3中，始终使用PSK
      或证书，但不能同时使用。未来的文档可能会定义如何将它们一起使用。
 
   如果服务器无法协商支持的一组参数(即客户端和服务器参数之间没有重叠)，则必须中止
   握手，并发出“handshake_failure”或“insufficient_security”致命警报
   (参见第6节)。
 
4.1.2.  Client Hello
 
   当客户端首次连接到服务器时，需要发送ClientHello作为其第一个TLS消息。当服务器使用
   HelloRetryRequest 响应其 ClientHello 时，客户端还将发送 ClientHello 。在
   这种情况下，客户端必须发送相同的 ClientHello 而不进行修改，以下情况除外：
 
   -  如果 HelloRetryRequest 中提供了“key_share”扩展，则将共享列表替换为
      包含指定组中单个 KeyShareEntry 的列表。
 
   -  如果存在“early_data”扩展(第4.2.10节)，则删除该扩展。
      HelloRetryRequest 之后不允许早期数据。
 
   -  如果HelloRetryRequest中提供了“cookie”扩展，则包括“cookie”扩展。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   -  更新“pre_shared_key”扩展(如果存在)，方法是重新计算
      “obfuscated_ticket_age”和绑定器值，并(可选)删除与服务器指示的密码套件
      不兼容的任何PSK。
 
   -  可选地添加、删除或更改扩展的“填充”长度[RFC7685]。
 
   -  未来定义的扩展可能允许的其他修改，并且存在于 HelloRetryRequest 中。
 



   由于 TLS 1.3 禁止重新协商，因此如果服务器已经协商了 TLS 1.3 并在任何其他时间
   收到ClientHello，则它必须终止连接并发出“unexpected_message”警报。
 

   如果服务器与以前版本的 TLS 建立了 TLS 连接，并在重新协商中收到
   TLS 1.3 ClientHello，则它必须保留以前的协议版本。特别是，它不能协商TLS 1.3。
 


   Structure of this message:
 
      uint16 ProtocolVersion;
      opaque Random[32];
 
      uint8 CipherSuite[2];    /* Cryptographic suite selector */
 
      struct {
          ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
          Random random;
          opaque legacy_session_id&lt;0..32&gt;;
          CipherSuite cipher_suites&lt;2..2^16-2&gt;;
          opaque legacy_compression_methods&lt;1..2^8-1&gt;;
          Extension extensions&lt;8..2^16-1&gt;;
      } ClientHello;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   legacy_version:  在TLS的早期版本中，此字段用于版本协商，表示客户端支持的最高
      版本号。经验表明，许多服务器没有正确实现版本协商，导致
      “version intolerance”， 即服务器拒绝一个本来可以接受的 ClientHello，
     其版本号高于它所支持的版本号。在TLS 1.3中，客户端在 “supported_versions”
     扩展(第4.2.1节)中指明其版本首选项，并且 Legacy_Version 字段必须设置为
     0x0303，这是 TLS 1.2 的版本号。TLS 1.3 ClientHellos被标识为具有0x0303
     的 legacy_version 和 supported_versions 扩展，其中0x0304是其中指示的
     最高版本。(有关向后兼容性的详细信息，请参阅附录D。)。





   random:  由安全随机数生成器生成的32个字节。有关更多信息，请参见附录C。
 

   legacy_session_id:  TLS 1.3 之前的TLS版本支持“会话恢复”功能，该功能已与此
      版本中的预共享密钥合并(参见第2.2节)。具有由TLS 1.3之前的服务器设置的缓存
      会话ID 的客户端应将该字段设置为该值。在兼容模式下(参见附录D.4)，此字段必须
      非空，因此未提供TLS 1.3之前的会话的客户端必须生成新的32字节值。这个值不需要是
      随机的，但是应该是不可预测的，以避免实现专注于特定的值(也称为渗透)。否则，必须
      将其设置为零长度向量(即，零值单字节长度字段)。
 




   cipher_suites:  客户端支持的对称密码选项列表，指定记录层保护算法(包括密钥长度)
      和要与HKDF一起使用的散列，按客户端首选项的降序排列。值在附录B.4 中定义。如果
      列表中包含服务器不识别、不支持或不希望使用的密码套件，则服务器必须忽略这些
      密码套件，并像往常一样处理其余的密码套件。如果客户端正在尝试PSK密钥建立，则它
      应该通告至少一个指示与PSK相关联的散列的密码套件。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   legacy_compression_methods:  1.3之前的TLS版本支持压缩，支持的压缩方法列表
      在此字段中发送。对于每个 TLS 1.3 ClientHello，此向量必须正好包含一个字节，
      设置为零，这与以前版本的TLS中的“null”压缩方法相对应。如果接收到的TLS 1.3 
      ClientHello 具有此字段中的任何其他值，则服务器必须中止握手并发出
      “illegal_parameter” 警报。请注意，TLS 1.3 服务器可能会收到包含其他压缩
      方法的TLS 1.2或以前的ClientHellos，并且(如果协商这样的以前版本)必须遵循
      适用于TLS以前版本的过程。
 



   extensions:  客户端通过发送扩展字段中的数据从服务器请求扩展功能。实际的
      “Extension” 格式在4.2节中定义。在 TLS 1.3中，某些扩展的使用是强制性的，
      因为功能已经转移到扩展中，以保持 ClientHello 与以前版本的TLS的兼容性。服务器
      必须忽略无法识别的扩展。
 


   TLS的所有版本都允许扩展字段可选地跟随在 compression_methods 字段之后。
   TLS 1.3 ClientHello 消息始终包含扩展(最低限度为“supported_versions”，
   否则，它们将被解释为TLS 1.2 ClientHello 消息)。但是，TLS 1.3 服务器可能会从
   以前版本的TLS接收没有扩展字段的 ClientHello 消息。扩展的存在可以通过确定
   ClientHello末尾的 compression_methods 字段后面是否有字节来检测。请注意，这种
   检测可选数据的方法不同于具有可变长度字段的常规TLS方法，但它用于在定义扩展之前与
   TLS 兼容。TLS 1.3 服务器需要首先执行此检查，并且只有在存在
   “supported_versions”扩展时才会尝试协商 TLS 1.3。如果协商1.3之前的TLS版本，
   则服务器必须检查消息是否在 legacy_compression_methods 之后不包含数据，或者
   它是否包含有效的扩展块，后面没有数据。如果不是，则必须中止握手并发出
   “decode_error” 警报。
 
   在客户端使用扩展请求附加功能并且该功能不是由服务器提供的情况下，客户端可能会中止
   握手。
 
   发送 ClientHello 消息后，客户端等待 ServerHello 或 HelloRetryRequest消息。
   如果正在使用早期数据，则客户端可以在等待下一次握手消息的同时传输早期应用数据
   (第2.3节)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.1.3.  Server Hello
 
   如果服务器能够基于ClientHello协商可接受的握手参数集，则服务器将响应
   ClientHello 消息发送此消息以继续进行握手。
 
   Structure of this message:
 
      struct {
          ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
          Random random;
          opaque legacy_session_id_echo&lt;0..32&gt;;
          CipherSuite cipher_suite;
          uint8 legacy_compression_method = 0;
          Extension extensions&lt;6..2^16-1&gt;;
      } ServerHello;
 
   legacy_version:  在TLS的以前版本中，此字段用于版本协商，并表示连接的选定
      版本号。不幸的是，一些中间件在提供新值时会失败。在TLS 1.3中，TLS服务器使用
      “supported_versions”扩展(第4.2.1节)指示其版本，并且legacy_version字段
      必须设置为0x0303，这是TLS 1.2的版本号。(有关向后兼容性的详细信息，请参阅
      附录D。)
 



   random:  由安全随机数生成器生成的32字节。有关更多信息，请参见附录C。如果协商
      TLS 1.2 或 TLS 1.1 ，则必须覆盖后8个字节，如下所述，但其余字节必须是
      随机的。此结构由服务器生成，并且必须独立于 ClientHello.random 生成。


 
   legacy_session_id_echo:  客户端的 legacy_session_id 字段的内容。请注意，
      即使客户端的值对应于服务器已选择不恢复的缓存的TLS 1.3之前的会话，也会回显此
      字段。接收到与其在 ClientHello中发送的字段不匹配的legacy_session_id_echo
      字段的客户端必须中止握手，并发出“illegal_parameter”警报。



 
   cipher_suite:  服务器从 ClientHello.cipher_suites 中的列表中选择的单个密码
      套件。接收到未提供的密码套件的客户端必须中止握手，并发出“illegal_parameter”
      警报。
 
   legacy_compression_method:  必须具有值0的单个字节。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   extensions:  扩展的列表.   ServerHello 必须仅包含建立加密上下文和协商协议
      版本所需的扩展。 所有 TLS 1.3 ServerHello 消息必须包含
      "supported_versions" 扩展。 当前 ServerHello 消息还包含
      "pre_shared_key"扩展或"key_share"扩展，或两者（当 PSK 与 （EC）DHE 
      密钥建立时）。 其他扩展（请参阅第 4.2 节）在加密扩展消息中单独发送。
 
   出于与中间件向后兼容的原因(参见附录D.4)，HelloRetryRequest 消息使用与
   ServerHello相同的结构，但 Random 设置为 “HelloRetryRequest” 的SHA-256的
   特殊值：
 
     CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91
     C2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C
 
   在接收到 server_hello 类型的消息时，实现必须首先检查 Random 值，如果它与此值
   匹配，则按照4.1.4节中的描述对其进行处理。
 
   TLS 1.3在服务器的随机值中嵌入了降级保护机制。为响应 ClientHello 而协商
   TLS 1.2 或更低版本的 TLS 1.3 服务器必须特别在其 ServerHello 中设置其随机值
   的最后8个字节。
 
   如果协商 TLS 1.2，TLS 1.3 服务器必须将其随机值的最后8个字节设置为字节：
 
     44 4F 57 4E 47 52 44 01
 
   如果协商TLS 1.1或更低版本，则 TLS 1.3 服务器必须，并且TLS 1.2服务器应将其
   ServerHello.Random 值的最后8个字节设置为字节：
 
     44 4F 57 4E 47 52 44 00
 
   TLS 1.3客户端收到指示TLS 1.2或更低版本的ServerHello时，必须检查最后8个字节
   是否不等于这些值中的任何一个。如果ServerHello指示TLS 1.1或更低，TLS 1.2客户端
   还应检查最后8个字节是否等于第二个值。如果找到匹配项，客户端必须中止握手并发出
   “illegal_parameter”警报。此机制提供有限的保护，以防止在完成的交换所提供的内容
   之上的降级攻击：因为存在于TLS 1.2及更低版本中的消息 ServerKeyExchange 包括
   对两个随机值的签名，因此只要使用短暂的密码，主动攻击者就不可能在未检测的情况下
   修改随机值。使用静态RSA时，它不提供降级保护。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 




 
   注意：这是对[RFC5246]的更改，因此在实践中许多TLS 1.2客户端和服务器将不会像
   上面指定的那样工作。
 
   与TLS 1.2或更早版本执行重新协商并且在重新协商期间接收到 TLS 1.3 ServerHello
   的传统TLS客户端必须中止握手并发出“protocol_version”警报。请注意，当TLS 1.3
   已被协商时，重新协商是不可能的。
 
4.1.4.  Hello Retry Request
 
   如果服务器能够找到一组可接受的参数，但 ClientHello 没有包含足够的信息来继续
   进行握手，则服务器将发送此消息以响应 ClientHello 消息。如第4.1.3节所述，
   HelloRetryRequest 具有与 ServerHello 消息相同的格式，Legacy_Version、
   Legacy_Session_id_echo、cipher_Suite 和 Legacy_Compression_Method字段
   具有相同的含义。然而，为了方便起见，我们在整个文档中讨论 “HelloRetryRequest”，
   就好像它是一条截然不同的消息一样。
 
   服务器的扩展必须包含“supported_versions”。此外，它应该包含客户端生成正确
   的 ClientHello 对所需的最小扩展集。与 ServerHello 一样，HelloRetryRequest
   不得包含客户端在其 ClientHello 中首先提供的任何扩展，但可选的 “cookie” 
   (参见第4.2.2节)扩展除外。
 




   收到 HelloRetryRequest 后，客户端必须按照第4.1.3节的规定检查
   Legacy_Version、Legacy_Session_id_echo、cipher_Suite和
   Legacy_Compression_Method，然后处理扩展，首先使用“Supported_Versions”
   确定版本。如果HelloRetryRequest不会导致ClientHello中的任何更改，则客户端必须
   中止握手并发出“illegal_parameter”警报。如果客户端在同一连接中接收到第二个
   HelloRetryRequest(即ClientHello本身响应HelloRetryRequest)，则它必须中止
   握手并发出“unexpected_message”警报。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   否则，客户端必须处理HelloRetryRequest中的所有扩展，并发送第二个更新的
   ClientHello。本规范中定义的HelloRetryRequest扩展包括：
 
   -  supported_versions (see Section 4.2.1)
 
   -  cookie (see Section 4.2.2)
 
   -  key_share (see Section 4.2.8)
 
   接收到未提供密码套件的客户端必须中止握手。服务器必须确保在接收符合更新的
   ClientHello 时协商相同的密码套件(如果服务器选择密码套件作为协商的第一步，则这
   将自动发生)。在接收到ServerHello后，客户端必须检查 ServerHello 中提供的密码
   套件与HelloRetryRequest中提供的密码套件是否相同，否则会中止握手并发出
   “illegal_parameter”警报。

 
   此外，在其更新的ClientHello中，客户端不应提供与所选密码套件的散列以外的散列
   相关联的任何预共享密钥。这允许客户端避免必须为第二ClientHello中的多个散列计算
   部分散列转录本。
 
   HelloRetryRequest的“supported_versions”扩展中 selected_version 的值
   必须保留在 ServerHello 中，并且如果值更改，客户端必须中止握手并发出
   “illegal_parameter”警报。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.  Extensions
 
   许多TLS消息包含标记长度值编码的扩展结构。
 
    struct {
        ExtensionType extension_type;
        opaque extension_data&lt;0..2^16-1&gt;;
    } Extension;
 
    enum {
        server_name(0),                             /* RFC 6066 */
        max_fragment_length(1),                     /* RFC 6066 */
        status_request(5),                          /* RFC 6066 */
        supported_groups(10),                       /* RFC 8422, 7919 */
        signature_algorithms(13),                   /* RFC 8446 */
        use_srtp(14),                               /* RFC 5764 */
        heartbeat(15),                              /* RFC 6520 */
        application_layer_protocol_negotiation(16), /* RFC 7301 */
        signed_certificate_timestamp(18),           /* RFC 6962 */
        client_certificate_type(19),                /* RFC 7250 */
        server_certificate_type(20),                /* RFC 7250 */
        padding(21),                                /* RFC 7685 */
        pre_shared_key(41),                         /* RFC 8446 */
        early_data(42),                             /* RFC 8446 */
        supported_versions(43),                     /* RFC 8446 */
        cookie(44),                                 /* RFC 8446 */
        psk_key_exchange_modes(45),                 /* RFC 8446 */
        certificate_authorities(47),                /* RFC 8446 */
        oid_filters(48),                            /* RFC 8446 */
        post_handshake_auth(49),                    /* RFC 8446 */
        signature_algorithms_cert(50),              /* RFC 8446 */
        key_share(51),                              /* RFC 8446 */
        (65535)
    } ExtensionType;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Here:
 
   -  "extension_type" 标识特定的扩展类型。
 
   -  "extension_data" 包含特定于特定扩展类型的信息。
 
   扩展类型列表由IANA维护，如第11节所述。
 
   扩展通常是以请求/响应的方式构造的，尽管一些扩展只是没有相应响应的指示。客户端
   在ClientHello消息中发送其扩展请求，服务器在ServerHello、
   EncryptedExtensions、HelloRetryRequest和Certificate消息中发送其扩展响应。
   服务器在CertificateRequest消息中发送扩展请求，客户端可以用证书消息来响应。
   服务器也可以在NewSessionTicket中发送未经请求的扩展，尽管客户端不直接响应这些
   扩展。
 
   如果远程端点没有发送相应的扩展请求，则实现不得发送扩展响应，HelloRetryRequest
   中的“cookie”扩展除外。在接收到这样的扩展时，端点必须中止握手并发出
   “unsupported_extension”警报。
 
   下表显示给定扩展可能出现的消息，使用以下表示法：CH(ClientHello)、
   SH(ServerHello)、EE(EncryptedExtensions)、CT(Certificate)、
   CR(CertificateRequest)、NST(NewSessionTicket)和
   HRR(HelloRetryRequest)。如果实现接收到它识别的扩展，并且没有为它出现的消息
   指定该扩展，则它必须中止握手并发出“illegal_parameter”警报。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   +--------------------------------------------------+-------------+
   | Extension                                        |     TLS 1.3 |
   +--------------------------------------------------+-------------+
   | server_name [RFC6066]                            |      CH, EE |
   |                                                  |             |
   | max_fragment_length [RFC6066]                    |      CH, EE |
   |                                                  |             |
   | status_request [RFC6066]                         |  CH, CR, CT |
   |                                                  |             |
   | supported_groups [RFC7919]                       |      CH, EE |
   |                                                  |             |
   | signature_algorithms (RFC 8446)                  |      CH, CR |
   |                                                  |             |
   | use_srtp [RFC5764]                               |      CH, EE |
   |                                                  |             |
   | heartbeat [RFC6520]                              |      CH, EE |
   |                                                  |             |
   | application_layer_protocol_negotiation [RFC7301] |      CH, EE |
   |                                                  |             |
   | signed_certificate_timestamp [RFC6962]           |  CH, CR, CT |
   |                                                  |             |
   | client_certificate_type [RFC7250]                |      CH, EE |
   |                                                  |             |
   | server_certificate_type [RFC7250]                |      CH, EE |
   |                                                  |             |
   | padding [RFC7685]                                |          CH |
   |                                                  |             |
   | key_share (RFC 8446)                             | CH, SH, HRR |
   |                                                  |             |
   | pre_shared_key (RFC 8446)                        |      CH, SH |
   |                                                  |             |
   | psk_key_exchange_modes (RFC 8446)                |          CH |
   |                                                  |             |
   | early_data (RFC 8446)                            | CH, EE, NST |
   |                                                  |             |
   | cookie (RFC 8446)                                |     CH, HRR |
   |                                                  |             |
   | supported_versions (RFC 8446)                    | CH, SH, HRR |
   |                                                  |             |
   | certificate_authorities (RFC 8446)               |      CH, CR |
   |                                                  |             |
   | oid_filters (RFC 8446)                           |          CR |
   |                                                  |             |
   | post_handshake_auth (RFC 8446)                   |          CH |
   |                                                  |             |
   | signature_algorithms_cert (RFC 8446)             |      CH, CR |
   +--------------------------------------------------+-------------+</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   当存在多个不同类型的扩展时，扩展可以任何顺序出现，除了“pre_shared_key”
   (第4.2.11节)，它必须是ClientHello中的最后一个扩展 (但可以出现在ServerHello
   Extensions块的任何地方)。给定的扩展块中不能有多个相同类型的扩展。
 
   在TLS 1.3中，与TLS 1.2不同，即使在恢复PSK模式下，也会为每次握手协商扩展。
   然而，0-RTT 参数是在前一次握手中协商的参数；不匹配可能需要拒绝0-RTT
   (参见4.2.10节)。
 
   在这个协议中，新功能和现有功能之间可能会发生一些微妙的(也不是那么微妙的)交互作用，
   这可能会导致总体安全性的显着降低。设计新扩展时应考虑以下注意事项：
 
   -  服务器不同意扩展的某些情况是错误条件(例如，握手不能继续)，而有些情况只是拒绝
      支持特定功能。通常，前者应使用错误警报，后者应在服务器扩展响应中使用一个字段。
 
   -  扩展应尽可能设计为防止通过操纵握手消息来强制使用(或不使用)特定功能的任何攻击。
      无论是否认为该功能会导致安全问题，都应遵循此原则。通常，扩展字段被包括在完成
      的消息散列的输入中的事实将是足够的，但是当扩展改变在握手阶段发送的消息的含义
      时，需要格外小心。设计者和实现者应该意识到这样一个事实：在握手得到验证之前，
      主动攻击者可以修改消息并插入、删除或替换扩展。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.1.  Supported Versions
 
      struct {
          select (Handshake.msg_type) {
              case client_hello:
                   ProtocolVersion versions&lt;2..254&gt;;
 
              case server_hello: /* and HelloRetryRequest */
                   ProtocolVersion selected_version;
          };
      } SupportedVersions;
 
   “supported_versions”扩展由客户端用来指示它支持的TLS版本，服务器用来指示它
   正在使用的版本。该扩展包含按优先顺序排列的受支持版本的列表，最首选的版本排在第一
   位。本规范的实现必须在ClientHello中发送此扩展，其中包含它们准备协商的所有TLS
   版本(对于本规范，这意味着最低限度为0x0304，但如果允许协商TLS的以前版本，则它们
   也必须存在)。
 
   如果不存在此扩展，则符合本规范且支持TLS 1.2的服务器必须按照[RFC5246]中的规定
   协商TLS 1.2或更早版本，即使ClientHello.legacy_version 为0x0304或更高版本
   也是如此。服务器可能会在接收到具有legacy_version 0x0304或更高版本的
   ClientHello时中止握手。
 
   协商TLS 1.3之前的TLS版本的服务器必须设置ServerHello.version，并且不能发送
   “supported_versions”扩展。协商TLS 1.3的服务器必须通过发送包含所选版本值
   (0x0304)的“supported_versions”扩展来响应。它必须将
   ServerHello.legacy_version 字段设置为0x0303(TLS 1.2)。客户端必须在处理
   ServerHello的其余部分之前检查此扩展(尽管它们必须解析ServerHello才能读取扩展)。
   如果存在此扩展，则客户端必须忽略 ServerHello.legacy_version 值，并且必须
   仅使用“supported_versions”扩展来确定所选版本。如果ServerHello中的
   “supported_versions”扩展包含客户端未提供的版本或包含TLS 1.3之前的版本，则
   客户端必须中止握手并发出“illegal_parameter”警报。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 







 
4.2.2.  Cookie
 
      struct {
          opaque cookie&lt;1..2^16-1&gt;;
      } Cookie;
 
   Cookie有两个主要用途：
 
   -  允许服务器强制客户端在其明显的网络地址展示可达性(从而提供DoS保护措施)。这
      主要用于非面向连接的传输(参见[RFC6347]中的一个例子)。
 
   -  允许服务器将状态卸载到客户端，从而允许它发送HelloRetryRequest而不存储任何
      状态。服务器可以通过将ClientHello的散列存储在HelloRetryRequest cookie
      (用一些适当的完整性保护算法保护)中来做到这一点。
 
   当发送HelloRetryRequest时，服务器可以向客户端提供“cookie”扩展(这是通常
   规则的例外，即可能发送的唯一扩展是那些出现在ClientHello中的扩展)。当发送
   新的ClientHello时，客户端必须将HelloRetryRequest中接收到的扩展的内容复制到
   新ClientHello中的“cookie”扩展中。在后续连接中，客户端不得在其初始
   ClientHello中使用Cookie。
 
   当服务器无状态运行时，它可能会在第一个ClientHello和第二个ClientHello之间接收
   change_cipher_spec类型的不受保护的记录(参见第5节)。由于服务器没有存储任何
   状态，这将看起来好像它是要接收的第一条消息。无状态运行的服务器必须忽略这些记录。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.3.  Signature Algorithms
 
   TLS 1.3提供了两个扩展，用于指示在数字签名中可以使用哪些签名算法。
   “signature_algorithms_cert” 扩展适用于证书中的签名，而最初出现在TLS 1.2中的
   “signature_algorithms”扩展适用于 CertificateVerify 消息中的签名。证书中找
   到的密钥还必须是与其一起使用的签名算法的适当类型。这是RSA密钥和PSS签名的特殊
   问题，如下所述。如果不存在“signature_algorithms_cert”扩展，则
   “signature_algorithms”扩展也适用于证书中出现的签名。希望服务器通过证书对自身
   进行身份验证的客户端必须发送“signature_algorithms”扩展。如果服务器通过证书进行
   身份验证，而客户端尚未发送“signature_algorithms”扩展，则服务器必须中止握手
   并发出“missing_extension”警报(参见第9.2节)。
 
   添加了"signature_algorithms_cert"扩展，以允许支持证书和 TLS 本身的不同
   算法集的实现清楚地发出其功能信号。  TLS 1.2 实现也应处理此扩展。在这两种情况下
   具有相同策略的实现可能会省略"signature_algorithms_cert"扩展。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   这些扩展的“extension_data”字段包含SignatureSchemeList 值：
 
      enum {
          /* RSASSA-PKCS1-v1_5 algorithms */
          rsa_pkcs1_sha256(0x0401),
          rsa_pkcs1_sha384(0x0501),
          rsa_pkcs1_sha512(0x0601),
 
          /* ECDSA algorithms */
          ecdsa_secp256r1_sha256(0x0403),
          ecdsa_secp384r1_sha384(0x0503),
          ecdsa_secp521r1_sha512(0x0603),
 
          /* RSASSA-PSS algorithms with public key OID rsaEncryption */
          rsa_pss_rsae_sha256(0x0804),
          rsa_pss_rsae_sha384(0x0805),
          rsa_pss_rsae_sha512(0x0806),
 
          /* EdDSA algorithms */
          ed25519(0x0807),
          ed448(0x0808),
 
          /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */
          rsa_pss_pss_sha256(0x0809),
          rsa_pss_pss_sha384(0x080a),
          rsa_pss_pss_sha512(0x080b),
 
          /* Legacy algorithms */
          rsa_pkcs1_sha1(0x0201),
          ecdsa_sha1(0x0203),
 
          /* Reserved Code Points */
          private_use(0xFE00..0xFFFF),
          (0xFFFF)
      } SignatureScheme;
 
      struct {
          SignatureScheme supported_signature_algorithms&lt;2..2^16-2&gt;;
      } SignatureSchemeList;
 
   注意：这个枚举被命名为“SignatureScheme”，因为在TLS 1.2中已经有一个
   “SignatureAlgorithm”类型，这将被替换。我们在整个文本中使用术语
   “signature algorithm”。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   每个SignatureScheme值列出了客户端愿意验证的单个签名算法。这些值以首选项的降序
   表示。请注意，签名算法将任意长度的消息而不是摘要作为输入。传统上作用于摘要的算法
   应该在TLS中定义，以首先使用指定的散列算法对输入进行散列，然后照常进行。上面列出
   的码点组有以下含义：
 
   RSASSA-PKCS1-v1_5 algorithms:  表示使用 RSASSA-PKCS1-v1_5[RFC8017]
      和[SHS]中定义的相应散列算法的签名算法。这些值仅指出现在证书中的签名(参见
      第4.4.2.2节)，并未定义为在签名的TLS握手消息中使用，尽管为了与TLS 1.2向后
      兼容，它们可能出现在“Signature_Algorithms”
      和“Signature_Algorithms_cert”中。
 
   ECDSA algorithms:  表示使用ECDSA[ECDSA]的签名算法，ANSI X9.62[ECDSA]
      和 FIPS 186-4[DSS]中定义的相应曲线，以及[SHS]中定义的相应散列算法。签名
      表示为DER编码的[X690]ECDSA-sig-value结构。
 
   RSASSA-PSS RSAE algorithms:  表示使用带有掩码生成函数1的
      RSASSA-PSS[RFC8017]的签名算法。掩码生成函数中使用的摘要和正在签名的摘要
      都是[SHS]中定义的相应散列算法。Salt的长度必须等于摘要算法的输出长度。如果
      公钥在X.509证书中携带，则必须使用rsaEncryption OID[RFC5280]。
 
   EdDSA algorithms:  表示使用[RFC8032]或其后继者中定义的EdDSA的签名算法。
      请注意，这些对应于“PureEdDSA”算法，而不是“Manage”变体。
 
   RSASSA-PSS PSS algorithms:  表示使用带有掩码生成函数1的
      RSASSA-PSS[RFC8017]的签名算法。掩码生成函数中使用的摘要和正在签名的摘要
      都是[SHS]中定义的相应散列算法。Salt的长度必须等于摘要算法的长度。如果公钥
      在X.509证书中携带，则必须使用 RSASSA-PSS OID[RFC5756]。在证书签名中使用
      时，必须对算法参数进行DER编码。如果存在相应的公钥参数，则签名中的参数必须与
      公钥中的参数相同。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Legacy algorithms:  表示由于使用具有已知弱点的算法而被弃用的算法，特别是在此
      上下文中与使用(1)RSASSA-PKCS1-v1_5或(2)ECDSA的RSA一起使用的SHA-1。这些
      值仅指出现在证书中的签名(参见第4.4.2.2节)，并未定义为在签名的TLS握手消息中
      使用，尽管为了与TLS 1.2向后兼容，它们可能出现在“Signature_Algorithms”和
      “Signature_Algorithms_cert”中。端点不应协商这些算法，但允许这样做只是
      为了向后兼容。提供这些值的客户端必须将它们列为最低优先级(列在
      SignatureSchemeList中的所有其他算法之后)。TLS 1.3服务器不得提供SHA-1
      签名的证书，除非没有它就无法产生有效的证书链(参见第4.4.2.2节)。
 
   自签名证书上的签名或作为信任锚的证书上的签名不会被验证，因为它们开始了一个证书路径
   (参见[RFC5280]，第 3.2节)。开始认证路径的证书可以使用在
   “signature_algorithms”扩展中未被宣传为受支持的签名算法。
 
   请注意，TLS 1.2对此扩展的定义有所不同。愿意协商TLS 1.2的TLS 1.3实现在协商
   该版本时必须符合[RFC5246]的要求。特别是：
 
   -  TLS 1.2客户端Hellos可以省略此扩展。
 
   -  在TLS 1.2中，扩展包含散列/签名对。这些对以两个二进制八位数编码，因此已
      分配SignatureScheme值以与TLS 1.2的编码对齐。一些遗留对未分配。从TLS 1.3
      开始，不推荐使用这些算法。任何实施都不能提供或协商它们。特别是，不能使用
      MD5[SLOTH]、SHA-224和DSA。
 
   -  ECDSA签名方案与TLS 1.2的ECDSA散列/签名对一致。然而，旧的语义并没有约束
      签名曲线。如果TLS 1.2被协商，实现必须准备接受使用他们在“supported_groups”
      扩展中通告的任何曲线的签名。
 
   -  发布对 RSASSA-PSS 的支持（TLS 1.3 中是强制性的）的实现必须准备好接受使用
      该方案的签名，即使协商 TLS 1.2 也是如此。 在 TLS 1.2 中，RSASSA-PSS 与
      RSA 密码套件一起使用。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.4.  Certificate Authorities
 
   “certificate_authority” 扩展用于指示端点支持的证书颁发机构(CA)，以及接收端点
   应该使用哪些证书颁发机构来指导证书选择。
 
   “certificate_authority”扩展的主体由CertificateAuthoritiesExtension结构
   组成。
 
      opaque DistinguishedName&lt;1..2^16-1&gt;;
 
      struct {
          DistinguishedName authorities&lt;3..2^16-1&gt;;
      } CertificateAuthoritiesExtension;
 
   authorities:  可接受的证书颁发机构的可分辨名称[X501]的列表，以DER编码的
      [X690]格式表示。这些可分辨名称为信任锚或从属CA指定了所需的可分辨名称；因此，
      此消息可用于描述已知的信任锚以及所需的授权空间。
 
   客户端可以在ClientHello消息中发送“certificate_authority”扩展。服务器可以
   在 CertificateRequest 消息中发送它。
 
   “Trusted_ca_keys”扩展[RFC6066]具有类似的用途，但更为复杂，在TLS 1.3中
   未使用(尽管它可能出现在来自提供先前版本的TLS的客户端的ClientHello消息中)。
 
4.2.5.  OID Filters
 
   “oid_filters”扩展允许服务器提供一组OID/值对，它希望客户端的证书匹配这些
   OID/值对。如果服务器提供此扩展，则只能在 CertificateRequest 消息中发送。
 
      struct {
          opaque certificate_extension_oid&lt;1..2^8-1&gt;;
          opaque certificate_extension_values&lt;0..2^16-1&gt;;
      } OIDFilter;
 
      struct {
          OIDFilter filters&lt;0..2^16-1&gt;;
      } OIDFilterExtension;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   filters:  证书扩展OID[RFC5280]及其允许值的列表，并以DER编码的[X690]格式
      表示。一些证书扩展OID允许多个值(例如，扩展密钥用法)。如果服务器包含非空筛选器
      列表，则响应中包含的客户端证书必须包含客户端识别的所有指定扩展OID。对于客户端
      识别的每个扩展OID，所有指定的值都必须存在于客户端证书中(但证书也可以具有其他
      值)。但是，客户端必须忽略并跳过任何无法识别的证书扩展OID。如果客户端忽略了一些
      所需的证书扩展OID，并提供了一个不满足请求的证书，则服务器可以在不进行客户端
      身份验证的情况下继续连接，或者通过“unsupported_certificate”警报中止握手。
      任何给定的OID不得在筛选器列表中出现一次以上。
 
   PKIX RFC定义了各种证书扩展OID及其相应的值类型。根据类型的不同，匹配的证书扩展值
   不一定是逐位相等的。预计TLS实现将依赖于其PKI库来使用证书扩展OID执行证书选择。
 
   本文档为[RFC5280]中定义的两个标准证书扩展定义了匹配规则：
 
   -  当请求中断言的所有密钥使用位也在密钥使用证书扩展中断言时，证书中的密钥使用扩展
      与请求相匹配。
 
   -  证书中的扩展密钥使用扩展与请求匹配，此时请求中存在的所有关键用途 OID 也位于
      扩展密钥使用证书扩展中。 请求中不得使用任何扩展密钥使用 OID 的特殊键。
 
   单独的规范可以为其他证书扩展定义匹配规则。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.6.  Post-Handshake Client Authentication
 
   “post_handshak_auth”扩展用于表示客户端愿意执行握手后身份验证(第4.6.2节)。
   服务器不能向不提供此扩展的客户端发送握手后CertificateRequest。服务器不得发送
   此扩展。
 
      struct {} PostHandshakeAuth;
 
   “post_handshak_auth”扩展的“extension_data”字段长度为零。
 
4.2.7.  Supported Groups
 
   当客户端发送时，“supported_groups”扩展表示客户端支持的用于密钥交换的命名组，
   按从最优先到最不优先的顺序排列。
 
   注意：在TLS 1.3之前的TLS版本中，此扩展为“椭圆曲线”，并且仅包含椭圆曲线组。
   参见[RFC8422]和[RFC7919]。此扩展也用于协商ECDSA曲线。签名算法现在是独立协商
   的(参见第4.2.3节)。
 
   此扩展的“extension_data”字段包含一个“NamedGroupList”值：
 
      enum {
 
          /* Elliptic Curve Groups (ECDHE) */
          secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
          x25519(0x001D), x448(0x001E),
 
          /* Finite Field Groups (DHE) */
          ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),
          ffdhe6144(0x0103), ffdhe8192(0x0104),
 
          /* Reserved Code Points */
          ffdhe_private_use(0x01FC..0x01FF),
          ecdhe_private_use(0xFE00..0xFEFF),
          (0xFFFF)
      } NamedGroup;
 
      struct {
          NamedGroup named_group_list&lt;2..2^16-1&gt;;
      } NamedGroupList;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Elliptic Curve Groups (ECDHE):  表示支持相应的命名曲线，在FIPS 186-4[DSS]
      或[RFC7748]中定义。值0xFE00至0xFEFF保留供私人使用[RFC8126]。
 
   Finite Field Groups (DHE):  表示对[RFC7919]中定义的相应有限域组的支持。
      值0x01FC至0x01FF保留供私人使用。
 
   named_group_list 中的项目根据发件方的偏好排序(最优先选择)。
 
   从TLS 1.3开始，允许服务器向客户端发送“supported_groups”扩展。在成功完成握手
   之前，客户端不能根据在“supported_groups”中找到的任何信息采取行动，但可以使用从
   成功完成的握手中学到的信息来更改它们在后续连接中使用的“key_share”扩展中的组。
   如果服务器具有比“key_share”扩展中的组更喜欢的组，但仍愿意接受ClientHello，则
   应发送“supported_groups”以更新客户端的首选项视图；此扩展应包含服务器支持的所有
   组，无论客户端当前是否支持这些组。
 
4.2.8.  Key Share
 
   “key_share”扩展包含端点的加密参数。
 
   客户端可能会发送空的client_shares 向量，以便向服务器请求组选择，代价是额外的往返
   (参见第4.1.4节)。
 
      struct {
          NamedGroup group;
          opaque key_exchange&lt;1..2^16-1&gt;;
      } KeyShareEntry;
 
   group:  正在交换的密钥的命名组。
 
   key_exchange:  密钥交换信息。此字段的内容由指定的组及其相应的定义确定。有限域
      Diffie-Hellman[DH76]参数在4.2.8.1节中描述；椭圆曲线Diffie-Hellman参数
      在4.2.8.2节中描述。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   在ClientHello消息中，该扩展的“extension_data”字段包含一个
   “KeyShareClientHello”值：
 
      struct {
          KeyShareEntry client_shares&lt;0..2^16-1&gt;;
      } KeyShareClientHello;
 
   client_shares:  按客户端首选项的降序排列的提供的KeyShareEntry值的列表。
 
   如果客户端正在请求HelloRetryRequest，则此向量可能为空。每个KeyShareEntry值
   必须对应于“supported_groups”扩展中提供的组，并且必须以相同的顺序出现。然而，
   这些值可以是“supported_groups”扩展的非连续子集，并且可以省略最优选的组。如果
   最优先的群体是新的，而且不太可能在足够的地方得到支持，以便预先生成关键份额，则
   可能会出现这种情况。
 
   客户端可以提供与其提供的支持组数量相同的KeyShareEntry值，每个组代表一组密钥交换
   参数。例如，客户可能提供几条椭圆曲线或多个FFDHE组的份额。必须独立生成每个
   KeyShareEntry的key_exchange值。客户端不能为同一组提供多个KeyShareEntry值。
   客户端不得为客户端的“Supported_Groups”扩展中未列出的组提供任何KeyShareEntry
   值。服务器可以检查是否违反了这些规则，如果有违反，则中止握手，并发出
   “illegal_parameter”警报。
 
   在HelloRetryRequest消息中，此扩展的“extension_data”字段包含
   KeyShareHelloRetryRequest值：
 
      struct {
          NamedGroup selected_group;
      } KeyShareHelloRetryRequest;
 
   selected_group:  服务器打算协商的相互支持的组，并请求重试的客户端
      Hello/KeyShare。
 
   在HelloRetryRequest中接收到此扩展后，客户端必须验证(1)selected_group字段
   对应于原始ClientHello中的“supported_groups”扩展中提供的组，以及
   (2)selected_group字段不对应于原始 ClientHello 中的 “Key_Share”扩展中提供
   的组。如果这两个检查中的任何一个失败，则客户端必须中止握手并发出
   “illegal_parameter”警报。否则，在发送新的 ClientHello 时，客户端必须将原始
   的“key_share”扩展替换为仅包含触发HelloRetryRequest的selected_group字段中
   指示的组的新KeyShareEntry的扩展。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 


 
   在ServerHello消息中，此扩展的“extension_data”字段包含KeyShareServerHello
   值：
 
      struct {
          KeyShareEntry server_share;
      } KeyShareServerHello;
 
   server_share:  与client's shares之一在同一组中的单个KeyShareEntry值。
 
   如果使用(EC)DHE密钥建立，服务器在ServerHello中只提供一个KeyShareEntry。
   此值必须与服务器为协商的密钥交换选择的客户端提供的KeyShareEntry值在同一组中。
   服务器不得为客户端的“Supported_Groups”扩展中未指明的任何组发送
   KeyShareEntry，也不得在使用“PSK_ke”PskKeyExchangeMode时发送
   KeyShareEntry。如果客户端收到使用(EC)DHE密钥建立和包含“KEY_SHARE”扩展
   的HelloRetryRequest，则客户端必须验证ServerHello中选定的NamedGroup与
   HelloRetryRequest中的NamedGroup相同。如果此检查失败，客户端必须中止握手并
   发出“illegal_parameter”警报。
 
4.2.8.1.  Diffie-Hellman Parameters
 
   客户端和服务器的Diffie-Hellman[DH76]参数都编码在KeyShare结构中
   KeyShareEntry的不透明KEY_EXCHANGE字段中。OPAQUE值包含指定组的
   Diffie-Hellman公共值(Y=g^X mod p)(有关组定义，请参阅[RFC7919])，编码为
   大端整数，并在左侧填充0，大小为p(以字节为单位)。
 
   注意：对于给定的Diffie-Hellman组，填充会导致所有公钥具有相同的长度。
 
   对等点必须通过确保1</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.8.2.  ECDHE Parameters
 
   客户端和服务器的ECDHE参数都编码在KeyShare结构中KeyShareEntry的不透明
   KEY_EXCHANGE字段中。
 
   对于secp256r1、secp384r1和secp521r1，内容是以下struct的序列化值：
 
      struct {
          uint8 legacy_form = 4;
          opaque X[coordinate_length];
          opaque Y[coordinate_length];
      } UncompressedPointRepresentation;
 
   X和Y分别是网络字节顺序中x和y值的二进制表示。没有内部长度标记，因此每个数字表示
   占用与曲线参数所暗示的一样多的二进制八位数。对于P-256，这意味着X和Y中的每一个都
   使用32个二进制八位数，如有必要，在左侧用零填充。对于P-384，他们每个采取48个八位
   组。对于P-521，他们每个采取66个八位组。
 
   对于曲线secp256r1、secp384r1和secp521r1，对等节点必须通过确保该点是椭圆曲线
   上的有效点来验证彼此的公共值Q。适当的验证程序在[ECDSA]的第4.3.7节中定义，或者在
   [KEYAGREEMENT]的第5.6.2.3节中定义。这个过程包括三个步骤：(1)验证q不是无穷远处
   的点(O)，(2)验证对于q=(x，y)整数x和y都在正确的区间内，以及(3)确保(x，y)是椭圆
   曲线方程的正确解。对于这些曲线，实现者不需要验证正确子组中的成员资格。
 
   对于X25519和X448，公共值的内容是[RFC7748]中定义的相应函数的字节串输入和
   输出：X25519为32字节，X448为56字节。
 
   注意：1.3之前的TLS版本允许点格式协商；TLS 1.3删除了此功能，支持每条曲线的
   单点格式。
 
4.2.9.  Pre-Shared Key Exchange Modes
 
   为了使用PSK，客户端还必须发送“psk_key_exchange_modes”扩展。此扩展的语义是
   客户端仅支持使用具有这些模式的PSK，这限制了在此ClientHello中提供的PSK的使用，
   以及服务器可能通过NewSessionTicket提供的PSK的使用。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   如果客户端提供“pre_shared_key”扩展，则它必须提供“psk_key_exchange_modes”
   扩展。如果客户端提供的“pre_shared_key”不带“psk_key_exchange_modes”扩展，
   则服务器必须中止握手。服务器不得选择客户端未列出的密钥交换模式。此扩展还限制了
   用于PSK恢复的模式。服务器不应发送带有与通告模式不兼容的票证的NewSessionTicket；
   但是，如果服务器这样做，其影响只会是客户端的恢复尝试失败。
 
   服务器不得发送“psk_key_exchange_modes”扩展。
 
      enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;
 
      struct {
          PskKeyExchangeMode ke_modes&lt;1..255&gt;;
      } PskKeyExchangeModes;
 
   psk_ke:  仅PSK密钥建立。在此模式下，服务器不得提供“key_share”值。
 
   psk_dhe_ke:  PSK与(EC)DHE密钥建立。在此模式下，客户端和服务器必须提供
       “key_share”值，如第4.2.8节所述。
 
   分配的任何未来值必须确保传输的协议消息明确地标识服务器选择了哪种模式；目前，这是
   由ServerHello中存在的“key_share”指示的。
 
4.2.10.  Early Data Indication
 
   当使用PSK并且允许该PSK的早期数据时，客户端可以在其第一次发送消息时发送应用程序
   数据。如果客户端选择这样做，它必须同时提供“pre_shared_key”和“Early_Data”
   扩展。
 
   此扩展的“extension_data”字段包含一个“EarlyDataIndication”值。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
      struct {} Empty;
 
      struct {
          select (Handshake.msg_type) {
              case new_session_ticket:   uint32 max_early_data_size;
              case client_hello:         Empty;
              case encrypted_extensions: Empty;
          };
      } EarlyDataIndication;
 
   有关max_early_data_size 字段使用的详细信息，请参阅第4.6.1节。
 
   0-RTT数据的参数(版本、对称密码组、应用层协议协商(ALPN)[RFC7301]协议等)。是与
   正在使用的PSK相关联的那些。对于外部调配的PSK，关联值是与密钥一起调配的值。对于
   通过 NewSessionTicket 消息建立的PSK，关联值是在建立 PSK 的连接中协商的那些
   值。用于加密早期数据的PSK必须是客户端的“pre_shared_key”扩展中列出的第一个PSK。
 
   对于通过 NewSessionTicket 提供的PSK，服务器必须验证所选PSK身份(通过从
   PskIdentity.obfuscated_ticket_age % 2^32 - Ticket_age_add计算)的票龄
   在自票证发出后的时间容差内(参见第8节)。如果不是，则服务器应继续握手，但拒绝
   0-RTT，并且不应采取任何其他假定此ClientHello是新的操作。
 
   在第一个航班中发送的0-RTT消息与在其他航班中发送的相同类型的消息(握手和应用数据)
   具有相同的(加密的)内容类型，但受到不同密钥的保护。在接收到服务器的完成消息后，
   如果服务器已经接受了早期数据，则会发送EndOfEarlyData消息以指示密钥更改。此消息
   将使用0-RTT业务密钥进行加密。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   接收“early_data”扩展的服务器必须采用以下三种方式之一：
 
   -  忽略扩展并返回常规的 1-RTT 响应。 然后，服务器会跳过过去的早期数据，尝试使用
      握手流密钥取消对接收到的记录层的保护，丢弃未能取消保护的记录数据（最多为配置的
      max_early_data_size）。 一旦记录层被成功取消保护，它将被视为客户端第二次
      消息的开始，服务器继续执行普通 1-RTT 握手。
 
   -  请求客户端通过响应 HelloRetryRequest 发送另一个 ClientHello 。 客户端
      不得在其后续 ClientHello 中包含"early_data"扩展。 然后，服务器通过跳过
      外部内容类型为"application_data"（指示它们已加密）的所有记录来忽略早期
      数据，最长为已配置的 max_early_data_size。
 
   -  在EncryptedExtensions中返回自己的“early_data”扩展，表示打算处理早期数据。
      服务器不可能仅接受早期数据消息的子集。即使服务器发送接受早期数据的消息，实际的
      早期数据本身在服务器生成此消息时可能已经在运行。
 








   为了接受早期数据，服务器必须接受PSK密码套件并选择客户端的“pre_shared_key”扩展
   中提供的第一个密钥。此外，它必须验证以下值是否与所选PSK关联的值相同：
 
   -  TLS版本号
 
   -  选定的密码套件
 
   -  所选ALPN[RFC7301]协议(如果有)
 
   这些要求是使用所讨论的 PSK 执行 1-RTT 握手所需的那些要求的超集。对于外部建立的
   PSK，关联值是与密钥一起提供的值。对于通过 NewSessionTicket 消息建立的 PSK，
   关联值是在建立票证的连接中协商的那些值。
 
   未来的扩展必须定义它们与0-RTT的交互。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   如果这些检查中的任何一个失败，服务器必须不响应扩展，并且必须使用上面列出的前两个
   机制之一丢弃所有的第一波发送数据(因此回退到1-RTT或2-RTT)。如果客户端尝试0-RTT
   握手，但服务器拒绝它，则服务器通常不具有0-RTT记录保护密钥，并且必须改为使用试用
   解密(或者使用1-RTT握手密钥，或者通过在HelloRetryRequest的情况下通过查找明文
   ClientHello)来找到第一个非0-RTT消息。
 
   如果服务器选择接受“early_data”扩展，则在处理早期数据记录时，它必须符合为所有
   记录指定的相同错误处理要求。具体地说，如果服务器在接受的“early_data”扩展之后
   未能解密0-RTT记录，则必须按照5.2节的规定使用“bad_record_mac”警报终止连接。
 
   如果服务器拒绝“early_data”扩展，则一旦握手完成，客户端应用程序可以选择重新传输
   先前在early_data中发送的应用程序数据。注意，早期数据的自动重传可能导致关于连接
   状态的不正确假设。例如，当协商的连接选择与用于早期数据的ALPN协议不同的ALPN协议
   时，应用程序可能需要构造不同的消息。同样，如果早期数据假定有关连接状态的任何内容，
   则可能在握手完成后错误地发送。
 
   TLS实现不应自动重新发送早期数据；应用程序可以更好地决定何时重新传输是合适的。
   除非协商的连接选择相同的ALPN协议，否则TLS实现不得自动重新发送早期数据。
 












4.2.11.  Pre-Shared Key Extension
 
   “pre_shared_key”扩展用于协商与PSK密钥建立关联的给定握手使用的预共享密钥的身份。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   此扩展的“extension_data”字段包含“PreSharedKeyExtension”值：
 
      struct {
          opaque identity&lt;1..2^16-1&gt;;
          uint32 obfuscated_ticket_age;
      } PskIdentity;
 
      opaque PskBinderEntry&lt;32..255&gt;;
 
      struct {
          PskIdentity identities&lt;7..2^16-1&gt;;
          PskBinderEntry binders&lt;33..2^16-1&gt;;
      } OfferedPsks;
 
      struct {
          select (Handshake.msg_type) {
              case client_hello: OfferedPsks;
              case server_hello: uint16 selected_identity;
          };
      } PreSharedKeyExtension;
 
   identity:  密钥标签。例如，票证(如附录B.3.4中所定义)或外部建立的预共享密钥的
      标签。
 
   obfuscated_ticket_age:  密钥年龄的模糊版本。第4.2.11.1节描述了如何为通过
      NewSessionTicket 消息建立的身份形成此值。对于外部建立的身份，应使用0的
      obfuscated_ticket_age，并且服务器必须忽略该值。
 
   identities:  客户端愿意与服务器协商的身份列表。如果与“early_data”扩展一起发送
      (参见第4.2.10节)，则第一个身份是用于0-RTT数据的身份。
 
   binders:  一系列HMAC值，每个值对应身份列表中的每个值，并按相同的顺序进行计算，
      如下所述。
 
   selected_identity:  服务器选择的标识，表示为客户端列表中标识的(从0开始)索引。
 






   每个PSK与单个散列算法相关联。对于通过票证机制建立的PSK(第4.6.1节)，这是建立
   票证的连接上的KDF哈希算法。对于外部建立的PSK，在建立PSK时必须设置Hash算法，如果
   未定义此类算法，则默认设置为SHA-256。服务器必须确保它选择兼容的PSK(如果有的话)
   和密码套件。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   
 
   在TLS 1.3之前的TLS版本中，服务器名称标识(SNI)值旨在与会话相关联(
   [RFC6066]的第3节)，要求服务器强制与会话关联的SNI值与恢复握手中指定的SNI值相
   匹配。然而，在现实中，对于它们将使用两个提供的SNI值中的哪一个，实现并不一致，导致
   客户端事实上强制执行一致性要求。在TLS 1.3中，SNI值总是在恢复握手中显式指定，
   服务器不需要将SNI值与票证相关联。然而，客户应将SNI与PSK一起存储，以满足
   第4.6.1节的要求。
 








   实现者注意：当会话恢复是PSK的主要用例时，实现PSK/密码套件匹配要求的最直接的方法
   是首先协商密码套件，然后排除任何不兼容的PSK。应该简单地忽略任何未知的PSK(例如，
   不在PSK数据库中或用未知密钥加密的PSK)。如果未找到可接受的PSK，则服务器应执行
   非PSK握手(如果可能)。如果向后兼容性很重要，客户端提供的外部建立的PSK应该会影响
   密码套件的选择。
 



   在接受PSK密钥建立之前，服务器必须验证相应的绑定器值(参见下面的4.2.11.2节)。
   如果此值不存在或未验证，则服务器必须中止握手。服务器不应尝试验证多个绑定器；相反，
   它们应该选择单个PSK并仅验证对应于该PSK的绑定器。有关此要求的安全理由，请参见
   第8.2节和附录E.6。为了接受PSK密钥建立，服务器发送指示所选身份的
   “pre_shared_key”扩展。
 
   客户端必须验证服务器的selected_identity是否在客户端提供的范围内，服务器是否
   选择了指示与PSK关联的哈希的密码套件，以及如果 ClientHello
   “psk_key_exchange_modes”扩展需要，服务器“key_share”扩展是否存在。如果这些值
   不一致，客户端必须中止握手并发出“illegal_parameter”警报。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   如果服务器提供了“early_data”扩展名，则客户端必须验证服务器的selected_identity
   是否为0。如果返回任何其他值，则客户端必须中止握手并发出“illegal_parameter”
   警报。
 
   “pre_shared_key”扩展名必须是ClientHello中的最后一个扩展名(这便于实现，如下
   所述)。服务器必须检查它是否是最后一个扩展名，否则握手失败，并显示
   “illegal_parameter” 警报。
 
4.2.11.1.  Ticket Age
 
   客户端对票龄的看法是自收到 NewSessionTicket 消息以来的时间。客户端不得尝试使用
   年龄大于随票证提供的“ticket_lifetime”值的票证。每个PskIdentity的
   “obfuscated_ticket_age” 字段包含一个模糊版本的票龄，其形成方式是以毫秒为单位
   取年龄并添加票证附带的“ticket_age_add”值(参见第4.6.1节)，模数为2^32。此添加
   可防止被动观察者关联连接，除非重新使用票证。请注意，NewSessionTicket消息中的
   “ticket_lifetime”字段以秒为单位，而“obfuscated_ticket_age”以毫秒为单位。
   由于票证寿命被限制为一周，因此32位足以表示任何合理的年龄，即使以毫秒为单位。
 
4.2.11.2.  PSK Binder
 
   PSK 绑定器值在 PSK 和当前握手之间形成绑定，以及在生成 PSK 的握手（如果通过
   NewSessionTicket消息）和当前握手之间的绑定。绑定器列表中的每个条目都被计算为
   基于包含部分ClientHello的哈希值，包括PreSharedKeyExtension.identities的
   HMAC。也就是说，它包括所有ClientHello，但不包括绑定器列表本身。消息的长度字段
   (包括总长度、扩展块的长度和“pre_shared_key”扩展的长度)都被设置为好像存在正确
   长度的绑定器一样。
 
   PskBinderEntry的计算方法与Finished消息相同(第4.4.4节)，但BaseKey是通过密钥
   进度表从提供的相应PSK导出的binder_key(参见7.1节)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   如果握手包括 HelloRetryRequest，则初始客户端Hello和 HelloRetry请求将连同
   新的ClientHello一起包含在记录中。 例如，如果客户端发送 ClientHello1，其
   绑定器将通过以下方式计算：
 
      Transcript-Hash(Truncate(ClientHello1))
 
   其中 Truncate() 从ClientHello 中删除绑定器列表。
 
   如果服务器响应HelloRetryRequest，然后客户端发送ClientHello2，则将计算其绑定：
 
      Transcript-Hash(ClientHello1,
                      HelloRetryRequest,
                      Truncate(ClientHello2))
 
   完整的ClientHello1/ClientHello2包含在所有其他握手散列计算中。请注意，在
   第一波发送中，Truncate(ClientHello1)直接进行散列，但在第二波发送中，对
   ClientHello1进行散列，然后作为“message_hash”消息重新注入，如第4.4.1节所述。
 
4.2.11.3.  Processing Order
 
   允许客户端“流式传输”0-RTT数据，直到它们接收到服务器完成，然后才发送
   EndOfEarlyData消息，然后是握手的其余部分。为了避免死锁，在接受“early_data”
   时，服务器必须处理客户端的ClientHello，然后立即发送它们的消息，而不是在发送
   ServerHello之前等待客户端的EndOfEarlyData消息。
 
4.3.  Server Parameters
 
   接下来来自服务器的两条消息 EncryptedExtensions 和 CertificateRequest 包含
   来自服务器的信息，这些信息决定了握手的其余部分。使用从
   server_handshake_traffic_secret派生的密钥对这些消息进行加密。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.3.1.  Encrypted Extensions
 
   在所有握手中，服务器必须在ServerHello消息之后立即发送EncryptedExtensions
   消息。这是在从server_handshak_traffic_secret派生的密钥下加密的第一条消息。
 
   加密扩展消息包含可受保护的扩展，即任何不需要建立加密上下文但不与单个证书关联的
   扩展。客户端必须检查EncryptedExtensions是否存在任何禁止的扩展，如果发现任何
   扩展，则必须中止握手并发出“illegal_parameter”警报。
 
   Structure of this message:
 
      struct {
          Extension extensions&lt;0..2^16-1&gt;;
      } EncryptedExtensions;
 
   extensions:  扩展列表。有关更多信息，请参见4.2节中的表格。
 
4.3.2.  Certificate Request
 
   使用证书进行身份验证的服务器可以可选地向客户端请求证书。如果发送此消息，则必须在
   EncryptedExtensions之后。
 
   Structure of this message:
 
      struct {
          opaque certificate_request_context&lt;0..2^8-1&gt;;
          Extension extensions&lt;2..2^16-1&gt;;
      } CertificateRequest;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   certificate_request_context:  标识证书请求并将在客户端的证书消息中回显的
      字符串。certificate_request_context 在此连接范围内必须是唯一的(从而防止
      客户端 CertificateVerify 消息的重播)。此字段应为零长度，除非用于4.6.2节
      中描述的握手后身份验证交换。当请求握手后身份验证时，服务器应使上下文对客户端
      不可预测(例如，通过随机生成上下文)，以防止对客户端私钥具有临时访问权限的
      攻击者预先计算有效的CertificateVerify消息。
 
   extensions:  描述所请求证书的参数的一组扩展。必须指定“signature_algorithms”
      扩展，如果为此消息定义了其他扩展，则可以选择包括其他扩展。客户端必须忽略无法
      识别的扩展。
 







   在TLS的以前版本中，CertificateRequest消息包含服务器将接受的签名算法和证书颁发
   机构的列表。在TLS 1.3中，前者通过发送“signature_algorithms”和可选的
   “signature_algorithms_cert”扩展来表示。后者通过发送
   “certificate_authority”扩展来表示(参见第4.2.4节)。
 
   使用PSK进行身份验证的服务器不得在主握手中发送CertificateRequest消息，尽管它们
   可以在握手后身份验证中发送该消息(参见第4.6.2节)，但前提是客户端已发送
   “post_handshak_auth”扩展(参见第4.2.6节)。
 

4.4.  Authentication Messages
 
   如第2节所述，TLS通常使用一组通用的消息进行身份验证、密钥确认和握手
   完整性：Certificate、CertificateVerify和Finish。(PSK绑定器也以类似的方式
   执行密钥确认。)。这三条消息总是作为他们握手发送中的最后一条消息发送。Certificate
   和CertificateVerify 消息仅在某些情况下发送，定义如下。完成的消息始终作为身份
   验证块的一部分发送。这些消息在从 [sender]_handshake_traffic_secret 派生的
   密钥下进行加密。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   验证消息的计算都统一采用以下输入:
 
   -  要使用的证书和签名密钥
 
   -  握手上下文，由要包含在记录散列中的一组消息组成。
 
   -  用于计算MAC密钥的基础密钥。
 
   基于这些输入，消息随后添加：
 
   Certificate:  用于身份验证的证书，以及链中的任何支持证书。请注意，基于证书的
      客户端身份验证在PSK握手流(包括0-RTT)中不可用。
 
   CertificateVerify:  Hash(Handshake Context, Certificate)的签名
 
   Finished:  使用从基密钥派生的MAC密钥在 Transcript-Hash(Handshake   
      Context, Certificate，CertificateVerify) 的值上进行MAC。
 
   下表定义了每个场景的握手上下文和MAC基础密钥：
 
   +-----------+-------------------------+-----------------------------+
   | Mode      | Handshake Context       | Base Key                    |
   +-----------+-------------------------+-----------------------------+
   | Server    | ClientHello ... later   | server_handshake_traffic_   |
   |           | of EncryptedExtensions/ | secret                      |
   |           | CertificateRequest      |                             |
   |           |                         |                             |
   | Client    | ClientHello ... later   | client_handshake_traffic_   |
   |           | of server               | secret                      |
   |           | Finished/EndOfEarlyData |                             |
   |           |                         |                             |
   | Post-     | ClientHello ... client  | client_application_traffic_ |
   | Handshake | Finished +              | secret_N                    |
   |           | CertificateRequest      |                             |
   +-----------+-------------------------+-----------------------------+</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.4.1.  The Transcript Hash
 
   TLS 中的许多加密计算都使用Transcript哈希。 此值是通过对包含的每个握手消息（包括
   包含握手消息类型和长度字段的握手消息标头）的串联进行哈希计算的，但不包括记录层
   标头。即：
 
    Transcript-Hash(M1, M2, ... Mn) = Hash(M1 || M2 || ... || Mn)
 
   作为此一般规则的例外情况，当服务器使用 HelloRetryRequest 响应 ClientHello
   时，ClientHello1  的值将替换为包含哈希（ClientHello1）的握手类型为
   "message_hash" 的特殊合成握手消息。 即
 
  Transcript-Hash(ClientHello1, HelloRetryRequest, ... Mn) =
      Hash(message_hash ||        /* Handshake type */
           00 00 Hash.length  ||  /* Handshake message length (bytes) */
           Hash(ClientHello1) ||  /* Hash of ClientHello1 */
           HelloRetryRequest  || ... || Mn)
 
   这种构造的原因是允许服务器通过在cookie中仅存储ClientHello1的散列来执行无状态
   HelloRetryRequest，而不是要求它导出整个中间散列状态(参见第4.2.2节)。
 
   为具体起见，始终从以下握手消息序列中提取记录散列，从第一个ClientHello开始，并且
   仅包括发送的那些消息：ClientHello，HelloRetryRequest，ClientHello，
   ServerHello，EncryptedExtensions，server CertificateRequest，
   server Certificate，server CertificateVerify，Server Finish，
   EndOfEarlyData，Client Certificate，Client CertificateVerify，
   Client Finish。

 
   通常，实现可以通过基于协商的散列保持运行的Transcript Hash来实现抄本。然而，
   请注意，后续的握手后身份验证不包括彼此，只包括通过主握手结束的消息。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.4.2.  Certificate
 
   此消息将端点的证书链传递给对等体。
 
   每当商定的密钥交换方法使用证书进行身份验证时，服务器必须发送证书消息(这包括本文档
   中定义的所有密钥交换方法，PSK除外)。
 
   当且仅当服务器通过CertificateRequest消息请求客户端身份验证时，客户端必须发送
   证书消息(第4.3.2节)。如果服务器请求客户端身份验证，但没有合适的证书可用，则客户端
   必须发送不包含证书的证书消息(即，“certificate_list”字段的长度为0)。无论证书
   消息是否为空，都必须发送 Finished 消息。
 
   Structure of this message:
 
      enum {
          X509(0),
          RawPublicKey(2),
          (255)
      } CertificateType;
 
      struct {
          select (certificate_type) {
              case RawPublicKey:
                /* From RFC 7250 ASN.1_subjectPublicKeyInfo */
                opaque ASN1_subjectPublicKeyInfo&lt;1..2^24-1&gt;;
 
              case X509:
                opaque cert_data&lt;1..2^24-1&gt;;
          };
          Extension extensions&lt;0..2^16-1&gt;;
      } CertificateEntry;
 
      struct {
          opaque certificate_request_context&lt;0..2^8-1&gt;;
          CertificateEntry certificate_list&lt;0..2^24-1&gt;;
      } Certificate;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   certificate_request_context:  如果此消息响应CertificateRequest，则为该
      消息中certificate_request_context的值。否则(在服务器身份验证的情况下)，
      此字段应为零长度。
 
   certificate_list:  CertificateEntry结构的序列(链)，每个结构包含一个证书和
      一组扩展。
 
   extensions:  CertificateEntry的一组扩展值。“扩展”格式在4.2节中定义。目前
      服务器证书的有效扩展包括OCSP状态扩展[RFC6066]和
      SignedCertificateTimestamp扩展[RFC6962]；也可以为此消息定义未来的扩展。
      来自服务器的证书消息中的扩展必须对应于ClientHello消息中的扩展。来自客户端
      的证书消息中的扩展必须对应于来自服务器的CertificateRequest消息中的扩展。
      如果扩展应用于整个链，则应将其包括在第一个CertificateEntry中。
 
   如果在EncryptedExtensions中未协商相应的证书类型扩展
   (“server_certificate_type” 或 “client_certificate_type”)，或者协商了
   X.509证书类型，则每个 CertificateEntry 都包含一个 DER 编码的 X.509证书 。
   发送者的证书必须位于列表中的第一个 CertificateEntry 中。每一个紧随其后的证书
   都应直接证明紧接其前的证书。因为证书验证需要独立分发信任锚点，所以可以从链中省略
   指定信任锚点的证书，前提是所支持的对等体已知拥有任何省略的证书。
 
   注意：在TLS 1.3之前，“certificate_list”排序要求每个证书对紧接它之前的证书
   进行认证；然而，一些实现允许一些灵活性。服务器有时会出于过渡目的同时发送当前和
   不推荐使用的中间件，而其他服务器只是配置不正确，但这些情况仍然可以正确地进行验证。
   为了获得最大的兼容性，所有实现都应该准备好处理来自任何TLS版本的可能无关的证书
   和任意顺序，但第一个证书必须是发送者的证书。
 
   如果协商了RawPublicKey证书类型，则certificate_list必须包含不超过一个
   CertificateEntry，其中包含一个 ASN1_SubjectPublicKeyInfo 值，
   如[RFC7250]第3节所定义。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   OpenPGP证书类型[RFC6091]不能与TLS 1.3一起使用。
 
   服务器的certificate_list必须始终为非空。如果客户端没有要发送的适当证书来响应
   服务器的身份验证请求，则它将发送一个空的certificate_list。
 
4.4.2.1.  OCSP Status and SCT Extensions
 
   [RFC6066]和[RFC6961]提供扩展以协商服务器向客户端发送OCSP响应。在TLS 1.2及
   更低版本中，服务器以空扩展回复以指示此扩展的协商，并且在CertificateStatus消息中
   携带OCSP信息。在TLS 1.3中，服务器的OCSP信息在包含相关证书的CertificateEntry
   中的扩展中携带。具体地说，来自服务器的“status_request”扩展的主体必须是
   [RFC6066]中定义的CertificateStatus结构，其解释为[RFC6960]中定义的。
 
   注意：status_request_v2 扩展[RFC6961]已弃用。在处理ClientHello消息时，
   TLS 1.3 服务器不得根据其存在或其中的信息进行操作；尤其是，它们不得在
   EncryptedExtensions、CertificateRequest 或 Certificate消息中发送
   status_request_v2扩展。TLS 1.3 服务器必须能够处理包含它的ClientHello消息，
   因为它可能由在早期协议版本中使用它的客户端发送。
 
   服务器可以通过在其CertificateRequest消息中发送空的“status_request”扩展来
   请求客户端将OCSP响应与其证书一起呈现。如果客户端选择发送OCSP响应，其
   “status_request”扩展的主体必须是[RFC6066]中定义的CertificateStatus结构。
 
   类似地，[RFC6962]为服务器提供了一种机制，用于在TLS 1.2及更低版本的ServerHello
   中发送签名证书时间戳(Signed Certificate Timestamp，SCT)作为扩展。在
   TLS 1.3中，服务器的 SCT 信息在CertificateEntry中的扩展中携带。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.4.2.2.  服务器证书选择
 
   以下规则适用于服务器发送的证书：
 
   -  证书类型必须是X.509v3[RFC5280]，除非明确协商(例如，[RFC7250])。
 
   -  服务器的最终实体证书的公钥(及相关限制)必须与从客户端的
      “signature_algorithms”扩展(当前为RSA、ECDSA或EdDSA)中选择的身份验证
      算法兼容。
 
   -  证书必须允许使用密钥进行签名(即，如果存在密钥使用扩展，则必须设置
      digitalSignature位)，并在客户端的
      “signature_algorithms”/“signature_algorithms_cert”扩展中指定签名方案
      (参见第4.2.3节)。
 
   -  “server_name”[RFC6066]和“certificate_authority”扩展名用于指导证书
      选择。由于服务器可能需要存在“server_name”扩展，因此客户端应发送此扩展
      (如果适用)。
 
   如果服务器能够提供这样的链，则服务器提供的所有证书都必须使用客户端公布的签名算法
   进行签名(见第4.2.3节)。自签名的证书或预期为信任锚的证书不作为链的一部分进行验证，
   因此可以使用任何算法进行签名。
 
   如果服务器不能产生仅通过所指示的支持的算法签名的证书链，则它应该通过向客户端发送
   其选择的证书链来继续握手，该证书链可能包括不知道客户端支持的算法。此回退链一般
   不应使用已弃用的SHA-1哈希算法，但如果客户端的广告允许，则可以这样做，否则不得
   这样做。
 
   如果客户端无法使用提供的证书构建可接受的链，并决定中止握手，则必须使用适当的证书
   相关警报中止握手(默认情况下，为“unsupported_certificate”；有关更多信息，
   请参见第6.2节)。
 
   如果服务器有多个证书，它会根据上述标准(除了其他标准，如传输层端点、本地配置和
   首选项)选择其中一个。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.4.2.3.  客户端证书选择
 
   以下规则适用于客户端发送的证书：
 
   -  证书类型必须是X.509v3[RFC5280]，除非明确协商(例如，[RFC7250])。
 
   -  如果CertificateRequest消息中存在“certificate_authority”扩展，则
      证书链中的至少一个证书应由列出的CA之一颁发。
 
   -  必须使用可接受的签名算法对证书进行签名，如第4.3.2节所述。请注意，这将放宽
      TLS以前版本中对证书签名算法的限制。
 
   -  如果CertificateRequest消息包含非空的“oid_filters”扩展，则最终实体证书
      必须与客户端识别的扩展OID相匹配，如第4.2.5节所述。
 
4.4.2.4.  接收证书消息
 
   一般来说，详细的证书验证程序超出了TLS的范围(参见[RFC5280])。本节提供特定于TLS
   的要求。
 
   如果服务器提供空的证书消息，则客户端必须中止握手并发出“decode_error”警报。
 
   如果客户端不发送任何证书(即，它发送空的证书消息)，则服务器可以在不进行客户端身份
   验证的情况下继续握手，或者使用“certificate_required”警报中止握手。此外，如果
   证书链的某些方面是不可接受的(例如，它不是由已知的、受信任的CA签署的)，则服务器
   可以根据其判断继续握手(考虑到客户端未认证)或中止握手。
 
   任何接收到需要使用任何签名算法(使用MD5散列)验证的证书的端点必须中止握手并发出
   “bad_certificate”警报。SHA-1已弃用，建议接收需要使用SHA-1散列的任何签名算法
   验证的任何证书的任何端点使用“bad_certificate”警报中止握手。为了清楚起见，
   这意味着端点可以接受自签名证书或信任锚证书的这些算法。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   建议所有端点尽快过渡到SHA-256或更好的版本，以保持与当前正在逐步取消SHA-1支持的
   实施的互操作性。
 
   注意，包含一个签名算法的密钥的证书可以使用不同的签名算法(例如，用ECDSA密钥签名
   的RSA密钥)进行签名。
 
4.4.3.  Certificate Verify
 
   此消息用于提供端点拥有与其证书相对应的私钥的明确证明。CertificateVerify 消息
   还为目前为止的握手提供了完整性。服务器在通过证书进行身份验证时必须发送此消息。
   每当通过证书进行身份验证时(即证书消息非空时)，客户端都必须发送此消息。发送时，
   此消息必须立即出现在证书消息之后，并紧接着出现在完成消息之前。
 
   Structure of this message:
 
      struct {
          SignatureScheme algorithm;
          opaque signature&lt;0..2^16-1&gt;;
      } CertificateVerify;
 
   算法字段指定使用的签名算法(有关此类型的定义，请参见第4.2.3节)。签名是使用该算法
   的数字签名。签名所涵盖的内容是第4.4.1节所述的哈希输出，即：
 
      Transcript-Hash(Handshake Context, Certificate)
 
   然后通过以下级联计算数字签名：
 
   -  由重复64次的八位字节32(0x20)组成的字符串。
 
   -  上下文字符串。
 
   -  作为分隔符的单个0字节。
 
   -  要签名的内容</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   此结构旨在防止对以前版本的TLS的攻击，其中ServerKeyExchange格式意味着攻击者
   可以获得具有所选32字节前缀(ClientHello.random)的消息的签名。初始的64字节填充
   清除该前缀以及服务器控制的ServerHello.random。
 
   服务器签名的上下文字符串是“TLS 1.3，server CertificateVerify”。客户端签名的
   上下文字符串是“TLS 1.3，Client CertificateVerify”。它用于提供在不同上下文中
   进行的签名之间的分离，有助于防止潜在的跨协议攻击。
 
   例如，如果记录散列为32字节01(此长度对于SHA-256有意义)，则服务器
   CertificateVerify 的数字签名所涵盖的内容将为：
 
      2020202020202020202020202020202020202020202020202020202020202020
      2020202020202020202020202020202020202020202020202020202020202020
      544c5320312e332c207365727665722043657274696669636174655665726966
      79
      00
      0101010101010101010101010101010101010101010101010101010101010101
 
   在发送方，CertificateVerify消息的签名字段的计算过程作为输入：
 
   -  数字签名覆盖的内容。
 
   -  前一条消息中发送的证书对应的私有签名密钥。
 
   如果CertificateVerify消息是由服务器发送的，则签名算法必须是客户端的
   “Signature_Algorithms”扩展中提供的算法，除非在没有不支持的算法的情况下无法
   生成有效的证书链(参见4.2.3节)。
 
   如果由客户端发送，则签名中使用的签名算法必须是CertificateRequest消息中
   “signature_algorithms”扩展的supported_signature_algorithms字段中存在的
   算法之一。
 
   此外，签名算法必须与发送方的最终实体证书中的密钥兼容。RSA签名必须使用RSASSA-PSS
   算法，无论“signature_algorithms”中是否出现RSASSA-PKCS1-v1_5算法。不能在
   CertificateVerify 消息的任何签名中使用SHA-1算法。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   本规范中的所有SHA-1签名算法都是专为在传统证书中使用而定义的，对于
   CertificateVerify签名无效。
 
   CertificateVerify消息的接收方必须验证签名字段。验证过程采用以下输入：
 
   -  数字签名覆盖的内容。
 
   -  包含在相关证书消息中找到的对方证书中的公钥。
 
   -  CertificateVerify消息的Signature字段中收到的数字签名。
 
   如果验证失败，接收方必须终止握手并发出“decrypt_error”警报。
 
4.4.4.  Finished
 
   Finished消息是身份验证块中的最终消息。它对于提供握手和计算出的密钥的认证是
   必不可少的。
 
   Finished消息的接收者必须验证内容是否正确，如果不正确，则必须使用
   “decrypt_error”警报终止连接。
 
   一旦一方发送了其 Finished 消息并从其对等方接收并验证了 Finished 消息，它就
   可以开始通过连接发送和接收应用程序数据。允许在接收对等体的 Finished 之前发送
   数据的设置有两种：
 
   1.  客户端发送第4.2.10节所述的0-RTT数据。
 
   2.  服务器可在发送第一波发送后发送数据，但由于握手尚未完成，因此无法保证对等方
       的身份或其活动性（即，ClientHello 可能已被重播）。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   用于计算完成消息的密钥是使用HKDF根据4.4节中定义的基本密钥计算的(参见7.1节)。
   具体而言：
 
   finished_key =
       HKDF-Expand-Label(BaseKey, "finished", "", Hash.length)
 
   Structure of this message:
 
      struct {
          opaque verify_data[Hash.length];
      } Finished;
 
   The verify_data value is computed as follows:
 
      verify_data =
          HMAC(finished_key,
               Transcript-Hash(Handshake Context,
                               Certificate*, CertificateVerify*))
 
      * Only included if present.
 
   HMAC[RFC2104]使用哈希算法进行握手。如上所述，HMAC输入通常可以通过正在运行的
   散列(即，仅在此时的握手散列)来实现。
 
   在TLS的早期版本中，VERIFY_DATA始终是12个八位字节的长度。在TLS 1.3中，它是
   用于握手的哈希的HMAC输出的大小。
 
   注意：警报和任何其他非握手记录类型不是握手消息，不包括在散列计算中。
 
   Finished消息之后的任何记录都必须按照第7.2节所述，在适当的应用流密钥下进行加密。
   特别是，这包括服务器为响应客户端Certificate 和CertificateVerify消息而发送的
   任何警报。
 
4.5.  End of Early Data
 
      struct {} EndOfEarlyData;
 
   如果服务器在EncryptedExtensions中发送了“early_data”扩展，则客户端必须在
   接收服务器 Finished 后发送 EndOfEarlyData 消息。如果服务器不在
   EncryptedExtensions中发送“early_data”扩展，则客户端不能发送EndOfEarlyData
   消息。该消息指示所有 0-RTT application_data 消息(如果有的话)都已被传输，并且
   以下记录在握手业务密钥下受到保护。服务器不能发送此消息，接收此消息的客户端必须终止
   连接，并发出“unexpected_message”警报。此消息在从
   client_early_traffic_secret派生的密钥下加密。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 


 
4.6.  Post-Handshake Messages
 
   TLS还允许在主握手之后发送其他消息。这些消息使用握手内容类型，并在适当的应用流
   密钥下加密。
 
4.6.1.  New Session Ticket Message
 
   在服务器接收到客户端 Finished 消息后的任何时间，它都可以发送NewSessionTicket
   消息。该消息在票据值和从恢复主秘密导出的秘密PSK之间创建唯一的关联(参见第7节)。
 
   客户端可以通过在其ClientHello(第4.2.11节)中的“pre_shared_key”扩展中包含
   票证值，从而将此PSK用于未来的握手。服务器可以在单个连接上发送多个票证，可以在连接
   之后立即发送，也可以在特定事件之后发送(参见附录C.4)。例如，服务器可能在握手后
   身份验证后发送新票证，以便封装额外的客户端身份验证状态。多张票证对客户有多种用途，
   包括：
 
   -  打开多个并行HTTP连接。
 
   -  通过(例如)Happy Eyeballs[RFC8305]或相关技术跨接口和寻址系列执行连接竞速。
 
   任何票证只能使用与用于建立原始连接的KDF哈希算法相同的密码套件恢复。
 
   仅当新的SNI值对原始会话中提供的服务器证书有效时，客户端才能恢复，并且仅当SNI值
   与原始会话中使用的SNI值匹配时才应恢复。后者是一种性能优化：通常，没有理由期望单个
   证书覆盖的不同服务器能够接受彼此的票证；因此，在这种情况下尝试恢复将浪费单次使用
   票证。如果提供了这样的指示(外部或通过任何其他方式)，则客户端可以使用不同的SNI值
   恢复。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   在恢复时，如果向调用应用程序报告SNI值，则实现必须使用在恢复ClientHello中发送的
   值，而不是在前一个会话中发送的值。请注意，如果服务器实现拒绝具有不同SNI值的所有
   PSK身份，则这两个值总是相同的。
 
   注意：虽然恢复主密钥取决于客户端的第二波发送，但不请求客户端身份验证的服务器可以
   独立计算成绩单的剩余部分，然后在发送完成后立即发送 NewSessionTicket ，而不是
   等待客户端完成。例如，在期望客户端并行打开多个TLS连接并且将受益于恢复握手的减少
   的开销的情况下，这可能是适当的。
 
      struct {
          uint32 ticket_lifetime;
          uint32 ticket_age_add;
          opaque ticket_nonce&lt;0..255&gt;;
          opaque ticket&lt;1..2^16-1&gt;;
          Extension extensions&lt;0..2^16-2&gt;;
      } NewSessionTicket;
 
   ticket_lifetime:  表示从票证签发时起按网络字节顺序以秒为单位的32位无符号整数
      的生存期。服务器不得使用任何大于604800秒(7天)的值。值为零表示应立即丢弃票证。
      客户端缓存票证的时间不得超过7天，无论ticket_lifetime如何，并且可以根据本地
      策略提前删除票证。服务器可能会将票证视为有效期比ticket_lifetime中规定的时间
      更短的一段时间。
 
   ticket_age_add:  安全生成的随机32位值，用于模糊客户端包含在“pre_shared_key”
      扩展中的票证的年龄。将客户端票证年龄与此值模2^32相加，以获得由客户端传输的值。
      服务器必须为它发送的每个票证生成一个新值。
 
   ticket_nonce:  在此连接上签发的所有票证中唯一的每次票值。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   ticket:  用作 PSK 标识的票证的值。 票证本身是一个字符串。 它可能是数据库查找
      密钥，也可以是自加密和自验证的值。
 
   extensions:  票据的一组扩展值。“扩展”格式在4.2节中定义。客户端必须忽略无法
      识别的扩展名。
 
   目前为NewSessionTicket定义的唯一扩展名是“early_data”，表示票据可用于发送
   0-RTT数据(第4.2.10节)。它包含下列值：
 
   max_early_data_size:  客户端在使用此票证时允许发送的最大0-RTT数据量，以字节
      为单位。仅计算应用数据有效载荷(即，明文而不是填充或内部内容类型字节)。接收到
      超过max_arly_data_size字节的0-RTT数据的服务器应终止连接，并发出
      “unexpected_message”警报。请注意，由于缺少加密材料而拒绝早期数据的服务器
      将无法区分填充与内容，因此客户端不应依赖能够在早期数据记录中发送大量填充。
 
   与票证关联的PSK计算如下：
 
       HKDF-Expand-Label(resumption_master_secret,
                        "resumption", ticket_nonce, Hash.length)
 
   由于Ticket_Nonce值对于每个NewSessionTicket消息是不同的，因此将为每个票证
   派生不同的PSK。
 
   请注意，原则上可以继续颁发新票证，从而无限期地延长最初派生自初始非 PSK 握手
   （很可能与对等方证书相关）的密钥材料的生存期。 建议实施对此类密钥材料的总使用寿命
   进行限制;这些限制应考虑对等方证书的生存期、干预吊销的可能性以及对等方联机证书验证
   签名后的时间。
 
4.6.2.  Post-Handshake Authentication
 
   当客户端发送了“post_handshake_auth”扩展(参见第4.2.6节)时，服务器可以在握手
   完成后的任何时间通过发送CertificateRequest消息来请求客户端身份验证。客户端
   必须使用适当的身份验证消息进行响应(参见第4.4节)。如果客户端选择进行身份验证，则
   必须发送Certificate、CertificateVerify和Finished。如果拒绝，则必须发送
   不包含证书的 Certificate 消息，后跟 Finished 。给定响应的所有客户端消息必须
   连续出现在线路上，不能插入其他类型的消息。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 






   如果客户端接收CertificateRequest消息而没有发送“post_handshak_auth”扩展，
   则必须发送“unexpected_message”致命警报。
 
   注意：因为客户端身份验证可能涉及提示用户，所以服务器必须为一些延迟做好准备，包括
   在发送CertificateRequest和接收响应之间接收任意数量的其他消息。此外，紧密接连
   收到多个CertificateRequest的客户端可能会以与收到它们的顺序不同的顺序响应它们
   (certificate_request_context值允许服务器消除响应的歧义)。
 


4.6.3.  密钥和初始化向量更新
 
   KeyUpdate握手消息用于指示发送方正在更新其发送的加密密钥。该消息可以在发送
   Finished 消息之后由任何一个对等体发送。在接收完成消息之前接收到KeyUpdate消息
   的实现必须终止连接，并发出“unexpected_message”警报。发送KeyUpdate消息后，
   发送方应使用新密钥发送其所有数据，按第7.2节所述计算。在接收到KeyUpdate后，
   接收方必须更新其接收密钥。
 
      enum {
          update_not_requested(0), update_requested(1), (255)      } KeyUpdateRequest;
 
      struct {
          KeyUpdateRequest request_update;
      } KeyUpdate;
 
   request_update:  指示KeyUpdate的接收者是否应使用自己的KeyUpdate进行响应。
      如果一个实现接收到任何其他值，它必须终止连接并发出“illegal_parameter”警报。
 
   如果request_update 字段设置为 “update_requested”，则在发送其下一个应用数据
   记录之前，接收方必须发送自己的带有request_update 设置为
   “update_not_requested”的KeyUpdate。此机制允许任何一方强制对整个连接进行
   更新，但会导致接收多个KeyUpdates的实现在静默状态下使用单个更新进行响应。请注意，
   在发送request_update设置为“update_request”的KeyUpdate和接收对等体的
   KeyUpdate之间，实现可能会接收任意数量的消息，因为这些消息可能已经在传输中。然而，
   因为发送和接收密钥是从独立的数据密钥中派生出来的，所以保留接收数据密钥不会威胁到
   在发送方更改密钥之前发送的数据的前向保密性。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 




 
   如果实现独立地发送自己的KeyUpdates，request_update设置为“update_request”，
   并且它们在发送中交叉，那么每一端也将发送响应，结果是每一端增加两代。
 
   发送方和接收方都必须使用旧密钥对其KeyUpdate消息进行加密。此外，在接受用新密钥
   加密的任何消息之前，双方必须强制接收到具有旧密钥的KeyUpdate。如果不这样做，则
   可能允许邮件截断攻击。
 
5.  记录协议
 
   TLS记录协议接收要传输的消息，将数据分段为可管理的块，保护记录，并传输结果。对
   接收到的数据进行验证、解密、重新组装，然后将其传递给更高级别的客户端。
 
   TLS记录是分类的，这允许在同一记录层上多路复用多个更高级别的协议。本文档指定了
   四种内容类型：握手、application_data、alert和change_cipher_spec。
   change_cipher_spec记录仅用于兼容性目的(参见附录D.4)。
 
   在发送或接收第一个 ClientHello 消息之后以及在接收到对等体的 Finished 消息
   之前的任何时间，实现可以接收由单字节值 0x01 组成的类型 change_cipher_spec 的
   未加密记录，并且必须简单地丢弃它而无需进一步处理。请注意，此记录可能出现在握手时
   实现预期受保护记录的某一点，因此有必要在尝试解除记录保护之前检测此条件。接收任何
   其他 change_cipher_spec 值或接收到受保护的 change_cipher_spec 记录的实现
   必须中止握手，并发出“unexpected_message”警报。如果实现检测到
   change_cipher_spec 记录在第一个 ClientHello 消息之前或对等体的 Finished 
   消息之后接收，则必须将其视为意外的记录类型(尽管无状态服务器可能无法将这些情况与
   允许的情况区分开来)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   实现不得发送本文档中未定义的记录类型，除非通过某些扩展进行协商。如果TLS实现接收
   到意外的记录类型，则它必须终止连接并发出“unexpected_message”警报。新的记录
   内容类型值由IANA在TLS Content Type注册表中分配，如第11节所述。
 
5.1.  记录层
 
   记录层将信息块分片成TLSPlaintext记录，这些记录以2^14字节或更少的块为单位承载
   数据。消息边界的处理方式取决于底层的contentType。任何未来的内容类型都必须指定
   适当的规则。请注意，这些规则比TLS 1.2中强制实施的规则更严格。
 
   握手消息可以合并到单个TLSPlaintext记录中，也可以在多个记录之间进行分段，前提是：
 
   -  握手消息不得与其他记录类型交错。也就是说，如果握手消息被拆分为两个或多个记录，
      则它们之间不能有任何其他记录。
 
   -  握手消息不得跨越密钥更改。实现必须验证紧接在键更改之前的所有消息是否与记录
      边界对齐；如果不是，则它们必须终止连接，并发出“unexpected_message”警报。
      因为ClientHello、EndOfEarlyData、ServerHello、Finish和KeyUpdate消息
      可以紧跟在键更改之前，所以实现必须按照记录边界发送这些消息。
 
   实现不能发送握手类型的零长度片段，即使这些片段包含填充。
 
   报警消息(第6节)不能在记录之间分割，并且不能将多个报警消息合并到单个
   TLSPlaintext记录中。换句话说，具有Alert类型的记录必须恰好包含一条消息。
 
   应用程序数据消息包含对TLS不透明的数据。应用程序数据消息始终受到保护。可以发送应用
   数据的零长度片段，因为它们作为流量分析对策是潜在有用的。应用程序数据片段可以跨多个
   记录拆分或合并为单个记录。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
      enum {
          invalid(0),
          change_cipher_spec(20),
          alert(21),
          handshake(22),
          application_data(23),
          (255)
      } ContentType;
 
      struct {
          ContentType type;
          ProtocolVersion legacy_record_version;
          uint16 length;
          opaque fragment[TLSPlaintext.length];
      } TLSPlaintext;
 
   type:  用于处理包含的片段的更高级别的协议。
 
   legacy_record_version:  对于由TLS 1.3实现生成的除初始ClientHello之外的
      所有记录(即，在HelloRetryRequest之后未生成的记录)，必须将其设置为0x0303，
      其中出于兼容性目的，也可以设置为0x0301。此字段已弃用，在任何情况下都必须忽略。
      在某些情况下，以前版本的TLS会在此字段中使用其他值。
 
   length:  以下TLSPlaintext.Fragment的长度(以字节为单位)。长度不能超过2^14
      字节。接收到超过此长度的记录的端点必须使用“record_overflow”警报终止连接。
 
   fragment:  正在传输的数据。这个值是透明的，并且被视为一个独立的块，由type字段
      指定的更高级别的协议来处理。
 
   本文档介绍TLS 1.3，它使用版本0x0304。此版本值是历史的，源自对TLS 1.0使用
   0x0301和对SSL 3.0使用0x0300。为了最大化向后兼容性，包含初始ClientHello的
   记录应该具有版本0x0301(反射TLS 1.0)，而包含第二个ClientHello或ServerHello
   的记录必须具有版本0x0303(反射TLS 1.2)。在协商TLS的先前版本时，端点遵循附录D中
   提供的程序和要求。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   当尚未启用记录保护时，直接将TLSPlaintext结构写入导线上。一旦开始记录保护，
   TLSPlaintext记录就会被保护并发送，如下节所述。请注意，应用程序数据记录不得写入
   未受保护的线路(详情请参阅第2节)。
 
5.2.  记录负载保护
 
   记录保护功能将TLSPlaintext结构转换为TLSCiphertext结构。去保护功能反转该过程。
   在TLS 1.3中，与以前版本的TLS不同，所有密码都被建模为“带关联数据的身份验证加密”
   (AEAD)[RFC5116]。EAAD函数提供统一的加密和认证操作，其将明文转换成认证的密文，
   然后再返回。每个加密记录都由一个明文头和一个加密体组成，加密体本身包含一个类型和
   可选的填充。
 
      struct {
          opaque content[TLSPlaintext.length];
          ContentType type;
          uint8 zeros[length_of_padding];
      } TLSInnerPlaintext;
 
      struct {
          ContentType opaque_type = application_data; /* 23 */
          ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */
          uint16 length;
          opaque encrypted_record[TLSCiphertext.length];
      } TLSCiphertext;
 
   content:  TLSPlaintext.Fragment值，包含握手或警报消息的字节编码，或要发送
      的应用程序数据的原始字节。
 
   type:  包含记录内容类型的TLSPlaintext.type值。
 
   zeros:  零值字节的任意长度游程可能出现在类型字段之后的明文中。这为发件人提供了
      将任何TLS记录填充选定数量的机会，只要总数保持在记录大小限制内即可。更多细节
      见5.4节。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   opaque_type:  TLSCiphertext记录的外部opaque_type 字段始终设置为值23
      (APPLICATION_DATA)，以便与习惯于解析以前版本的TLS的中间件保持向外兼容性。
      解密后，可以在TLSInnerPlaintext.type中找到记录的实际内容类型。
 
   legacy_record_version:  Legacy_Record_Version字段始终为0x0303。TLS 1.3
      TLSCiphertext直到TLS 1.3被协商后才会生成，因此在可能接收到其他值的地方没有
      历史兼容性问题。请注意，握手协议(包括ClientHello和ServerHello消息)验证协议
      版本，因此此值是冗余的。
 
   length:  以下TLSCiphertext.encrypted_record 的长度(以字节为单位)，它是
      内容和填充的长度之和，加上内部内容类型的1长度，再加上由aead算法添加的任何
      扩展。长度不能超过2^14+256字节。接收到超过此长度的记录的端点必须使用
      “record_overflow”警报终止连接。
 
   encrypted_record:  序列化的TLSInnerPlaintext结构的aead加密形式。
 
   AEAD 算法将单个密钥、nonce、纯文本和"附加数据"作为输入包含在身份验证检查中，
   如 [RFC5116] 第 2.1 节所述。 密钥是client_write_key 或
   server_write_key，nonce派生自序列号和client_write_iv 或server_write_iv 
   （请参阅第 5.3 节），其他数据输入是记录标头。
 
   I.e.,
 
      additional_data = TLSCiphertext.opaque_type ||
                        TLSCiphertext.legacy_record_version ||
                        TLSCiphertext.length
 
   AEAD算法的明文输入是编码的TLSInnerPlaintext结构。数据密钥的推导在7.3节中定义。
 
   AEAD输出由来自AEAD加密操作的密文输出组成。由于包含TLSInnerPlaintext.type和
   发送方提供的任何填充，明文的长度大于相应的TLSPlaintext.length。AEAD输出的
   长度通常将大于明文，但数量随AEAD算法而变化。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   由于密码可能包含填充，因此开销的量可以随明文的不同长度而变化。象征性的
 
      AEADEncrypted =
          AEAD-Encrypt(write_key, nonce, additional_data, plaintext)
 
   TLSCiphertext的 encrypted_record 字段设置为AEADEncrypted。
 
   为了解密和验证，算法以密钥、随机数、附加数据和AEADEncrypted值作为输入。输出
   要么是明文，要么是指示解密失败的错误。没有单独的完整性检查。象征性的
 
      plaintext of encrypted_record =
          AEAD-Decrypt(peer_write_key, nonce,
                       additional_data, AEADEncrypted)
 
   如果解密失败，接收方必须终止连接并发出“bad_record_mac”警报。
 
   TLS 1.3中使用的AEAD算法不得产生大于255个八位组的扩展。从其对等端接收
   TLSCiphertext.length大于2^14+256个八位字节的记录的端点必须使用
   “record_overflow”警报终止连接。此限制由最大TLSInnerPlaintext长度2^14个
   八位字节+ContentType的1个八位字节+255个八位字节的最大aead扩展得出。
 
5.3.  Per-Record Nonce
 
   64位序列号被单独维护，用于读取和写入记录。在读取或写入每个记录后，适当的序列号
   递增1。在连接开始时和每当密钥改变时，每个序列号都被设置为零；在特定业务下加密
   传输的第一个记录必须使用序列号0。
 
   因为序列号的大小是64位，所以它们不应该换行。如果TLS实现需要包装序列号，则必须
   重新设置密钥(第4.6.3节)或终止连接。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   每个 AEAD 算法将为每个记录的随机数指定可能的长度范围，从 N_MIN 字节到
   输入的 N_MAX 字节 [RFC5116]。  对于 AEAD 算法， TLS每条记录随机数的
   长度被（iv_length）设置为 8 字节和 N_MIN 中较大的一个（参见 [RFC5116]，
   第 4 节）。 N_MAX 小于 8 字节的 AEAD 算法不得与 TLS 一起使用。 AEAD 构造的
   每个记录的随机数格式如下：
 
   1.  64位记录序列号按网络字节顺序编码，左侧补零至iv_length。
 
   2.  填充的序列号与静态client_write_iv或server_write_iv进行异或
       (取决于角色)。
 
   得到的数量(长度为iv_length)用作每条记录的随机数。
 
   注意：这与TLS 1.2中的构造不同，TLS 1.2中指定了部分显式的nonce。
 
5.4.  记录填充
 
   可以填充所有加密的TLS记录以扩大TLSCiphertext的大小。这允许发送者对观察者隐藏
   流量的大小。
 
   当生成TLSCiphertext记录时，实现可以选择填充。未填充的记录只是填充长度为零的
   记录。填充是加密前附加到contentType字段的零值字节字符串。在加密之前，实现必须
   将填充八位组设置为全零。
 
   如果发送者需要，应用数据记录可以包含零长度的TLSInnerPlaintext.content。这
   允许在活动的存在或不存在可能是敏感的上下文中生成合理大小的覆盖流量。实现不得发送
   长度为零的TLSInnerPlaintext.content的握手和警报记录；如果接收到这样的消息，
   则接收实现必须终止连接，并发出“unexpected_message”警报。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   发送的填充由记录保护机制自动验证；在成功解密TLSCiphertext.Encrypted_Record
   后，接收实现从末尾向开始扫描字段，直到找到非零的二进制八位数。这个非零的二进制
   八位数是消息的内容类型。之所以选择这种填充方案，是因为它允许以任意大小(从零到TLS
   记录大小限制)填充任何加密的TLS记录，而不引入新的内容类型。该设计还强制实施全零
   填充八位组，这允许快速检测填充错误。
 
   实现必须将其扫描限制为从aead解密返回的明文。如果接收实现在明文中找不到非零的
   二进制八位数，则它必须终止连接，并发出“unexpected_message”警报。
 
   填充的存在不会改变总体记录大小限制：完整编码的TLSInnerPlaintext不得超过
   2^14+1个八位字节。如果减少了最大片段长度-例如，通过[RFC8449]的
   record_size_limit扩展-那么减少的限制适用于完整明文，包括内容类型和填充。
 
   选择建议何时填充以及填充多少的填充策略是一个复杂的主题，并且超出了本规范的范围。
   如果TLS之上的应用层协议有自己的填充，则最好在应用层内填充应用数据TLS记录。不过，
   加密握手或警报记录的填充仍必须在TLS层处理。稍后的文档可以通过TLS扩展或一些其他
   手段定义填充选择算法或定义填充策略请求机制。
 
5.5.  密钥使用限制
 
   在给定的密钥集下可以安全加密的纯文本数量有限制。 [AEAD-LIMITS] 在假定基础
   基元（AES 或 ChaCha20）没有弱点的情况下，对这些限制进行了分析。实现应在达到这些
   限制之前执行第 4.6.3 节中描述的密钥更新。
 
   对于AES-GCM，在给定连接上最多可以加密2^24.5条全尺寸记录(约2400万条)，同时保持
   大约2^-57的安全裕度，以保证身份验证加密(AE)安全性。对于CHACH20/Poly1305，
   记录序列号将在达到安全限值之前自动换行。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
6.  警报协议
 
   TLS提供警报内容类型以指示关闭信息和错误。与其他消息一样，警报消息按照当前连接状态
   进行加密。
 
   警报消息传达警报的描述和旧字段，该字段传达TLS早期版本中消息的严重性级别。警报分为
   两类：关闭警报和错误警报。在TLS 1.3中，严重性隐含在正在发送的警报类型中，并且可以
   安全地忽略“level”字段。“close_notify”警报用于指示连接的一个方向有序关闭。在
   接收到这样的警报时，TLS实现应该向应用程序指示数据结束。
 
   错误警报指示连接的中止关闭(参见第6.2节)。在接收到错误警报后，TLS实现应向应用程序
   指示错误，并且不得允许在连接上发送或接收任何进一步的数据。服务器和客户端必须忘记
   在失败的连接中建立的密码值和密钥，与会话票证关联的PSK除外，如果可能，应将其丢弃。
 
   6.2节中列出的所有警报必须使用AlertLevel=FATAL发送，并且在收到时必须被视为错误
   警报，而不管消息中的警报等级是什么。未知警报类型必须视为错误警报。
 
   注意：TLS定义了两个通用警报(参见第6节)，用于解析消息失败时使用。接收不能根据
   语法解析的消息的对等体(例如，具有超出消息边界的长度或包含超出范围的长度)必须
   用“decode_error”警报终止连接。接收到语法上正确但语义上无效的消息的对等体
   (例如，p-1的DHE共享或无效的枚举)必须以“illegal_parameter”警报终止连接。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
      enum { warning(1), fatal(2), (255) } AlertLevel;
 
      enum {
          close_notify(0),
          unexpected_message(10),
          bad_record_mac(20),
          record_overflow(22),
          handshake_failure(40),
          bad_certificate(42),
          unsupported_certificate(43),
          certificate_revoked(44),
          certificate_expired(45),
          certificate_unknown(46),
          illegal_parameter(47),
          unknown_ca(48),
          access_denied(49),
          decode_error(50),
          decrypt_error(51),
          protocol_version(70),
          insufficient_security(71),
          internal_error(80),
          inappropriate_fallback(86),
          user_canceled(90),
          missing_extension(109),
          unsupported_extension(110),
          unrecognized_name(112),
          bad_certificate_status_response(113),
          unknown_psk_identity(115),
          certificate_required(116),
          no_application_protocol(120),
          (255)
      } AlertDescription;
 
      struct {
          AlertLevel level;
          AlertDescription description;
      } Alert;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
6.1.  关闭警报
 
   客户端和服务器必须共享连接即将结束的信息，以避免截断攻击。
 
   close_notify:  此警报通知收件人发件人将不再在此连接上发送任何消息。必须忽略
      在接收到关闭警报之后接收到的任何数据。
 
   user_canceled:  此警报通知收件人发送方出于某种与协议故障无关的原因取消握手。
      如果用户在握手完成后取消操作，则通过发送“close_notify”关闭连接更合适。
      此警报后应紧跟“close_notify”。此警报通常具有AlertLevel=Warning。
 





   任何一方都可以通过发送“close_notify”警报来启动连接的写入端的关闭。必须忽略在
   接收到关闭警报之后接收到的任何数据。如果在“close_notify”之前接收到传输层关闭，
   则接收方无法知道发送的所有数据都已收到。
 
   每一方必须在关闭其连接的写入端之前发送“close_notify”警报，除非它已经发送了一些
   错误警报。这对连接的读取端没有任何影响。请注意，这与TLS 1.3之前的TLS版本不同，
   在TLS 1.3之前的版本中，要求实现通过丢弃挂起的写入并立即发送自己的
   “close_Notify”警报来对“close_notification”作出反应。之前的要求可能会导致
   读取侧的截断。在关闭连接的读取端之前，双方不需要等待接收“close_notify”警报，
   尽管这样做会引入截断的可能性。
 




   如果使用TLS的应用协议规定在关闭TLS连接后可以在底层传输上携带任何数据，则在向
   应用层指示数据结束之前，TLS实现必须接收“close_notify”警报。本标准的任何部分都
   不应用于规定TLS的使用配置文件管理其数据传输的方式，包括何时打开或关闭连接。
 
   注意：假设关闭连接的写入端在销毁传输之前可靠地传递挂起的数据。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
6.2.  错误警报
 
   TLS中的错误处理非常简单。当检测到错误时，检测方向其对等方发送消息。在发送或接收到
   致命警报消息时，双方必须立即关闭连接。
 
   每当实现遇到致命错误条件时，它都应该发送适当的致命警报，并且必须在不发送或接收任何
   其他数据的情况下关闭连接。在本说明书的其余部分中，当在没有特定警报的情况下使用短语
   “终止连接”和“中止握手”时，意味着实现应该发送如下描述所指示的警报。短语
   “使用X警报终止连接”和“用X警报中止握手”意味着如果实现发送任何警报，则必须发送警报
   X。从TLS 1.3开始，本节中定义的所有警报以及所有未知警报都被普遍认为是致命的
   (参见第6节)。实现应该提供一种方便记录警报发送和接收的方法。
 
 






  已定义了以下错误警报:
 
   unexpected_message:  收到不适当的消息（例如，错误的握手消息、过早的应用程序
      数据等）。在正确实现之间的通信中，绝不应观察到此警报。
 


   bad_record_mac:  如果收到无法解除保护的记录，则返回此警报。因为aead算法结合了
      解密和验证，并且还为了避免旁道攻击，所以此警报用于所有解除保护失败。在正确实现
      的通信中绝不应观察到此警报，除非网络中的消息已损坏。
 



   record_overflow:  收到长度超过2^14+256字节的TLSCiphertext记录，或解密为
      超过2^14字节(或其他协商限制)的TLSPlaintext记录的记录。在正确实现的通信中
      绝不应观察到此警报，除非网络中的消息已损坏。
 


   handshake_failure:  收到“handshake_failure”警报消息表明，发送方在给定可用
      选项的情况下无法协商一组可接受的安全参数。

 
   bad_certificate:  证书已损坏，包含未正确验证的签名等。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   unsupported_certificate:  证书的类型不受支持。
 
   certificate_revoked:  证书被其签名者吊销。
 
   certificate_expired:  证书已过期或当前无效。
 
   certificate_unknown:  在处理证书的过程中出现了一些其他(未指定的)问题，
      使其不可接受。
 
   illegal_parameter:  握手中的某个字段不正确或与其他字段不一致。此警报用于符合
      正式协议语法但其他方面不正确的错误。
 


   unknown_ca:  收到有效的证书链或部分链，但未接受证书，因为找不到CA证书或无法与
      已知的信任锚点匹配。
 


   access_denied:  收到有效的证书或PSK，但当应用访问控制时，发送方决定不继续协商。
 

   decode_error:  无法解码消息，因为某些字段超出指定范围或消息长度不正确。此警报
      用于消息不符合正式协议语法的错误。在正确实现之间的通信中绝不应观察到此警报，
      除非网络中的消息已损坏。
 


   decrypt_error:  握手(非记录层)加密操作失败，包括无法正确验证签名或验证已完成
      的消息或PSK绑定器。
 

   protocol_version:  对等体尝试协商的协议版本被识别，但不受支持(参见附录D)。

 
   insufficient_security:  由于服务器需要比客户端支持的参数更安全的参数，在协商
      失败时返回，而不是返回“handshake_failure”。
 
   internal_error:  与对等体或协议的正确性无关的内部错误(如内存分配失败)使其无法
      继续。
 
   inappropriate_fallback:  由服务器发送，以响应来自客户端的无效连接重试尝试
      (参见[RFC7507])。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   missing_extension:  由接收握手消息的端点发送，该握手消息不包含对于所提供的
      TLS版本或其他协商参数强制发送的扩展。
 
   unsupported_extension:  由接收任何握手消息的端点发送，该握手消息包含已知禁止
      包含在给定握手消息中的扩展，或者包括ServerHello或证书中未首先在相应
      ClientHello或CertificateRequest中提供的任何扩展。
 
   unrecognized_name:  当不存在由客户端通过“server_name”扩展提供的名称标识的
      服务器时，由服务器发送(参见[RFC6066])。
 
   bad_certificate_status_response:  当服务器通过“status_request”扩展提供
      无效或不可接受的OCSP响应时，由客户端发送(参见[RFC6066])。
 



   unknown_psk_identity:  当需要PSK密钥建立但客户端没有提供可接受的PSK标识时，
      服务器发送。发送此警报是可选的；服务器可能会选择发送“decrypt_error”警报，
      以仅指示无效的PSK身份。
 
   certificate_required:  当需要客户端证书但客户端没有提供任何证书时，服务器
      发送。
 
   no_application_protocol:  当“application_layer_protocol_negotiation”
      扩展仅通告服务器不支持的协议时，由服务器发送(参见[RFC7301])。
 
   新的警报值由IANA分配，如第11节所述。
 
7.  密码计算
 
   TLS握手建立一个或多个输入密码，这些输入密钥被组合以创建实际工作密钥材料，如下
   所述。密钥导出过程合并了输入密码和握手记录。注意，因为握手记录包括来自Hello消息
   的随机值，所以任何给定的握手都将具有不同的业务密码，即使使用相同的输入密码，当
   相同的PSK用于多个连接时也是如此。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
7.1.  密钥表
 
   密钥派生过程利用为HKDF[RFC5869]定义的HKDF-Extract和HKDF-Expand函数，以及
   下面定义的函数：
 
       HKDF-Expand-Label(Secret, Label, Context, Length) =
            HKDF-Expand(Secret, HkdfLabel, Length)
 
       Where HkdfLabel is specified as:
 
       struct {
           uint16 length = Length;
           opaque label&lt;7..255&gt; = "tls13 " + Label;
           opaque context&lt;0..255&gt; = Context;
       } HkdfLabel;
 
       Derive-Secret(Secret, Label, Messages) =
            HKDF-Expand-Label(Secret, Label,
                              Transcript-Hash(Messages), Hash.length)
 
   Transcript-Hash 和 HKDF 使用的哈希函数是加密套件哈希算法。hash.length是其
   输出长度(以字节为单位)。消息是所指示的握手消息的串联，包括握手消息类型和长度字段，
   但不包括记录层报头。请注意，在某些情况下，零长度上下文(由""表示)被传递给
   HKDF-Expand-Label。本文档中指定的标签都是ASCII字符串，不包括尾部的NUL字节。
 
   注意：对于常用的散列函数，任何超过12个字符的标签都需要额外的散列函数迭代来计算。
   本说明书中的标签均已选择适合此限制。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   使用HKDF-Extract和Derve-Secret函数从两个输入密码派生密钥。添加新密码的一般
   模式是使用HKDF-Extract，其中Salt是当前密码状态，输入密钥材料(IKM)是要添加的
   新密码。在此版本的TLS 1.3中，两个输入密码是：
 
   -  PSK (外部建立的预共享密钥，或从前一个连接的resumption_master_secret 值
      派生而来的预共享密钥)。
 
   -  (EC)DHE 共享密钥 (Section 7.4)
 
   这会产生一个完整的密钥导出计划，如下图所示。在此图中，以下格式约定适用：
 
   -  HKDF-Extract绘制为采用顶部的Salt参数和左侧的IKM参数，其输出位于底部，输出的
      名称位于右侧。
 
   -  Derive-Secret 的Secret参数由传入箭头指示。例如，Early Secret是用于生成
      client_early_traffic_secret。
 
   -  "0" 表示设置为零的Hash.length字节字符串。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
             0
             |
             v
   PSK -&gt;  HKDF-Extract = Early Secret
             |
             +-----&gt; Derive-Secret(., "ext binder" | "res binder", "")
             |                     = binder_key
             |
             +-----&gt; Derive-Secret(., "c e traffic", ClientHello)
             |                     = client_early_traffic_secret
             |
             +-----&gt; Derive-Secret(., "e exp master", ClientHello)
             |                     = early_exporter_master_secret
             v
       Derive-Secret(., "derived", "")
             |
             v
   (EC)DHE -&gt; HKDF-Extract = Handshake Secret
             |
             +-----&gt; Derive-Secret(., "c hs traffic",
             |                     ClientHello...ServerHello)
             |                     = client_handshake_traffic_secret
             |
             +-----&gt; Derive-Secret(., "s hs traffic",
             |                     ClientHello...ServerHello)
             |                     = server_handshake_traffic_secret
             v
       Derive-Secret(., "derived", "")
             |
             v
   0 -&gt; HKDF-Extract = Master Secret
             |
             +-----&gt; Derive-Secret(., "c ap traffic",
             |                     ClientHello...server Finished)
             |                     = client_application_traffic_secret_0
             |
             +-----&gt; Derive-Secret(., "s ap traffic",
             |                     ClientHello...server Finished)
             |                     = server_application_traffic_secret_0
             |
             +-----&gt; Derive-Secret(., "exp master",
             |                     ClientHello...server Finished)
             |                     = exporter_master_secret
             |
             +-----&gt; Derive-Secret(., "res master",
                                   ClientHello...client Finished)
                                   = resumption_master_secret</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   这里的一般模式是，图的左侧显示的密码只是没有上下文的原始熵，而右侧的密码包括握手
   上下文，因此可以用于在没有其他上下文的情况下导出工作密钥。请注意，即使使用相同的
   密码，对Derve-Secret的不同调用也可能采用不同的消息参数。在0-RTT交换中，
   Derve-Secret用四个不同的转录本调用；在仅1-RTT的交换中，它用三个不同的转录本
   调用。
 
   如果给定的密码不可用，则使用由设置为零的Hash.length字节字符串组成的0值。请注意，
   这并不意味着跳过轮次，因此如果PSK不在使用中，则Early Secret仍将是
   HKDF-Extract(0，0)。对于binder_key的计算，标签是用于外部PSK(在TLS之外提供的
   那些)的“ext binder”和用于恢复PSK(那些被提供为先前握手的恢复主秘密的PSK)的
   “res binder”。不同的标签防止用一种类型的PSK替换另一种类型的PSK。
 
   根据服务器最终选择的PSK，有多个潜在的早期密码值。客户端将需要为每个潜在的PSK计算
   一次；如果没有选择PSK，则需要计算对应于零PSK的Early Secret。
 
   一旦计算了从给定秘密得到的所有值，该秘密就应该被擦除。
 
7.2.  更新 Traffic Secrets
 
   一旦握手完成，任何一方都可以使用第4.6.3节中定义的KeyUpdate握手消息更新其发送
   Traffic Secrets。下一代数据密钥的计算方法是：如本节所述，从
   client_/server_application_traffic_secret_N生成
   client_/server_application_traffic_secret_N+1，然后如第7.3节所述重新推导
   Traffic Secrets。
 
   下一代 application_traffic_secret 的计算方式为：
 
       application_traffic_secret_N+1 =
           HKDF-Expand-Label(application_traffic_secret_N,
                             "traffic upd", "", Hash.length)
 
   一旦计算出client_/server_application_traffic_secret_N+1及其关联的
   traffic_secret，实施应该删除client_/server_application_traffic_secret_N
   及其关联的traffic_secret。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
7.3.  Traffic Key 计算
 
   业务密钥材料由以下输入值生成：
 
   -  A secret value
 
   -  目的值，指示正在生成的特定值。
 
   -  生成的密钥长度。
 
   使用以下方法从输入的业务密码值生成业务密钥材料：
 
   [sender]_write_key = HKDF-Expand-Label(Secret, "key", "", key_length)
   [sender]_write_iv  = HKDF-Expand-Label(Secret, "iv", "", iv_length)
 
   [发送方]表示发送方。下表显示了每种记录类型的Secret值。
 
       +-------------------+---------------------------------------+
       | Record Type       | Secret                                |
       +-------------------+---------------------------------------+
       | 0-RTT Application | client_early_traffic_secret           |
       |                   |                                       |
       | Handshake         | [sender]_handshake_traffic_secret     |
       |                   |                                       |
       | Application Data  | [sender]_application_traffic_secret_N |
       +-------------------+---------------------------------------+
 
   每当基础密钥改变时(例如，当从握手改变为应用数据密钥时或在密钥更新时)，重新计算
   所有业务密钥材料。
 
7.4.  (EC)DHE 共享密码计算
 
7.4.1.  有限域 Diffie-Hellman
 
   对于有限域组，执行常规的 Diffie-Hellman[DH76] 计算。协商的密钥(Z)通过以大端
   字节顺序形式编码转换为字节串，并用零填充，直到素数的大小。该字节串用作如上所述的
   密钥调度中的共享秘密。
 
   请注意，此构造与以前版本的TLS不同，TLS删除了前导零。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
7.4.2.  Elliptic Curve Diffie-Hellman
 
   对于secp256r1、secp384r1和secp521r1，ECDH计算(包括参数和密钥生成以及
   共享秘密计算)是根据[IEEE1363]使用身份图作为密钥导出函数(KDF)的ECKAS-DH1方案
   来执行的，使得共享秘密是表示为八位字节串的ECDH共享秘密椭圆曲线点的x坐标。请
   注意，FE2OSP(Field Element To Octet String Conversion Primitive)输出
   的这个八位字节字符串(IEEE 1363术语中的“Z”)对于任何给定字段都具有恒定的长度；
   在此八位字节字符串中找到的前导零不得被截断。
 
   (请注意，这种身份KDF的使用是技术性的。完整的情况是，ECDH与非平凡的KDF一起使用，
   因为TLS不直接将此密码用于计算其他密码以外的任何事情。)。
 
   对于X25519和X448，ECDH计算如下：
 
   -  放入KeyShareEntry.key_exchange结构的公钥是将ECDH标量乘法函数应用于适当
      长度的密钥(放入标量输入)和标准公共基点(放入u坐标点输入)的结果。
 
   -  ECDH共享密钥是将ECDH标量乘法函数应用于密钥(进入标量输入)和对等体的公钥
      (进入u坐标点输入)的结果。输出是原始的，没有任何处理。
 
   对于这些曲线，实现应该使用[RFC7748]中指定的方法来计算Diffie-Hellman共享秘密。
   实现必须检查计算出的Diffie-Hellman共享机密是否为全零值，如果是，则中止，
   如[RFC7748]的第6节所述。如果实现者使用这些椭圆曲线的替代实现，他们应执行
   [RFC7748]的第7节中指定的附加检查。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
7.5.  导出器
 
   [RFC5705]根据TLS伪随机函数(PRF)定义TLS的密钥材料导出器。本文件将PRF替换为
   HKDF，因此需要新的结构。导出器界面保持不变。
 
   导出器的值计算如下：
 
   TLS-Exporter(label, context_value, key_length) =
       HKDF-Expand-Label(Derive-Secret(Secret, label, ""),
                         "exporter", Hash(context_value), key_length)
 
   其中Secret是 early_exporter_master_secret 或 exporter_master_secret。
   除非应用程序明确指定，否则实现必须使用 exporter_master_secret。
   early_exporter_master_secret 定义用于0-RTT数据需要导出器的设置中。建议为
   早期导出器提供单独的界面；这可以避免导出器用户在需要常规导出器时意外使用早期
   导出器，反之亦然。
 
   如果未提供上下文，则context_value的长度为零。因此，不提供上下文将计算与提供
   空上下文相同的值。这与以前版本的TLS有所不同，以前的TLS版本中，空上下文产生的输出
   与不存在的上下文不同。自本文档发布之日起，没有使用带有上下文和无上下文的已分配
   导出器标签。 未来的规范不得定义允许空上下文和具有相同标签的空上下文的导出器的
   使用。导出器的新用途应该在所有导出器计算中提供上下文，尽管值可以是空的。
 
   导出器标签格式的要求在[RFC5705]第4节中定义。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
8.  0-RTT and Anti-Replay
 
   如第2.3节和附录E.5所述，TLS不为0-RTT数据提供固有的重放保护。需要关注的潜在威胁
   有两个：
 
   -  通过简单复制0-RTT数据报进行重放攻击的网络攻击者。
 
   -  利用客户端重试行为安排服务器接收应用程序消息的多个副本的网络攻击者。这种威胁
      在某种程度上已经存在，因为重视健壮性的客户端通过尝试重试请求来响应网络错误。
      然而，0-RTT为不维护全局一致的服务器状态的任何服务器系统添加了额外的维度。
      具体地说，如果服务器系统有多个区域，在区域B中不接受区域A的票证，则攻击者可以
      将针对A的ClientHello和早期数据复制到A和B。在A，数据将在0-RTT中被接受，
      但是在B处，服务器将拒绝0-RTT数据，而是强制完全握手。如果攻击者阻止来自 A 的
      ServerHello，则客户端将完成与B的握手，并可能重试请求，从而导致整个服务器
      系统上的重复。
 
   可以通过共享状态来保证0-RTT数据最多接受一次来防止第一类攻击。服务器应通过实施本节
   中描述的方法之一或通过等效的方法来提供该级别的重放安全。然而，应该理解的是，由于
   操作方面的考虑，并不是所有的部署都会将状态保持在该级别。因此，在正常操作中，客户端
   将不知道服务器实际实现这些机制中的哪一种(如果有的话)，因此必须仅发送他们认为可以
   安全重放的早期数据。
 
   除了重放的直接影响外，还有一类攻击，其中即使通常被认为是幂等的操作也可以被大量的
   重放利用(定时攻击，资源限制耗尽等，如附录E.5所述)。这些可以通过确保每个0-RTT
   有效载荷只能被有限次数地重放来减轻。服务器必须确保它的任何实例(可以是机器、线程或
   相关服务基础设施内的任何其他实体)最多接受0-RTT进行同一握手；这将重放的次数
   限制为部署中的服务器实例的数量。这样的保证可以通过本地记录来自最近接收到的
   ClientHellos的数据并拒绝重复，或者通过提供相同或更强的保证的任何其他方法来实现。
   “每个服务器实例最多一次”保证是最低要求；如果可行，服务器应该进一步限制0-RTT重播。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 



 
   第二类攻击在TLS层无法防止，必须由任何应用程序处理。请注意，客户端实现任何类型的
   重试行为的任何应用程序都需要实现某种反重放防御。
 


8.1.  一次性票据
 
   最简单的反重放防御形式是服务器只允许每个会话票证使用一次。例如，服务器可以维护所有
   未完成的有效票证的数据库，在使用时从数据库中删除每个票证。如果提供了未知的票证，
   则服务器将回退到完全握手。
 
   如果票证不是自包含的，而是数据库 key，并且相应的PSK在使用时被删除，则使用PSK建立
   的连接享有前向保密性。这提高了在没有(EC)DHE的情况下使用PSK时所有0-RTT数据和PSK
   使用的安全性。
 
   由于此机制需要在具有多个分布式服务器的环境中的服务器节点之间共享会话数据库，与
   自加密票证相比，可能难以实现高成功率的PSK 0-RTT连接。与会话数据库不同，会话票证
   即使没有一致的存储，也可以成功地进行基于PSK的会话建立，尽管当允许0-RTT时，它们
   仍然需要一致的存储来防止0-RTT数据的重放，如下一节所述。
 




8.2.  Client Hello Recording
 
   反重放的另一种形式是记录从ClientHello派生的唯一值(通常是随机值或PSK绑定器)并
   拒绝重复。记录所有ClientHello会导致状态不受限制地增长，但是服务器可以在给定的
   时间窗口内记录ClientHello，并使用“obfuscated_ticket_age”确保票证不会在
   该窗口外重用。
 
   为了实现这一点，当接收到ClientHello时，服务器首先验证PSK绑定器，如第4.2.11节
   所述。然后，如下一节所述，它会计算expected_arrival_time ，如果0-RTT在记录
   窗口之外，则拒绝0-RTT，退回到1-RTT握手。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   如果expected_arrival_time 在窗口中，那么服务器检查它是否记录了匹配的
   ClientHello。如果找到一个，它要么中止握手并发出“illegal_parameter”警报，
   要么接受PSK但拒绝0-RTT。如果没有找到匹配的 ClientHello，那么它接受0-RTT，
   然后只要expected_arrival_time 在窗口内就存储ClientHello。服务器还可以实现
   具有假阳性的数据存储，例如Bloom过滤器，在这种情况下，它们必须通过拒绝0-RTT来
   响应明显的重放，但不能中止握手。
 
   服务器必须仅从ClientHello的已验证部分派生存储密钥。如果ClientHello包含多个
   PSK身份，则攻击者可以为不太首选的身份创建具有不同绑定器值的多个ClientHello，
   前提是服务器不会对其进行验证(如第4.2.11节所建议的)。即，如果客户端发送
   PSK A和B，但服务器偏好 A，则攻击者可以在不影响A的绑定器的情况下改变B的绑定器。
   如果B的绑定器是存储密钥的一部分，则该ClientHello将不会出现为副本，这将导致
   ClientHello 被接受，并且可能导致诸如重放高速缓存污染之类的副作用，尽管任何
   0-RTT数据都将是不可解密的，因为它将使用不同的密钥。如果将经过验证的绑定器或
   ClientHello.random用作存储密钥，则不可能进行这种攻击。
 
   因为这种机制不需要存储所有未完成的票据，所以它可能更容易在具有高恢复速率和0-RTT
   的分布式系统中实现，而代价是由于可靠地存储和检索所接收的ClientHello消息的困难，
   潜在的较弱的反重放防御。在许多这样的系统中，对所有接收到的ClientHellos进行全局
   一致的存储是不切实际的。在这种情况下，通过使单个存储区域对给定票证具有权威性，并在
   任何其他区域中拒绝该票证的0-RTT，来提供最佳的防重放保护。这种方法可以防止攻击者
   进行简单的重播，因为只有一个区域会接受0-RTT数据。较弱的设计是为每个区域实现单独
   的存储，但允许在任何区域中使用0-RTT。这种方法将每个区域的重放次数限制为一次。
   当然，无论采用哪种设计，应用程序消息复制都是可能的。
 
   当实施刚刚开始时，只要他们的记录窗口的任何部分与启动时间重叠，他们就应该拒绝
   0-RTT。否则，他们将面临接受在此期间最初发送的回放的风险。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   注意：如果客户端的时钟比服务器的时钟运行得快得多，那么将来可能会收到一个在窗口
   之外的ClientHello，在这种情况下，它可能会被1-RTT接受，导致客户端重试，然后再被
   0-RTT接受。这是第8节中描述的第二种攻击形式的另一种变体。
 
8.3.  Freshness Checks
 
   Because the ClientHello indicates the time at which the client sent   it, it is possible to efficiently determine whether a ClientHello was   likely sent reasonably recently and only accept 0-RTT for such a   ClientHello, otherwise falling back to a 1-RTT handshake.  This is   necessary for the ClientHello storage mechanism described in   Section 8.2 because otherwise the server needs to store an unlimited   number of ClientHellos, and is a useful optimization for self-   contained single-use tickets because it allows efficient rejection of   ClientHellos which cannot be used for 0-RTT.
 
   In order to implement this mechanism, a server needs to store the   time that the server generated the session ticket, offset by an   estimate of the round-trip time between client and server.  I.e.,
 
       adjusted_creation_time = creation_time + estimated_RTT
 
   This value can be encoded in the ticket, thus avoiding the need to   keep state for each outstanding ticket.  The server can determine the   client's view of the age of the ticket by subtracting the ticket's   "ticket_age_add" value from the "obfuscated_ticket_age" parameter in   the client's "pre_shared_key" extension.  The server can determine   the expected_arrival_time of the ClientHello as:
 
     expected_arrival_time = adjusted_creation_time + clients_ticket_age
 
   When a new ClientHello is received, the expected_arrival_time is then   compared against the current server wall clock time and if they   differ by more than a certain amount, 0-RTT is rejected, though the   1-RTT handshake can be allowed to complete.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   There are several potential sources of error that might cause   mismatches between the expected_arrival_time and the measured time.   Variations in client and server clock rates are likely to be minimal,   though potentially the absolute times may be off by large values.   Network propagation delays are the most likely causes of a mismatch   in legitimate values for elapsed time.  Both the NewSessionTicket and   ClientHello messages might be retransmitted and therefore delayed,   which might be hidden by TCP.  For clients on the Internet, this   implies windows on the order of ten seconds to account for errors in   clocks and variations in measurements; other deployment scenarios may   have different needs.  Clock skew distributions are not symmetric, so   the optimal tradeoff may involve an asymmetric range of permissible   mismatch values.
 
   Note that freshness checking alone is not sufficient to prevent   replays because it does not detect them during the error window,   which -- depending on bandwidth and system capacity -- could include   billions of replays in real-world settings.  In addition, this   freshness checking is only done at the time the ClientHello is   received and not when subsequent early Application Data records are   received.  After early data is accepted, records may continue to be   streamed to the server over a longer time period.
 
9.  Compliance Requirements
 
9.1.  Mandatory-to-Implement Cipher Suites
 
   In the absence of an application profile standard specifying   otherwise:
 
   A TLS-compliant application MUST implement the TLS_AES_128_GCM_SHA256   [GCM] cipher suite and SHOULD implement the TLS_AES_256_GCM_SHA384   [GCM] and TLS_CHACHA20_POLY1305_SHA256 [RFC8439] cipher suites (see   Appendix B.4).
 
   A TLS-compliant application MUST support digital signatures with   rsa_pkcs1_sha256 (for certificates), rsa_pss_rsae_sha256 (for   CertificateVerify and certificates), and ecdsa_secp256r1_sha256.  A   TLS-compliant application MUST support key exchange with secp256r1   (NIST P-256) and SHOULD support key exchange with X25519 [RFC7748].</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
9.2.  Mandatory-to-Implement Extensions
 
   In the absence of an application profile standard specifying   otherwise, a TLS-compliant application MUST implement the following   TLS extensions:
 
   -  Supported Versions ("supported_versions"; Section 4.2.1)
 
   -  Cookie ("cookie"; Section 4.2.2)
 
   -  Signature Algorithms ("signature_algorithms"; Section 4.2.3)
 
   -  Signature Algorithms Certificate ("signature_algorithms_cert";      Section 4.2.3)
 
   -  Negotiated Groups ("supported_groups"; Section 4.2.7)
 
   -  Key Share ("key_share"; Section 4.2.8)
 
   -  Server Name Indication ("server_name"; Section&nbsp;3 of [RFC6066])
 
   All implementations MUST send and use these extensions when offering   applicable features:
 
   -  "supported_versions" is REQUIRED for all ClientHello, ServerHello,      and HelloRetryRequest messages.
 
   -  "signature_algorithms" is REQUIRED for certificate authentication.
 
   -  "supported_groups" is REQUIRED for ClientHello messages using DHE      or ECDHE key exchange.
 
   -  "key_share" is REQUIRED for DHE or ECDHE key exchange.
 
   -  "pre_shared_key" is REQUIRED for PSK key agreement.
 
   -  "psk_key_exchange_modes" is REQUIRED for PSK key agreement.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   A client is considered to be attempting to negotiate using this   specification if the ClientHello contains a "supported_versions"   extension with 0x0304 contained in its body.  Such a ClientHello   message MUST meet the following requirements:
 
   -  If not containing a "pre_shared_key" extension, it MUST contain      both a "signature_algorithms" extension and a "supported_groups"      extension.
 
   -  If containing a "supported_groups" extension, it MUST also contain      a "key_share" extension, and vice versa.  An empty
      KeyShare.client_shares vector is permitted.
 
   Servers receiving a ClientHello which does not conform to these   requirements MUST abort the handshake with a "missing_extension"   alert.
 
   Additionally, all implementations MUST support the use of the   "server_name" extension with applications capable of using it.   Servers MAY require clients to send a valid "server_name" extension.   Servers requiring this extension SHOULD respond to a ClientHello   lacking a "server_name" extension by terminating the connection with   a "missing_extension" alert.
 
9.3.  Protocol Invariants
 
   This section describes invariants that TLS endpoints and middleboxes   MUST follow.  It also applies to earlier versions of TLS.
 
   TLS is designed to be securely and compatibly extensible.  Newer   clients or servers, when communicating with newer peers, should   negotiate the most preferred common parameters.  The TLS handshake   provides downgrade protection: Middleboxes passing traffic between a   newer client and newer server without terminating TLS should be   unable to influence the handshake (see Appendix E.1).  At the same   time, deployments update at different rates, so a newer client or   server MAY continue to support older parameters, which would allow it   to interoperate with older endpoints.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   For this to work, implementations MUST correctly handle extensible   fields:
 
   -  A client sending a ClientHello MUST support all parameters      advertised in it.  Otherwise, the server may fail to interoperate      by selecting one of those parameters.
 
   -  A server receiving a ClientHello MUST correctly ignore all      unrecognized cipher suites, extensions, and other parameters.      Otherwise, it may fail to interoperate with newer clients.  In      TLS 1.3, a client receiving a CertificateRequest or
      NewSessionTicket MUST also ignore all unrecognized extensions.
 
   -  A middlebox which terminates a TLS connection MUST behave as a      compliant TLS server (to the original client), including having a      certificate which the client is willing to accept, and also as a      compliant TLS client (to the original server), including verifying      the original server's certificate.  In particular, it MUST      generate its own ClientHello containing only parameters it      understands, and it MUST generate a fresh ServerHello random      value, rather than forwarding the endpoint's value.
 
      Note that TLS's protocol requirements and security analysis only      apply to the two connections separately.  Safely deploying a TLS      terminator requires additional security considerations which are      beyond the scope of this document.
 
   -  A middlebox which forwards ClientHello parameters it does not      understand MUST NOT process any messages beyond that ClientHello.      It MUST forward all subsequent traffic unmodified.  Otherwise, it      may fail to interoperate with newer clients and servers.
 
      Forwarded ClientHellos may contain advertisements for features not      supported by the middlebox, so the response may include future TLS      additions the middlebox does not recognize.  These additions MAY      change any message beyond the ClientHello arbitrarily.  In      particular, the values sent in the ServerHello might change, the      ServerHello format might change, and the TLSCiphertext format      might change.
 
   The design of TLS 1.3 was constrained by widely deployed   non-compliant TLS middleboxes (see Appendix D.4); however, it does   not relax the invariants.  Those middleboxes continue to be   non-compliant.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
10.  Security Considerations
 
   Security issues are discussed throughout this memo, especially in   Appendices C, D, and E.
 
11.  IANA Considerations
 
   This document uses several registries that were originally created in   [RFC4346] and updated in [RFC8447].  IANA has updated these to   reference this document.  The registries and their allocation   policies are below:
 
   -  TLS Cipher Suites registry: values with the first byte in the      range 0-254 (decimal) are assigned via Specification Required      [RFC8126].  Values with the first byte 255 (decimal) are reserved      for Private Use [RFC8126].
 
      IANA has added the cipher suites listed in Appendix B.4 to the      registry.  The "Value" and "Description" columns are taken from      the table.  The "DTLS-OK" and "Recommended" columns are both      marked as "Y" for each new cipher suite.
 
   -  TLS ContentType registry: Future values are allocated via      Standards Action [RFC8126].
 
   -  TLS Alerts registry: Future values are allocated via Standards      Action [RFC8126].  IANA has populated this registry with the      values from Appendix B.2.  The "DTLS-OK" column is marked as "Y"      for all such values.  Values marked as "_RESERVED" have comments      describing their previous usage.
 
   -  TLS HandshakeType registry: Future values are allocated via      Standards Action [RFC8126].  IANA has updated this registry to      rename item 4 from "NewSessionTicket" to "new_session_ticket" and      populated this registry with the values from Appendix B.3.  The      "DTLS-OK" column is marked as "Y" for all such values.  Values      marked "_RESERVED" have comments describing their previous or      temporary usage.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   This document also uses the TLS ExtensionType Values registry   originally created in [RFC4366].  IANA has updated it to reference   this document.  Changes to the registry follow:
 
   -  IANA has updated the registration policy as follows:
 
      Values with the first byte in the range 0-254 (decimal) are      assigned via Specification Required [RFC8126].  Values with the      first byte 255 (decimal) are reserved for Private Use [RFC8126].
 
   -  IANA has updated this registry to include the "key_share",      "pre_shared_key", "psk_key_exchange_modes", "early_data",      "cookie", "supported_versions", "certificate_authorities",      "oid_filters", "post_handshake_auth", and
      "signature_algorithms_cert" extensions with the values defined in      this document and the "Recommended" value of "Y".
 
   -  IANA has updated this registry to include a "TLS 1.3" column which      lists the messages in which the extension may appear.  This column      has been initially populated from the table in Section 4.2, with      any extension not listed there marked as "-" to indicate that it      is not used by TLS 1.3.
 
   This document updates an entry in the TLS Certificate Types registry   originally created in [RFC6091] and updated in [RFC8447].  IANA has   updated the entry for value 1 to have the name "OpenPGP_RESERVED",   "Recommended" value "N", and comment "Used in TLS versions prior   to 1.3."
 
   This document updates an entry in the TLS Certificate Status Types   registry originally created in [RFC6961].  IANA has updated the entry   for value 2 to have the name "ocsp_multi_RESERVED" and comment "Used   in TLS versions prior to 1.3".
 
   This document updates two entries in the TLS Supported Groups   registry (created under a different name by [RFC4492]; now maintained   by [RFC8422]) and updated by [RFC7919] and [RFC8447].  The entries   for values 29 and 30 (x25519 and x448) have been updated to also   refer to this document.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   In addition, this document defines two new registries that are   maintained by IANA:
 
   -  TLS SignatureScheme registry: Values with the first byte in the      range 0-253 (decimal) are assigned via Specification Required      [RFC8126].  Values with the first byte 254 or 255 (decimal) are      reserved for Private Use [RFC8126].  Values with the first byte in      the range 0-6 or with the second byte in the range 0-3 that are      not currently allocated are reserved for backward compatibility.      This registry has a "Recommended" column.  The registry has been      initially populated with the values described in Section 4.2.3.      The following values are marked as "Recommended":
      ecdsa_secp256r1_sha256, ecdsa_secp384r1_sha384,      rsa_pss_rsae_sha256, rsa_pss_rsae_sha384, rsa_pss_rsae_sha512,      rsa_pss_pss_sha256, rsa_pss_pss_sha384, rsa_pss_pss_sha512, and      ed25519.  The "Recommended" column is assigned a value of "N"      unless explicitly requested, and adding a value with a      "Recommended" value of "Y" requires Standards Action [RFC8126].      IESG Approval is REQUIRED for a Y-&gt;N transition.
 
   -  TLS PskKeyExchangeMode registry: Values in the range 0-253      (decimal) are assigned via Specification Required [RFC8126].      The values 254 and 255 (decimal) are reserved for Private Use      [RFC8126].  This registry has a "Recommended" column.  The      registry has been initially populated with psk_ke (0) and      psk_dhe_ke (1).  Both are marked as "Recommended".  The      "Recommended" column is assigned a value of "N" unless explicitly      requested, and adding a value with a "Recommended" value of "Y"      requires Standards Action [RFC8126].  IESG Approval is REQUIRED      for a Y-&gt;N transition.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
12.  References
 
12.1.  Normative References
 
   [DH76]     Diffie, W. and M. Hellman, "New directions in
              cryptography", IEEE Transactions on Information
              Theory, Vol. 22 No. 6, pp. 644-654,
              DOI 10.1109/TIT.1976.1055638, November 1976.
 
   [ECDSA]    American National Standards Institute, "Public Key              Cryptography for the Financial Services Industry: The              Elliptic Curve Digital Signature Algorithm (ECDSA)",              ANSI ANS X9.62-2005, November 2005.
 
   [GCM]      Dworkin, M., "Recommendation for Block Cipher Modes of              Operation: Galois/Counter Mode (GCM) and GMAC",
              NIST Special Publication 800-38D,
              DOI 10.6028/NIST.SP.800-38D, November 2007.
 
   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-              Hashing for Message Authentication", RFC 2104,
              DOI 10.17487/RFC2104, February 1997,
              <https: www.rfc-editor.org="" info="" rfc2104="">.
 
   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https: www.rfc-editor.org="" info="" rfc2119="">.
 
   [RFC5116]  McGrew, D., "An Interface and Algorithms for Authenticated              Encryption", RFC 5116, DOI 10.17487/RFC5116, January 2008,              <https: www.rfc-editor.org="" info="" rfc5116="">.
 
   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List              (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May 2008,              <https: www.rfc-editor.org="" info="" rfc5280="">.
 
   [RFC5705]  Rescorla, E., "Keying Material Exporters for Transport              Layer Security (TLS)", RFC 5705, DOI 10.17487/RFC5705,              March 2010, <https: www.rfc-editor.org="" info="" rfc5705="">.
 
   [RFC5756]  Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk,              "Updates for RSAES-OAEP and RSASSA-PSS Algorithm
              Parameters", RFC 5756, DOI 10.17487/RFC5756, January 2010,              <https: www.rfc-editor.org="" info="" rfc5756="">.</https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [RFC5869]  Krawczyk, H. and P. Eronen, "HMAC-based Extract-and-Expand              Key Derivation Function (HKDF)", RFC 5869,
              DOI 10.17487/RFC5869, May 2010,
              <https: www.rfc-editor.org="" info="" rfc5869="">.
 
   [RFC6066]  Eastlake 3rd, D., "Transport Layer Security (TLS)              Extensions: Extension Definitions", RFC 6066,
              DOI 10.17487/RFC6066, January 2011,
              <https: www.rfc-editor.org="" info="" rfc6066="">.
 
   [RFC6655]  McGrew, D. and D. Bailey, "AES-CCM Cipher Suites for              Transport Layer Security (TLS)", RFC 6655,
              DOI 10.17487/RFC6655, July 2012,
              <https: www.rfc-editor.org="" info="" rfc6655="">.
 
   [RFC6960]  Santesson, S., Myers, M., Ankney, R., Malpani, A.,              Galperin, S., and C. Adams, "X.509 Internet Public Key              Infrastructure Online Certificate Status Protocol - OCSP",              RFC 6960, DOI 10.17487/RFC6960, June 2013,
              <https: www.rfc-editor.org="" info="" rfc6960="">.
 
   [RFC6961]  Pettersen, Y., "The Transport Layer Security (TLS)              Multiple Certificate Status Request Extension", RFC 6961,              DOI 10.17487/RFC6961, June 2013,
              <https: www.rfc-editor.org="" info="" rfc6961="">.
 
   [RFC6962]  Laurie, B., Langley, A., and E. Kasper, "Certificate              Transparency", RFC 6962, DOI 10.17487/RFC6962, June 2013,              <https: www.rfc-editor.org="" info="" rfc6962="">.
 
   [RFC6979]  Pornin, T., "Deterministic Usage of the Digital Signature              Algorithm (DSA) and Elliptic Curve Digital Signature              Algorithm (ECDSA)", RFC 6979, DOI 10.17487/RFC6979,              August 2013, <https: www.rfc-editor.org="" info="" rfc6979="">.
 
   [RFC7301]  Friedl, S., Popov, A., Langley, A., and E. Stephan,              "Transport Layer Security (TLS) Application-Layer Protocol              Negotiation Extension", RFC 7301, DOI 10.17487/RFC7301,              July 2014, <https: www.rfc-editor.org="" info="" rfc7301="">.
 
   [RFC7507]  Moeller, B. and A. Langley, "TLS Fallback Signaling Cipher              Suite Value (SCSV) for Preventing Protocol Downgrade              Attacks", RFC 7507, DOI 10.17487/RFC7507, April 2015,              <https: www.rfc-editor.org="" info="" rfc7507="">.
 
   [RFC7748]  Langley, A., Hamburg, M., and S. Turner, "Elliptic Curves              for Security", RFC 7748, DOI 10.17487/RFC7748,
              January 2016, <https: www.rfc-editor.org="" info="" rfc7748="">.</https:></https:></https:></https:></https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [RFC7919]  Gillmor, D., "Negotiated Finite Field Diffie-Hellman              Ephemeral Parameters for Transport Layer Security (TLS)",              RFC 7919, DOI 10.17487/RFC7919, August 2016,
              <https: www.rfc-editor.org="" info="" rfc7919="">.
 
   [RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,              "PKCS #1: RSA Cryptography Specifications Version 2.2",              RFC 8017, DOI 10.17487/RFC8017, November 2016,
              <https: www.rfc-editor.org="" info="" rfc8017="">.
 
   [RFC8032]  Josefsson, S. and I. Liusvaara, "Edwards-Curve Digital              Signature Algorithm (EdDSA)", RFC 8032,
              DOI 10.17487/RFC8032, January 2017,
              <https: www.rfc-editor.org="" info="" rfc8032="">.
 
   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for              Writing an IANA Considerations Section in RFCs", BCP 26,              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https: www.rfc-editor.org="" info="" rfc8126="">.
 
   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in              RFC 2119 Key Words", BCP 14, RFC 8174,
              DOI 10.17487/RFC8174, May 2017,
              <https: www.rfc-editor.org="" info="" rfc8174="">.
 
   [RFC8439]  Nir, Y. and A. Langley, "ChaCha20 and Poly1305 for IETF              Protocols", RFC 8439, DOI 10.17487/RFC8439, June 2018,              <https: www.rfc-editor.org="" info="" rfc8439="">.
 
   [SHS]      Dang, Q., "Secure Hash Standard (SHS)", National Institute              of Standards and Technology report,
              DOI 10.6028/NIST.FIPS.180-4, August 2015.
 
   [X690]     ITU-T, "Information technology -- ASN.1 encoding rules:              Specification of Basic Encoding Rules (BER), Canonical              Encoding Rules (CER) and Distinguished Encoding Rules              (DER)", ISO/IEC 8825-1:2015, November 2015.</https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
12.2.  Informative References
 
   [AEAD-LIMITS]
              Luykx, A. and K. Paterson, "Limits on Authenticated
              Encryption Use in TLS", August 2017,
              <http: www.isg.rhul.ac.uk="" ~kp="" tls-aebounds.pdf="">.
 
   [BBFGKZ16]
              Bhargavan, K., Brzuska, C., Fournet, C., Green, M.,
              Kohlweiss, M., and S. Zanella-Beguelin, "Downgrade              Resilience in Key-Exchange Protocols", Proceedings of IEEE              Symposium on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.37, May 2016.
 
   [BBK17]    Bhargavan, K., Blanchet, B., and N. Kobeissi, "Verified              Models and Reference Implementations for the TLS 1.3              Standard Candidate", Proceedings of IEEE Symposium on              Security and Privacy (San Jose), DOI 10.1109/SP.2017.26,              May 2017.
 
   [BDFKPPRSZZ16]
              Bhargavan, K., Delignat-Lavaud, A., Fournet, C.,
              Kohlweiss, M., Pan, J., Protzenko, J., Rastogi, A., Swamy,              N., Zanella-Beguelin, S., and J. Zinzindohoue,
              "Implementing and Proving the TLS 1.3 Record Layer",              Proceedings of IEEE Symposium on Security and Privacy (San              Jose), May 2017, <https: eprint.iacr.org="" 2016="" 1178="">.
 
   [Ben17a]   Benjamin, D., "Presentation before the TLS WG at              IETF 100", November 2017,
              <https: datatracker.ietf.org="" meeting="" 100="" materials="" slides-100-tls-sessa-tls13=""></https:>.
 
   [Ben17b]   Benjamin, D., "Additional TLS 1.3 results from Chrome",              message to the TLS mailing list, 18 December 2017,
              <https: www.ietf.org="" mail-archive="" web="" tls="" current="" msg25168.html="">.
 
   [Blei98]   Bleichenbacher, D., "Chosen Ciphertext Attacks against              Protocols Based on RSA Encryption Standard PKCS #1",              Proceedings of CRYPTO '98, 1998.
 
   [BMMRT15]  Badertscher, C., Matt, C., Maurer, U., Rogaway, P., and B.              Tackmann, "Augmented Secure Channels and the Goal of the              TLS 1.3 Record Layer", ProvSec 2015, September 2015,              <https: eprint.iacr.org="" 2015="" 394="">.</https:></https:></https:></http:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [BT16]     Bellare, M. and B. Tackmann, "The Multi-User Security of              Authenticated Encryption: AES-GCM in TLS 1.3", Proceedings              of CRYPTO 2016, July 2016,
              <https: eprint.iacr.org="" 2016="" 564="">.
 
   [CCG16]    Cohn-Gordon, K., Cremers, C., and L. Garratt, "On              Post-compromise Security", IEEE Computer Security              Foundations Symposium, DOI 10.1109/CSF.2016.19, July 2015.
 
   [CHECKOWAY]
              Checkoway, S., Maskiewicz, J., Garman, C., Fried, J.,              Cohney, S., Green, M., Heninger, N., Weinmann, R.,
              Rescorla, E., and H. Shacham, "A Systematic Analysis of              the Juniper Dual EC Incident", Proceedings of the 2016 ACM              SIGSAC Conference on Computer and Communications Security              - CCS '16, DOI 10.1145/2976749.2978395, October 2016.
 
   [CHHSV17]  Cremers, C., Horvat, M., Hoyland, J., Scott, S., and T.              van der Merwe, "Awkward Handshake: Possible mismatch of              client/server view on client authentication in
              post-handshake mode in Revision 18", message to the TLS              mailing list, 10 February 2017, <https: www.ietf.org="" mail-archive="" web="" tls="" current="" msg22382.html="">.
 
   [CHSV16]   Cremers, C., Horvat, M., Scott, S., and T. van der Merwe,              "Automated Analysis and Verification of TLS 1.3: 0-RTT,              Resumption and Delayed Authentication", Proceedings of              IEEE Symposium on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.35, May 2016,
              <https: ieeexplore.ieee.org="" document="" 7546518=""></https:>.
 
   [CK01]     Canetti, R. and H. Krawczyk, "Analysis of Key-Exchange              Protocols and Their Use for Building Secure Channels",              Proceedings of Eurocrypt 2001,
              DOI 10.1007/3-540-44987-6_28, April 2001.
 
   [CLINIC]   Miller, B., Huang, L., Joseph, A., and J. Tygar, "I Know              Why You Went to the Clinic: Risks and Realization of HTTPS              Traffic Analysis", Privacy Enhancing Technologies, pp.              143-163, DOI 10.1007/978-3-319-08506-7_8, 2014.
 
   [DFGS15]   Dowling, B., Fischlin, M., Guenther, F., and D. Stebila,              "A Cryptographic Analysis of the TLS 1.3 Handshake
              Protocol Candidates", Proceedings of ACM CCS 2015,
              October 2015, <https: eprint.iacr.org="" 2015="" 914="">.</https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [DFGS16]   Dowling, B., Fischlin, M., Guenther, F., and D. Stebila,              "A Cryptographic Analysis of the TLS 1.3 Full and
              Pre-shared Key Handshake Protocol", TRON 2016,
              February 2016, <https: eprint.iacr.org="" 2016="" 081="">.
 
   [DOW92]    Diffie, W., van Oorschot, P., and M. Wiener,
              "Authentication and authenticated key exchanges", Designs,              Codes and Cryptography, DOI 10.1007/BF00124891, June 1992.
 
   [DSS]      National Institute of Standards and Technology, U.S.              Department of Commerce, "Digital Signature Standard              (DSS)", NIST FIPS PUB 186-4, DOI 10.6028/NIST.FIPS.186-4,              July 2013.
 
   [FG17]     Fischlin, M. and F. Guenther, "Replay Attacks on Zero              Round-Trip Time: The Case of the TLS 1.3 Handshake
              Candidates", Proceedings of EuroS&amp;P 2017, April 2017,              <https: eprint.iacr.org="" 2017="" 082="">.
 
   [FGSW16]   Fischlin, M., Guenther, F., Schmidt, B., and B. Warinschi,              "Key Confirmation in Key Exchange: A Formal Treatment and              Implications for TLS 1.3", Proceedings of IEEE Symposium              on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.34, May 2016,
              <https: ieeexplore.ieee.org="" document="" 7546517=""></https:>.
 
   [FW15]     Weimer, F., "Factoring RSA Keys With TLS Perfect Forward              Secrecy", September 2015.
 
   [HCJC16]   Husak, M., Cermak, M., Jirsik, T., and P. Celeda, "HTTPS              traffic analysis and client identification using passive              SSL/TLS fingerprinting", EURASIP Journal on Information              Security, Vol. 2016, DOI 10.1186/s13635-016-0030-7,              February 2016.
 
   [HGFS15]   Hlauschek, C., Gruber, M., Fankhauser, F., and C. Schanes,              "Prying Open Pandora's Box: KCI Attacks against TLS",              Proceedings of USENIX Workshop on Offensive Technologies,              August 2015.
 
   [IEEE1363]
              IEEE, "IEEE Standard Specifications for Public Key
              Cryptography", IEEE Std. 1363-2000,
              DOI 10.1109/IEEESTD.2000.92292.</https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [JSS15]    Jager, T., Schwenk, J., and J. Somorovsky, "On the              Security of TLS 1.3 and QUIC Against Weaknesses in PKCS#1              v1.5 Encryption", Proceedings of ACM CCS 2015,
              DOI 10.1145/2810103.2813657, October 2015,
              <https: www.nds.rub.de="" media="" nds="" veroeffentlichungen="" 2015="" 08="" 21="" tls13quicattacks.pdf="">.
 
   [KEYAGREEMENT]
              Barker, E., Chen, L., Roginsky, A., Vassilev, A., and R.              Davis, "Recommendation for Pair-Wise Key Establishment              Schemes Using Discrete Logarithm Cryptography", National              Institute of Standards and Technology,
              DOI 10.6028/NIST.SP.800-56Ar3, April 2018.
 
   [Kraw10]   Krawczyk, H., "Cryptographic Extraction and Key              Derivation: The HKDF Scheme", Proceedings of CRYPTO 2010,              August 2010, <https: eprint.iacr.org="" 2010="" 264="">.
 
   [Kraw16]   Krawczyk, H., "A Unilateral-to-Mutual Authentication              Compiler for Key Exchange (with Applications to Client              Authentication in TLS 1.3", Proceedings of ACM CCS 2016,              October 2016, <https: eprint.iacr.org="" 2016="" 711="">.
 
   [KW16]     Krawczyk, H. and H. Wee, "The OPTLS Protocol and TLS 1.3",              Proceedings of EuroS&amp;P 2016, March 2016,
              <https: eprint.iacr.org="" 2015="" 978="">.
 
   [LXZFH16]  Li, X., Xu, J., Zhang, Z., Feng, D., and H. Hu, "Multiple              Handshakes Security of TLS 1.3 Candidates", Proceedings of              IEEE Symposium on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.36, May 2016,
              <https: ieeexplore.ieee.org="" document="" 7546519=""></https:>.
 
   [Mac17]    MacCarthaigh, C., "Security Review of TLS1.3 0-RTT",              March 2017, <https: github.com="" tlswg="" tls13-spec="" issues="" 1001="">.
 
   [PS18]     Patton, C. and T. Shrimpton, "Partially specified              channels: The TLS 1.3 record layer without elision", 2018,              <https: eprint.iacr.org="" 2018="" 634="">.
 
   [PSK-FINISHED]
              Scott, S., Cremers, C., Horvat, M., and T. van der Merwe,              "Revision 10: possible attack if client authentication is              allowed during PSK", message to the TLS mailing list,              31 October 2015, <https: www.ietf.org="" mail-archive="" web="" tls="" current="" msg18215.html="">.</https:></https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [REKEY]    Abdalla, M. and M. Bellare, "Increasing the Lifetime of a              Key: A Comparative Analysis of the Security of Re-keying              Techniques", ASIACRYPT 2000, DOI 10.1007/3-540-44448-3_42,              October 2000.
 
   [Res17a]   Rescorla, E., "Preliminary data on Firefox TLS 1.3              Middlebox experiment", message to the TLS mailing list,              5 December 2017, <https: www.ietf.org="" mail-archive="" web="" tls="" current="" msg25091.html="">.
 
   [Res17b]   Rescorla, E., "More compatibility measurement results",              message to the TLS mailing list, 22 December 2017,
              <https: www.ietf.org="" mail-archive="" web="" tls="" current="" msg25179.html="">.
 
   [RFC3552]  Rescorla, E. and B. Korver, "Guidelines for Writing RFC              Text on Security Considerations", BCP 72, RFC 3552,
              DOI 10.17487/RFC3552, July 2003,
              <https: www.rfc-editor.org="" info="" rfc3552="">.
 
   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,              "Randomness Requirements for Security", BCP 106, RFC 4086,              DOI 10.17487/RFC4086, June 2005,
              <https: www.rfc-editor.org="" info="" rfc4086="">.
 
   [RFC4346]  Dierks, T. and E. Rescorla, "The Transport Layer Security              (TLS) Protocol Version 1.1", RFC 4346,
              DOI 10.17487/RFC4346, April 2006,
              <https: www.rfc-editor.org="" info="" rfc4346="">.
 
   [RFC4366]  Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J.,              and T. Wright, "Transport Layer Security (TLS)
              Extensions", RFC 4366, DOI 10.17487/RFC4366, April 2006,              <https: www.rfc-editor.org="" info="" rfc4366="">.
 
   [RFC4492]  Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B.              Moeller, "Elliptic Curve Cryptography (ECC) Cipher Suites              for Transport Layer Security (TLS)", RFC 4492,
              DOI 10.17487/RFC4492, May 2006,
              <https: www.rfc-editor.org="" info="" rfc4492="">.
 
   [RFC5077]  Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig,              "Transport Layer Security (TLS) Session Resumption without              Server-Side State", RFC 5077, DOI 10.17487/RFC5077,              January 2008, <https: www.rfc-editor.org="" info="" rfc5077="">.</https:></https:></https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security              (TLS) Protocol Version 1.2", RFC 5246,
              DOI 10.17487/RFC5246, August 2008,
              <https: www.rfc-editor.org="" info="" rfc5246="">.
 
   [RFC5764]  McGrew, D. and E. Rescorla, "Datagram Transport Layer              Security (DTLS) Extension to Establish Keys for the Secure              Real-time Transport Protocol (SRTP)", RFC 5764,
              DOI 10.17487/RFC5764, May 2010,
              <https: www.rfc-editor.org="" info="" rfc5764="">.
 
   [RFC5929]  Altman, J., Williams, N., and L. Zhu, "Channel Bindings              for TLS", RFC 5929, DOI 10.17487/RFC5929, July 2010,              <https: www.rfc-editor.org="" info="" rfc5929="">.
 
   [RFC6091]  Mavrogiannopoulos, N. and D. Gillmor, "Using OpenPGP Keys              for Transport Layer Security (TLS) Authentication",              RFC 6091, DOI 10.17487/RFC6091, February 2011,
              <https: www.rfc-editor.org="" info="" rfc6091="">.
 
   [RFC6101]  Freier, A., Karlton, P., and P. Kocher, "The Secure              Sockets Layer (SSL) Protocol Version 3.0", RFC 6101,              DOI 10.17487/RFC6101, August 2011,
              <https: www.rfc-editor.org="" info="" rfc6101="">.
 
   [RFC6176]  Turner, S. and T. Polk, "Prohibiting Secure Sockets Layer              (SSL) Version 2.0", RFC 6176, DOI 10.17487/RFC6176,              March 2011, <https: www.rfc-editor.org="" info="" rfc6176="">.
 
   [RFC6347]  Rescorla, E. and N. Modadugu, "Datagram Transport Layer              Security Version 1.2", RFC 6347, DOI 10.17487/RFC6347,              January 2012, <https: www.rfc-editor.org="" info="" rfc6347="">.
 
   [RFC6520]  Seggelmann, R., Tuexen, M., and M. Williams, "Transport              Layer Security (TLS) and Datagram Transport Layer Security              (DTLS) Heartbeat Extension", RFC 6520,
              DOI 10.17487/RFC6520, February 2012,
              <https: www.rfc-editor.org="" info="" rfc6520="">.
 
   [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer              Protocol (HTTP/1.1): Message Syntax and Routing",
              RFC 7230, DOI 10.17487/RFC7230, June 2014,
              <https: www.rfc-editor.org="" info="" rfc7230="">.</https:></https:></https:></https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [RFC7250]  Wouters, P., Ed., Tschofenig, H., Ed., Gilmore, J.,              Weiler, S., and T. Kivinen, "Using Raw Public Keys in
              Transport Layer Security (TLS) and Datagram Transport              Layer Security (DTLS)", RFC 7250, DOI 10.17487/RFC7250,              June 2014, <https: www.rfc-editor.org="" info="" rfc7250="">.
 
   [RFC7465]  Popov, A., "Prohibiting RC4 Cipher Suites", RFC 7465,              DOI 10.17487/RFC7465, February 2015,
              <https: www.rfc-editor.org="" info="" rfc7465="">.
 
   [RFC7568]  Barnes, R., Thomson, M., Pironti, A., and A. Langley,              "Deprecating Secure Sockets Layer Version 3.0", RFC 7568,              DOI 10.17487/RFC7568, June 2015,
              <https: www.rfc-editor.org="" info="" rfc7568="">.
 
   [RFC7627]  Bhargavan, K., Ed., Delignat-Lavaud, A., Pironti, A.,              Langley, A., and M. Ray, "Transport Layer Security (TLS)              Session Hash and Extended Master Secret Extension",              RFC 7627, DOI 10.17487/RFC7627, September 2015,
              <https: www.rfc-editor.org="" info="" rfc7627="">.
 
   [RFC7685]  Langley, A., "A Transport Layer Security (TLS) ClientHello              Padding Extension", RFC 7685, DOI 10.17487/RFC7685,              October 2015, <https: www.rfc-editor.org="" info="" rfc7685="">.
 
   [RFC7924]  Santesson, S. and H. Tschofenig, "Transport Layer Security              (TLS) Cached Information Extension", RFC 7924,
              DOI 10.17487/RFC7924, July 2016,
              <https: www.rfc-editor.org="" info="" rfc7924="">.
 
   [RFC8305]  Schinazi, D. and T. Pauly, "Happy Eyeballs Version 2:              Better Connectivity Using Concurrency", RFC 8305,
              DOI 10.17487/RFC8305, December 2017,
              <https: www.rfc-editor.org="" info="" rfc8305="">.
 
   [RFC8422]  Nir, Y., Josefsson, S., and M. Pegourie-Gonnard, "Elliptic              Curve Cryptography (ECC) Cipher Suites for Transport Layer              Security (TLS) Versions 1.2 and Earlier", RFC 8422,
              DOI 10.17487/RFC8422, August 2018,
              <https: www.rfc-editor.org="" info="" rfc8422="">.
 
   [RFC8447]  Salowey, J. and S. Turner, "IANA Registry Updates for TLS              and DTLS", RFC 8447, DOI 10.17487/RFC8447, August 2018,              <https: www.rfc-editor.org="" info="" rfc8447="">.
 
   [RFC8449]  Thomson, M., "Record Size Limit Extension for TLS",              RFC 8449, DOI 10.17487/RFC8449, August 2018,
              <https: www.rfc-editor.org="" info="" rfc8449="">.</https:></https:></https:></https:></https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [RSA]      Rivest, R., Shamir, A., and L. Adleman, "A Method for              Obtaining Digital Signatures and Public-Key
              Cryptosystems", Communications of the ACM, Vol. 21 No. 2,              pp. 120-126, DOI 10.1145/359340.359342, February 1978.
 
   [SIGMA]    Krawczyk, H., "SIGMA: The 'SIGn-and-MAc' Approach to              Authenticated Diffie-Hellman and its Use in the IKE
              Protocols", Proceedings of CRYPTO 2003,
              DOI 10.1007/978-3-540-45146-4_24, August 2003.
 
   [SLOTH]    Bhargavan, K. and G. Leurent, "Transcript Collision              Attacks: Breaking Authentication in TLS, IKE, and SSH",              Network and Distributed System Security
              Symposium (NDSS 2016), DOI 10.14722/ndss.2016.23418,              February 2016.
 
   [SSL2]     Hickman, K., "The SSL Protocol", February 1995.
 
   [TIMING]   Boneh, D. and D. Brumley, "Remote Timing Attacks Are              Practical", USENIX Security Symposium, August 2003.
 
   [TLS13-TRACES]
              Thomson, M., "Example Handshake Traces for TLS 1.3", Work              in Progress, draft-ietf-tls-tls13-vectors-06, July 2018.
 
   [X501]     ITU-T, "Information Technology - Open Systems              Interconnection - The Directory: Models", ITU-T X.501,              October 2016, <https: www.itu.int="" rec="" t-rec-x.501="" en="">.</https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
Appendix A.  State Machine
 
   This appendix provides a summary of the legal state transitions for   the client and server handshakes.  State names (in all capitals,   e.g., START) have no formal meaning but are provided for ease of   comprehension.  Actions which are taken only in certain circumstances   are indicated in [].  The notation "K_{send,recv} = foo" means "set   the send/recv key to the given key".
 
A.1.  Client
 
                              START &lt;----+
               Send ClientHello |        | Recv HelloRetryRequest
          [K_send = early data] |        |
                                v        |
           /                 WAIT_SH ----+
           |                    | Recv ServerHello
           |                    | K_recv = handshake
       Can |                    V
      send |                 WAIT_EE
     early |                    | Recv EncryptedExtensions
      data |           +--------+--------+
           |     Using |                 | Using certificate
           |       PSK |                 v
           |           |            WAIT_CERT_CR
           |           |        Recv |       | Recv CertificateRequest
           |           | Certificate |       v
           |           |             |    WAIT_CERT
           |           |             |       | Recv Certificate
           |           |             v       v
           |           |              WAIT_CV
           |           |                 | Recv CertificateVerify
           |           +&gt; WAIT_FINISHED &lt;+
           |                  | Recv Finished
           \                  | [Send EndOfEarlyData]
                              | K_send = handshake
                              | [Send Certificate [+ CertificateVerify]]
    Can send                  | Send Finished
    app data   --&gt;            | K_send = K_recv = application
    after here                v
                          CONNECTED
 
   Note that with the transitions as shown above, clients may send   alerts that derive from post-ServerHello messages in the clear or   with the early data keys.  If clients need to send such alerts, they   SHOULD first rekey to the handshake keys if possible.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
A.2.  Server
 
                              START &lt;-----+
               Recv ClientHello |         | Send HelloRetryRequest
                                v         |
                             RECVD_CH ----+
                                | Select parameters
                                v
                             NEGOTIATED
                                | Send ServerHello
                                | K_send = handshake
                                | Send EncryptedExtensions
                                | [Send CertificateRequest]
 Can send                       | [Send Certificate + CertificateVerify]
 app data                       | Send Finished
 after   --&gt;                    | K_send = application
 here                  +--------+--------+
              No 0-RTT |                 | 0-RTT
                       |                 |
   K_recv = handshake  |                 | K_recv = early data
 [Skip decrypt errors] |    +------&gt; WAIT_EOED -+
                       |    |       Recv |      | Recv EndOfEarlyData
                       |    | early data |      | K_recv = handshake
                       |    +------------+      |
                       |                        |
                       +&gt; WAIT_FLIGHT2 &lt;--------+
                                |
                       +--------+--------+
               No auth |                 | Client auth
                       |                 |
                       |                 v
                       |             WAIT_CERT
                       |        Recv |       | Recv Certificate
                       |       empty |       v
                       | Certificate |    WAIT_CV
                       |             |       | Recv
                       |             v       | CertificateVerify
                       +-&gt; WAIT_FINISHED &lt;---+
                                | Recv Finished
                                | K_recv = application
                                v
                            CONNECTED</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
Appendix B.  Protocol Data Structures and Constant Values
 
   This appendix provides the normative protocol types and the   definitions for constants.  Values listed as "_RESERVED" were used in   previous versions of TLS and are listed here for completeness.   TLS 1.3 implementations MUST NOT send them but might receive them   from older TLS implementations.
 
B.1.  Record Layer
 
      enum {
          invalid(0),
          change_cipher_spec(20),
          alert(21),
          handshake(22),
          application_data(23),
          heartbeat(24),  /* RFC 6520 */
          (255)
      } ContentType;
 
      struct {
          ContentType type;
          ProtocolVersion legacy_record_version;
          uint16 length;
          opaque fragment[TLSPlaintext.length];
      } TLSPlaintext;
 
      struct {
          opaque content[TLSPlaintext.length];
          ContentType type;
          uint8 zeros[length_of_padding];
      } TLSInnerPlaintext;
 
      struct {
          ContentType opaque_type = application_data; /* 23 */          ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */          uint16 length;
          opaque encrypted_record[TLSCiphertext.length];      } TLSCiphertext;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.2.  Alert Messages
 
      enum { warning(1), fatal(2), (255) } AlertLevel;
 
      enum {
          close_notify(0),
          unexpected_message(10),
          bad_record_mac(20),
          decryption_failed_RESERVED(21),
          record_overflow(22),
          decompression_failure_RESERVED(30),
          handshake_failure(40),
          no_certificate_RESERVED(41),
          bad_certificate(42),
          unsupported_certificate(43),
          certificate_revoked(44),
          certificate_expired(45),
          certificate_unknown(46),
          illegal_parameter(47),
          unknown_ca(48),
          access_denied(49),
          decode_error(50),
          decrypt_error(51),
          export_restriction_RESERVED(60),
          protocol_version(70),
          insufficient_security(71),
          internal_error(80),
          inappropriate_fallback(86),
          user_canceled(90),
          no_renegotiation_RESERVED(100),
          missing_extension(109),
          unsupported_extension(110),
          certificate_unobtainable_RESERVED(111),
          unrecognized_name(112),
          bad_certificate_status_response(113),
          bad_certificate_hash_value_RESERVED(114),
          unknown_psk_identity(115),
          certificate_required(116),
          no_application_protocol(120),
          (255)
      } AlertDescription;
 
      struct {
          AlertLevel level;
          AlertDescription description;
      } Alert;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.  Handshake Protocol
 
      enum {
          hello_request_RESERVED(0),
          client_hello(1),
          server_hello(2),
          hello_verify_request_RESERVED(3),
          new_session_ticket(4),
          end_of_early_data(5),
          hello_retry_request_RESERVED(6),
          encrypted_extensions(8),
          certificate(11),
          server_key_exchange_RESERVED(12),
          certificate_request(13),
          server_hello_done_RESERVED(14),
          certificate_verify(15),
          client_key_exchange_RESERVED(16),
          finished(20),
          certificate_url_RESERVED(21),
          certificate_status_RESERVED(22),
          supplemental_data_RESERVED(23),
          key_update(24),
          message_hash(254),
          (255)
      } HandshakeType;
 
      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* bytes in message */
          select (Handshake.msg_type) {
              case client_hello:          ClientHello;
              case server_hello:          ServerHello;
              case end_of_early_data:     EndOfEarlyData;
              case encrypted_extensions:  EncryptedExtensions;              case certificate_request:   CertificateRequest;
              case certificate:           Certificate;
              case certificate_verify:    CertificateVerify;
              case finished:              Finished;
              case new_session_ticket:    NewSessionTicket;
              case key_update:            KeyUpdate;
          };
      } Handshake;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.1.  Key Exchange Messages
 
    uint16 ProtocolVersion;
    opaque Random[32];
 
    uint8 CipherSuite[2];    /* Cryptographic suite selector */
 
    struct {
        ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */        Random random;
        opaque legacy_session_id&lt;0..32&gt;;
        CipherSuite cipher_suites&lt;2..2^16-2&gt;;
        opaque legacy_compression_methods&lt;1..2^8-1&gt;;
        Extension extensions&lt;8..2^16-1&gt;;
    } ClientHello;
 
    struct {
        ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */        Random random;
        opaque legacy_session_id_echo&lt;0..32&gt;;
        CipherSuite cipher_suite;
        uint8 legacy_compression_method = 0;
        Extension extensions&lt;6..2^16-1&gt;;
    } ServerHello;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
    struct {
        ExtensionType extension_type;
        opaque extension_data&lt;0..2^16-1&gt;;
    } Extension;
 
    enum {
        server_name(0),                             /* RFC 6066 */
        max_fragment_length(1),                     /* RFC 6066 */
        status_request(5),                          /* RFC 6066 */
        supported_groups(10),                       /* RFC 8422, 7919 */
        signature_algorithms(13),                   /* RFC 8446 */
        use_srtp(14),                               /* RFC 5764 */
        heartbeat(15),                              /* RFC 6520 */
        application_layer_protocol_negotiation(16), /* RFC 7301 */        signed_certificate_timestamp(18),           /* RFC 6962 */
        client_certificate_type(19),                /* RFC 7250 */
        server_certificate_type(20),                /* RFC 7250 */
        padding(21),                                /* RFC 7685 */
        RESERVED(40),                               /* Used but never
                                                       assigned */
        pre_shared_key(41),                         /* RFC 8446 */
        early_data(42),                             /* RFC 8446 */
        supported_versions(43),                     /* RFC 8446 */
        cookie(44),                                 /* RFC 8446 */
        psk_key_exchange_modes(45),                 /* RFC 8446 */
        RESERVED(46),                               /* Used but never
                                                       assigned */
        certificate_authorities(47),                /* RFC 8446 */
        oid_filters(48),                            /* RFC 8446 */
        post_handshake_auth(49),                    /* RFC 8446 */
        signature_algorithms_cert(50),              /* RFC 8446 */
        key_share(51),                              /* RFC 8446 */
        (65535)
    } ExtensionType;
 
    struct {
        NamedGroup group;
        opaque key_exchange&lt;1..2^16-1&gt;;
    } KeyShareEntry;
 
    struct {
        KeyShareEntry client_shares&lt;0..2^16-1&gt;;
    } KeyShareClientHello;
 
    struct {
        NamedGroup selected_group;
    } KeyShareHelloRetryRequest;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
    struct {
        KeyShareEntry server_share;
    } KeyShareServerHello;
 
    struct {
        uint8 legacy_form = 4;
        opaque X[coordinate_length];
        opaque Y[coordinate_length];
    } UncompressedPointRepresentation;
 
    enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;
 
    struct {
        PskKeyExchangeMode ke_modes&lt;1..255&gt;;
    } PskKeyExchangeModes;
 
    struct {} Empty;
 
    struct {
        select (Handshake.msg_type) {
            case new_session_ticket:   uint32 max_early_data_size;            case client_hello:         Empty;
            case encrypted_extensions: Empty;
        };
    } EarlyDataIndication;
 
    struct {
        opaque identity&lt;1..2^16-1&gt;;
        uint32 obfuscated_ticket_age;
    } PskIdentity;
 
    opaque PskBinderEntry&lt;32..255&gt;;
 
    struct {
        PskIdentity identities&lt;7..2^16-1&gt;;
        PskBinderEntry binders&lt;33..2^16-1&gt;;
    } OfferedPsks;
 
    struct {
        select (Handshake.msg_type) {
            case client_hello: OfferedPsks;
            case server_hello: uint16 selected_identity;
        };
    } PreSharedKeyExtension;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.1.1.  Version Extension
 
      struct {
          select (Handshake.msg_type) {
              case client_hello:
                   ProtocolVersion versions&lt;2..254&gt;;
 
              case server_hello: /* and HelloRetryRequest */
                   ProtocolVersion selected_version;
          };
      } SupportedVersions;
 
B.3.1.2.  Cookie Extension
 
      struct {
          opaque cookie&lt;1..2^16-1&gt;;
      } Cookie;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.1.3.  Signature Algorithm Extension
 
      enum {
          /* RSASSA-PKCS1-v1_5 algorithms */
          rsa_pkcs1_sha256(0x0401),
          rsa_pkcs1_sha384(0x0501),
          rsa_pkcs1_sha512(0x0601),
 
          /* ECDSA algorithms */
          ecdsa_secp256r1_sha256(0x0403),
          ecdsa_secp384r1_sha384(0x0503),
          ecdsa_secp521r1_sha512(0x0603),
 
          /* RSASSA-PSS algorithms with public key OID rsaEncryption */          rsa_pss_rsae_sha256(0x0804),
          rsa_pss_rsae_sha384(0x0805),
          rsa_pss_rsae_sha512(0x0806),
 
          /* EdDSA algorithms */
          ed25519(0x0807),
          ed448(0x0808),
 
          /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */          rsa_pss_pss_sha256(0x0809),
          rsa_pss_pss_sha384(0x080a),
          rsa_pss_pss_sha512(0x080b),
 
          /* Legacy algorithms */
          rsa_pkcs1_sha1(0x0201),
          ecdsa_sha1(0x0203),
 
          /* Reserved Code Points */
          obsolete_RESERVED(0x0000..0x0200),
          dsa_sha1_RESERVED(0x0202),
          obsolete_RESERVED(0x0204..0x0400),
          dsa_sha256_RESERVED(0x0402),
          obsolete_RESERVED(0x0404..0x0500),
          dsa_sha384_RESERVED(0x0502),
          obsolete_RESERVED(0x0504..0x0600),
          dsa_sha512_RESERVED(0x0602),
          obsolete_RESERVED(0x0604..0x06FF),
          private_use(0xFE00..0xFFFF),
          (0xFFFF)
      } SignatureScheme;
 
      struct {
          SignatureScheme supported_signature_algorithms&lt;2..2^16-2&gt;;      } SignatureSchemeList;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.1.4.  Supported Groups Extension
 
      enum {
          unallocated_RESERVED(0x0000),
 
          /* Elliptic Curve Groups (ECDHE) */
          obsolete_RESERVED(0x0001..0x0016),
          secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),          obsolete_RESERVED(0x001A..0x001C),
          x25519(0x001D), x448(0x001E),
 
          /* Finite Field Groups (DHE) */
          ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),          ffdhe6144(0x0103), ffdhe8192(0x0104),
 
          /* Reserved Code Points */
          ffdhe_private_use(0x01FC..0x01FF),
          ecdhe_private_use(0xFE00..0xFEFF),
          obsolete_RESERVED(0xFF01..0xFF02),
          (0xFFFF)
      } NamedGroup;
 
      struct {
          NamedGroup named_group_list&lt;2..2^16-1&gt;;
      } NamedGroupList;
 
   Values within "obsolete_RESERVED" ranges are used in previous   versions of TLS and MUST NOT be offered or negotiated by TLS 1.3   implementations.  The obsolete curves have various known/theoretical   weaknesses or have had very little usage, in some cases only due to   unintentional server configuration issues.  They are no longer   considered appropriate for general use and should be assumed to be   potentially unsafe.  The set of curves specified here is sufficient   for interoperability with all currently deployed and properly   configured TLS implementations.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.2.  Server Parameters Messages
 
      opaque DistinguishedName&lt;1..2^16-1&gt;;
 
      struct {
          DistinguishedName authorities&lt;3..2^16-1&gt;;
      } CertificateAuthoritiesExtension;
 
      struct {
          opaque certificate_extension_oid&lt;1..2^8-1&gt;;
          opaque certificate_extension_values&lt;0..2^16-1&gt;;      } OIDFilter;
 
      struct {
          OIDFilter filters&lt;0..2^16-1&gt;;
      } OIDFilterExtension;
 
      struct {} PostHandshakeAuth;
 
      struct {
          Extension extensions&lt;0..2^16-1&gt;;
      } EncryptedExtensions;
 
      struct {
          opaque certificate_request_context&lt;0..2^8-1&gt;;
          Extension extensions&lt;2..2^16-1&gt;;
      } CertificateRequest;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.3.  Authentication Messages
 
      enum {
          X509(0),
          OpenPGP_RESERVED(1),
          RawPublicKey(2),
          (255)
      } CertificateType;
 
      struct {
          select (certificate_type) {
              case RawPublicKey:
                /* From RFC 7250 ASN.1_subjectPublicKeyInfo */
                opaque ASN1_subjectPublicKeyInfo&lt;1..2^24-1&gt;;
 
              case X509:
                opaque cert_data&lt;1..2^24-1&gt;;
          };
          Extension extensions&lt;0..2^16-1&gt;;
      } CertificateEntry;
 
      struct {
          opaque certificate_request_context&lt;0..2^8-1&gt;;
          CertificateEntry certificate_list&lt;0..2^24-1&gt;;
      } Certificate;
 
      struct {
          SignatureScheme algorithm;
          opaque signature&lt;0..2^16-1&gt;;
      } CertificateVerify;
 
      struct {
          opaque verify_data[Hash.length];
      } Finished;
 
B.3.4.  Ticket Establishment
 
      struct {
          uint32 ticket_lifetime;
          uint32 ticket_age_add;
          opaque ticket_nonce&lt;0..255&gt;;
          opaque ticket&lt;1..2^16-1&gt;;
          Extension extensions&lt;0..2^16-2&gt;;
      } NewSessionTicket;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.5.  Updating Keys
 
      struct {} EndOfEarlyData;
 
      enum {
          update_not_requested(0), update_requested(1), (255)      } KeyUpdateRequest;
 
      struct {
          KeyUpdateRequest request_update;
      } KeyUpdate;
 
B.4.  Cipher Suites
 
   A symmetric cipher suite defines the pair of the AEAD algorithm and   hash algorithm to be used with HKDF.  Cipher suite names follow the   naming convention:
 
      CipherSuite TLS_AEAD_HASH = VALUE;
 
      +-----------+------------------------------------------------+
      | Component | Contents                                       |
      +-----------+------------------------------------------------+
      | TLS       | The string "TLS"                               |
      |           |                                                |
      | AEAD      | The AEAD algorithm used for record protection  |
      |           |                                                |
      | HASH      | The hash algorithm used with HKDF              |
      |           |                                                |
      | VALUE     | The two-byte ID assigned for this cipher suite |
      +-----------+------------------------------------------------+
 
   This specification defines the following cipher suites for use with   TLS 1.3.
 
              +------------------------------+-------------+
              | Description                  | Value       |
              +------------------------------+-------------+
              | TLS_AES_128_GCM_SHA256       | {0x13,0x01} |
              |                              |             |
              | TLS_AES_256_GCM_SHA384       | {0x13,0x02} |
              |                              |             |
              | TLS_CHACHA20_POLY1305_SHA256 | {0x13,0x03} |
              |                              |             |
              | TLS_AES_128_CCM_SHA256       | {0x13,0x04} |
              |                              |             |
              | TLS_AES_128_CCM_8_SHA256     | {0x13,0x05} |
              +------------------------------+-------------+</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   The corresponding AEAD algorithms AEAD_AES_128_GCM, AEAD_AES_256_GCM,   and AEAD_AES_128_CCM are defined in [RFC5116].
   AEAD_CHACHA20_POLY1305 is defined in [RFC8439].  AEAD_AES_128_CCM_8   is defined in [RFC6655].  The corresponding hash algorithms are   defined in [SHS].
 
   Although TLS 1.3 uses the same cipher suite space as previous   versions of TLS, TLS 1.3 cipher suites are defined differently, only   specifying the symmetric ciphers, and cannot be used for TLS 1.2.   Similarly, cipher suites for TLS 1.2 and lower cannot be used with   TLS 1.3.
 
   New cipher suite values are assigned by IANA as described in   Section 11.
 
Appendix C.  Implementation Notes
 
   The TLS protocol cannot prevent many common security mistakes.  This   appendix provides several recommendations to assist implementors.   [TLS13-TRACES] provides test vectors for TLS 1.3 handshakes.
 
C.1.  Random Number Generation and Seeding
 
   TLS requires a cryptographically secure pseudorandom number generator   (CSPRNG).  In most cases, the operating system provides an   appropriate facility such as /dev/urandom, which should be used   absent other (e.g., performance) concerns.  It is RECOMMENDED to use   an existing CSPRNG implementation in preference to crafting a new   one.  Many adequate cryptographic libraries are already available   under favorable license terms.  Should those prove unsatisfactory,   [RFC4086] provides guidance on the generation of random values.
 
   TLS uses random values (1) in public protocol fields such as the   public Random values in the ClientHello and ServerHello and (2) to   generate keying material.  With a properly functioning CSPRNG, this   does not present a security problem, as it is not feasible to   determine the CSPRNG state from its output.  However, with a broken   CSPRNG, it may be possible for an attacker to use the public output   to determine the CSPRNG internal state and thereby predict the keying   material, as documented in [CHECKOWAY].  Implementations can provide   extra security against this form of attack by using separate CSPRNGs   to generate public and private values.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
C.2.  Certificates and Authentication
 
   Implementations are responsible for verifying the integrity of   certificates and should generally support certificate revocation   messages.  Absent a specific indication from an application profile,   certificates should always be verified to ensure proper signing by a   trusted certificate authority (CA).  The selection and addition of   trust anchors should be done very carefully.  Users should be able to   view information about the certificate and trust anchor.   Applications SHOULD also enforce minimum and maximum key sizes.  For   example, certification paths containing keys or signatures weaker   than 2048-bit RSA or 224-bit ECDSA are not appropriate for secure   applications.
 
C.3.  Implementation Pitfalls
 
   Implementation experience has shown that certain parts of earlier TLS   specifications are not easy to understand and have been a source of   interoperability and security problems.  Many of these areas have   been clarified in this document, but this appendix contains a short   list of the most important things that require special attention from   implementors.
 
   TLS protocol issues:
 
   -  Do you correctly handle handshake messages that are fragmented to      multiple TLS records (see Section 5.1)?  Do you correctly handle      corner cases like a ClientHello that is split into several small      fragments?  Do you fragment handshake messages that exceed the      maximum fragment size?  In particular, the Certificate and      CertificateRequest handshake messages can be large enough to      require fragmentation.
 
   -  Do you ignore the TLS record layer version number in all      unencrypted TLS records (see Appendix D)?
 
   -  Have you ensured that all support for SSL, RC4, EXPORT ciphers,      and MD5 (via the "signature_algorithms" extension) is completely      removed from all possible configurations that support TLS 1.3 or      later, and that attempts to use these obsolete capabilities fail      correctly (see Appendix D)?
 
   -  Do you handle TLS extensions in ClientHellos correctly, including      unknown extensions?</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   -  When the server has requested a client certificate but no suitable      certificate is available, do you correctly send an empty      Certificate message, instead of omitting the whole message (see      Section 4.4.2)?
 
   -  When processing the plaintext fragment produced by AEAD-Decrypt      and scanning from the end for the ContentType, do you avoid      scanning past the start of the cleartext in the event that the      peer has sent a malformed plaintext of all zeros?
 
   -  Do you properly ignore unrecognized cipher suites (Section 4.1.2),      hello extensions (Section 4.2), named groups (Section 4.2.7), key      shares (Section 4.2.8), supported versions (Section 4.2.1), and      signature algorithms (Section 4.2.3) in the ClientHello?
 
   -  As a server, do you send a HelloRetryRequest to clients which      support a compatible (EC)DHE group but do not predict it in the      "key_share" extension?  As a client, do you correctly handle a      HelloRetryRequest from the server?
 
   Cryptographic details:
 
   -  What countermeasures do you use to prevent timing attacks      [TIMING]?
 
   -  When using Diffie-Hellman key exchange, do you correctly preserve      leading zero bytes in the negotiated key (see Section 7.4.1)?
 
   -  Does your TLS client check that the Diffie-Hellman parameters sent      by the server are acceptable (see Section 4.2.8.1)?
 
   -  Do you use a strong and, most importantly, properly seeded random      number generator (see Appendix C.1) when generating Diffie-Hellman      private values, the ECDSA "k" parameter, and other security-      critical values?  It is RECOMMENDED that implementations implement      "deterministic ECDSA" as specified in [RFC6979].
 
   -  Do you zero-pad Diffie-Hellman public key values and shared      secrets to the group size (see Section 4.2.8.1 and Section 7.4.1)?
 
   -  Do you verify signatures after making them, to protect against      RSA-CRT key leaks [FW15]?</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
C.4.  Client Tracking Prevention
 
   Clients SHOULD NOT reuse a ticket for multiple connections.  Reuse of   a ticket allows passive observers to correlate different connections.   Servers that issue tickets SHOULD offer at least as many tickets as   the number of connections that a client might use; for example, a web   browser using HTTP/1.1 [RFC7230] might open six connections to a   server.  Servers SHOULD issue new tickets with every connection.   This ensures that clients are always able to use a new ticket when   creating a new connection.
 
C.5.  Unauthenticated Operation
 
   Previous versions of TLS offered explicitly unauthenticated cipher   suites based on anonymous Diffie-Hellman.  These modes have been   deprecated in TLS 1.3.  However, it is still possible to negotiate   parameters that do not provide verifiable server authentication by   several methods, including:
 
   -  Raw public keys [RFC7250].
 
   -  Using a public key contained in a certificate but without      validation of the certificate chain or any of its contents.
 
   Either technique used alone is vulnerable to man-in-the-middle   attacks and therefore unsafe for general use.  However, it is also   possible to bind such connections to an external authentication   mechanism via out-of-band validation of the server's public key,   trust on first use, or a mechanism such as channel bindings (though   the channel bindings described in [RFC5929] are not defined for   TLS 1.3).  If no such mechanism is used, then the connection has no   protection against active man-in-the-middle attack; applications   MUST NOT use TLS in such a way absent explicit configuration or a   specific application profile.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
Appendix D.  Backward Compatibility
 
   The TLS protocol provides a built-in mechanism for version   negotiation between endpoints potentially supporting different   versions of TLS.
 
   TLS 1.x and SSL 3.0 use compatible ClientHello messages.  Servers can   also handle clients trying to use future versions of TLS as long as   the ClientHello format remains compatible and there is at least one   protocol version supported by both the client and the server.
 
   Prior versions of TLS used the record layer version number   (TLSPlaintext.legacy_record_version and
   TLSCiphertext.legacy_record_version) for various purposes.  As of   TLS 1.3, this field is deprecated.  The value of
   TLSPlaintext.legacy_record_version MUST be ignored by all   implementations.  The value of TLSCiphertext.legacy_record_version is   included in the additional data for deprotection but MAY otherwise be   ignored or MAY be validated to match the fixed constant value.   Version negotiation is performed using only the handshake versions   (ClientHello.legacy_version and ServerHello.legacy_version, as well   as the ClientHello, HelloRetryRequest, and ServerHello   "supported_versions" extensions).  In order to maximize   interoperability with older endpoints, implementations that negotiate   the use of TLS 1.0-1.2 SHOULD set the record layer version number to   the negotiated version for the ServerHello and all records   thereafter.
 
   For maximum compatibility with previously non-standard behavior and   misconfigured deployments, all implementations SHOULD support   validation of certification paths based on the expectations in this   document, even when handling prior TLS versions' handshakes (see   Section 4.4.2.2).
 
   TLS 1.2 and prior supported an "Extended Master Secret" [RFC7627]   extension which digested large parts of the handshake transcript into   the master secret.  Because TLS 1.3 always hashes in the transcript   up to the server Finished, implementations which support both TLS 1.3   and earlier versions SHOULD indicate the use of the Extended Master   Secret extension in their APIs whenever TLS 1.3 is used.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
D.1.  Negotiating with an Older Server
 
   A TLS 1.3 client who wishes to negotiate with servers that do not   support TLS 1.3 will send a normal TLS 1.3 ClientHello containing   0x0303 (TLS 1.2) in ClientHello.legacy_version but with the correct   version(s) in the "supported_versions" extension.  If the server does   not support TLS 1.3, it will respond with a ServerHello containing an   older version number.  If the client agrees to use this version, the   negotiation will proceed as appropriate for the negotiated protocol.   A client using a ticket for resumption SHOULD initiate the connection   using the version that was previously negotiated.
 
   Note that 0-RTT data is not compatible with older servers and   SHOULD NOT be sent absent knowledge that the server supports TLS 1.3.   See Appendix D.3.
 
   If the version chosen by the server is not supported by the client   (or is not acceptable), the client MUST abort the handshake with a   "protocol_version" alert.
 
   Some legacy server implementations are known to not implement the TLS   specification properly and might abort connections upon encountering   TLS extensions or versions which they are not aware of.   Interoperability with buggy servers is a complex topic beyond the   scope of this document.  Multiple connection attempts may be required   in order to negotiate a backward-compatible connection; however, this   practice is vulnerable to downgrade attacks and is NOT RECOMMENDED.
 
D.2.  Negotiating with an Older Client
 
   A TLS server can also receive a ClientHello indicating a version   number smaller than its highest supported version.  If the   "supported_versions" extension is present, the server MUST negotiate   using that extension as described in Section 4.2.1.  If the   "supported_versions" extension is not present, the server MUST   negotiate the minimum of ClientHello.legacy_version and TLS 1.2.  For   example, if the server supports TLS 1.0, 1.1, and 1.2, and   legacy_version is TLS 1.0, the server will proceed with a TLS 1.0   ServerHello.  If the "supported_versions" extension is absent and the   server only supports versions greater than
   ClientHello.legacy_version, the server MUST abort the handshake with   a "protocol_version" alert.
 
   Note that earlier versions of TLS did not clearly specify the record   layer version number value in all cases
   (TLSPlaintext.legacy_record_version).  Servers will receive various   TLS 1.x versions in this field, but its value MUST always be ignored.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
D.3.  0-RTT Backward Compatibility
 
   0-RTT data is not compatible with older servers.  An older server   will respond to the ClientHello with an older ServerHello, but it   will not correctly skip the 0-RTT data and will fail to complete the   handshake.  This can cause issues when a client attempts to use   0-RTT, particularly against multi-server deployments.  For example, a   deployment could deploy TLS 1.3 gradually with some servers   implementing TLS 1.3 and some implementing TLS 1.2, or a TLS 1.3   deployment could be downgraded to TLS 1.2.
 
   A client that attempts to send 0-RTT data MUST fail a connection if   it receives a ServerHello with TLS 1.2 or older.  It can then retry   the connection with 0-RTT disabled.  To avoid a downgrade attack, the   client SHOULD NOT disable TLS 1.3, only 0-RTT.
 
   To avoid this error condition, multi-server deployments SHOULD ensure   a uniform and stable deployment of TLS 1.3 without 0-RTT prior to   enabling 0-RTT.
 
D.4.  Middlebox Compatibility Mode
 
   Field measurements [Ben17a] [Ben17b] [Res17a] [Res17b] have found   that a significant number of middleboxes misbehave when a TLS   client/server pair negotiates TLS 1.3.  Implementations can increase   the chance of making connections through those middleboxes by making   the TLS 1.3 handshake look more like a TLS 1.2 handshake:
 
   -  The client always provides a non-empty session ID in the      ClientHello, as described in the legacy_session_id section of      Section 4.1.2.
 
   -  If not offering early data, the client sends a dummy
      change_cipher_spec record (see the third paragraph of Section 5)      immediately before its second flight.  This may either be before      its second ClientHello or before its encrypted handshake flight.      If offering early data, the record is placed immediately after the      first ClientHello.
 
   -  The server sends a dummy change_cipher_spec record immediately      after its first handshake message.  This may either be after a      ServerHello or a HelloRetryRequest.
 
   When put together, these changes make the TLS 1.3 handshake resemble   TLS 1.2 session resumption, which improves the chance of successfully   connecting through middleboxes.  This "compatibility mode" is   partially negotiated: the client can opt to provide a session ID or   not, and the server has to echo it.  Either side can send</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   change_cipher_spec at any time during the handshake, as they must be   ignored by the peer, but if the client sends a non-empty session ID,   the server MUST send the change_cipher_spec as described in this   appendix.
 
D.5.  Security Restrictions Related to Backward Compatibility
 
   Implementations negotiating the use of older versions of TLS SHOULD   prefer forward secret and AEAD cipher suites, when available.
 
   The security of RC4 cipher suites is considered insufficient for the   reasons cited in [RFC7465].  Implementations MUST NOT offer or   negotiate RC4 cipher suites for any version of TLS for any reason.
 
   Old versions of TLS permitted the use of very low strength ciphers.   Ciphers with a strength less than 112 bits MUST NOT be offered or   negotiated for any version of TLS for any reason.
 
   The security of SSL 3.0 [RFC6101] is considered insufficient for the   reasons enumerated in [RFC7568], and it MUST NOT be negotiated for   any reason.
 
   The security of SSL 2.0 [SSL2] is considered insufficient for the   reasons enumerated in [RFC6176], and it MUST NOT be negotiated for   any reason.
 
   Implementations MUST NOT send an SSL version 2.0 compatible   CLIENT-HELLO.  Implementations MUST NOT negotiate TLS 1.3 or later   using an SSL version 2.0 compatible CLIENT-HELLO.  Implementations   are NOT RECOMMENDED to accept an SSL version 2.0 compatible   CLIENT-HELLO in order to negotiate older versions of TLS.
 
   Implementations MUST NOT send a ClientHello.legacy_version or   ServerHello.legacy_version set to 0x0300 or less.  Any endpoint   receiving a Hello message with ClientHello.legacy_version or   ServerHello.legacy_version set to 0x0300 MUST abort the handshake   with a "protocol_version" alert.
 
   Implementations MUST NOT send any records with a version less than   0x0300.  Implementations SHOULD NOT accept any records with a version   less than 0x0300 (but may inadvertently do so if the record version   number is ignored completely).
 
   Implementations MUST NOT use the Truncated HMAC extension, defined in   Section&nbsp;7 of [RFC6066], as it is not applicable to AEAD algorithms   and has been shown to be insecure in some scenarios.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
Appendix E.  Overview of Security Properties
 
   A complete security analysis of TLS is outside the scope of this   document.  In this appendix, we provide an informal description of   the desired properties as well as references to more detailed work in   the research literature which provides more formal definitions.
 
   We cover properties of the handshake separately from those of the   record layer.
 
E.1.  Handshake
 
   The TLS handshake is an Authenticated Key Exchange (AKE) protocol   which is intended to provide both one-way authenticated (server-only)   and mutually authenticated (client and server) functionality.  At the   completion of the handshake, each side outputs its view of the   following values:
 
   -  A set of "session keys" (the various secrets derived from the      master secret) from which can be derived a set of working keys.
 
   -  A set of cryptographic parameters (algorithms, etc.).
 
   -  The identities of the communicating parties.
 
   We assume the attacker to be an active network attacker, which means   it has complete control over the network used to communicate between   the parties [RFC3552].  Even under these conditions, the handshake   should provide the properties listed below.  Note that these   properties are not necessarily independent, but reflect the protocol   consumers' needs.
 
   Establishing the same session keys:  The handshake needs to output      the same set of session keys on both sides of the handshake,      provided that it completes successfully on each endpoint (see      [CK01], Definition 1, part 1).
 
   Secrecy of the session keys:  The shared session keys should be known      only to the communicating parties and not to the attacker (see      [CK01], Definition 1, part 2).  Note that in a unilaterally      authenticated connection, the attacker can establish its own      session keys with the server, but those session keys are distinct      from those established by the client.
 
   Peer authentication:  The client's view of the peer identity should      reflect the server's identity.  If the client is authenticated,      the server's view of the peer identity should match the client's      identity.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Uniqueness of the session keys:  Any two distinct handshakes should      produce distinct, unrelated session keys.  Individual session keys      produced by a handshake should also be distinct and independent.
 
   Downgrade protection:  The cryptographic parameters should be the      same on both sides and should be the same as if the peers had been      communicating in the absence of an attack (see [BBFGKZ16],      Definitions 8 and 9).
 
   Forward secret with respect to long-term keys:  If the long-term      keying material (in this case the signature keys in certificate-      based authentication modes or the external/resumption PSK in PSK      with (EC)DHE modes) is compromised after the handshake is      complete, this does not compromise the security of the session key      (see [DOW92]), as long as the session key itself has been erased.      The forward secrecy property is not satisfied when PSK is used in      the "psk_ke" PskKeyExchangeMode.
 
   Key Compromise Impersonation (KCI) resistance:  In a mutually      authenticated connection with certificates, compromising the      long-term secret of one actor should not break that actor's      authentication of their peer in the given connection (see      [HGFS15]).  For example, if a client's signature key is      compromised, it should not be possible to impersonate arbitrary      servers to that client in subsequent handshakes.
 
   Protection of endpoint identities:  The server's identity      (certificate) should be protected against passive attackers.  The      client's identity should be protected against both passive and      active attackers.
 
   Informally, the signature-based modes of TLS 1.3 provide for the   establishment of a unique, secret, shared key established by an   (EC)DHE key exchange and authenticated by the server's signature over   the handshake transcript, as well as tied to the server's identity by   a MAC.  If the client is authenticated by a certificate, it also   signs over the handshake transcript and provides a MAC tied to both   identities.  [SIGMA] describes the design and analysis of this type   of key exchange protocol.  If fresh (EC)DHE keys are used for each   connection, then the output keys are forward secret.
 
   The external PSK and resumption PSK bootstrap from a long-term shared   secret into a unique per-connection set of short-term session keys.   This secret may have been established in a previous handshake.  If   PSK with (EC)DHE key establishment is used, these session keys will   also be forward secret.  The resumption PSK has been designed so that   the resumption master secret computed by connection N and needed to   form connection N+1 is separate from the traffic keys used by</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   connection N, thus providing forward secrecy between the connections.   In addition, if multiple tickets are established on the same   connection, they are associated with different keys, so compromise of   the PSK associated with one ticket does not lead to the compromise of   connections established with PSKs associated with other tickets.   This property is most interesting if tickets are stored in a database   (and so can be deleted) rather than if they are self-encrypted.
 
   The PSK binder value forms a binding between a PSK and the current   handshake, as well as between the session where the PSK was   established and the current session.  This binding transitively   includes the original handshake transcript, because that transcript   is digested into the values which produce the resumption master   secret.  This requires that both the KDF used to produce the   resumption master secret and the MAC used to compute the binder be   collision resistant.  See Appendix E.1.1 for more on this.  Note: The   binder does not cover the binder values from other PSKs, though they   are included in the Finished MAC.
 
   TLS does not currently permit the server to send a
   certificate_request message in non-certificate-based handshakes   (e.g., PSK).  If this restriction were to be relaxed in future, the   client's signature would not cover the server's certificate directly.   However, if the PSK was established through a NewSessionTicket, the   client's signature would transitively cover the server's certificate   through the PSK binder.  [PSK-FINISHED] describes a concrete attack   on constructions that do not bind to the server's certificate (see   also [Kraw16]).  It is unsafe to use certificate-based client   authentication when the client might potentially share the same   PSK/key-id pair with two different endpoints.  Implementations   MUST NOT combine external PSKs with certificate-based authentication   of either the client or the server unless negotiated by some   extension.
 
   If an exporter is used, then it produces values which are unique and   secret (because they are generated from a unique session key).   Exporters computed with different labels and contexts are   computationally independent, so it is not feasible to compute one   from another or the session secret from the exported value.   Note: Exporters can produce arbitrary-length values; if exporters are   to be used as channel bindings, the exported value MUST be large   enough to provide collision resistance.  The exporters provided in   TLS 1.3 are derived from the same Handshake Contexts as the early   traffic keys and the application traffic keys, respectively, and thus   have similar security properties.  Note that they do not include the   client's certificate; future applications which wish to bind to the   client's certificate may need to define a new exporter that includes   the full handshake transcript.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   For all handshake modes, the Finished MAC (and, where present, the   signature) prevents downgrade attacks.  In addition, the use of   certain bytes in the random nonces as described in Section 4.1.3   allows the detection of downgrade to previous TLS versions.  See   [BBFGKZ16] for more details on TLS 1.3 and downgrade.
 
   As soon as the client and the server have exchanged enough   information to establish shared keys, the remainder of the handshake   is encrypted, thus providing protection against passive attackers,   even if the computed shared key is not authenticated.  Because the   server authenticates before the client, the client can ensure that if   it authenticates to the server, it only reveals its identity to an   authenticated server.  Note that implementations must use the   provided record-padding mechanism during the handshake to avoid   leaking information about the identities due to length.  The client's   proposed PSK identities are not encrypted, nor is the one that the   server selects.
 
E.1.1.  Key Derivation and HKDF
 
   Key derivation in TLS 1.3 uses HKDF as defined in [RFC5869] and its   two components, HKDF-Extract and HKDF-Expand.  The full rationale for   the HKDF construction can be found in [Kraw10] and the rationale for   the way it is used in TLS 1.3 in [KW16].  Throughout this document,   each application of HKDF-Extract is followed by one or more   invocations of HKDF-Expand.  This ordering should always be followed   (including in future revisions of this document); in particular, one   SHOULD NOT use an output of HKDF-Extract as an input to another   application of HKDF-Extract without an HKDF-Expand in between.   Multiple applications of HKDF-Expand to some of the same inputs are   allowed as long as these are differentiated via the key and/or the   labels.
 
   Note that HKDF-Expand implements a pseudorandom function (PRF) with   both inputs and outputs of variable length.  In some of the uses of   HKDF in this document (e.g., for generating exporters and the   resumption_master_secret), it is necessary that the application of   HKDF-Expand be collision resistant; namely, it should be infeasible   to find two different inputs to HKDF-Expand that output the same   value.  This requires the underlying hash function to be collision   resistant and the output length from HKDF-Expand to be of size at   least 256 bits (or as much as needed for the hash function to prevent   finding collisions).</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
E.1.2.  Client Authentication
 
   A client that has sent authentication data to a server, either during   the handshake or in post-handshake authentication, cannot be sure   whether the server afterwards considers the client to be   authenticated or not.  If the client needs to determine if the server   considers the connection to be unilaterally or mutually   authenticated, this has to be provisioned by the application layer.   See [CHHSV17] for details.  In addition, the analysis of   post-handshake authentication from [Kraw16] shows that the client   identified by the certificate sent in the post-handshake phase   possesses the traffic key.  This party is therefore the client that   participated in the original handshake or one to whom the original   client delegated the traffic key (assuming that the traffic key has   not been compromised).
 
E.1.3.  0-RTT
 
   The 0-RTT mode of operation generally provides security properties   similar to those of 1-RTT data, with the two exceptions that the   0-RTT encryption keys do not provide full forward secrecy and that   the server is not able to guarantee uniqueness of the handshake   (non-replayability) without keeping potentially undue amounts of   state.  See Section 8 for mechanisms to limit the exposure to replay.
 
E.1.4.  Exporter Independence
 
   The exporter_master_secret and early_exporter_master_secret are   derived to be independent of the traffic keys and therefore do not   represent a threat to the security of traffic encrypted with those   keys.  However, because these secrets can be used to compute any   exporter value, they SHOULD be erased as soon as possible.  If the   total set of exporter labels is known, then implementations SHOULD   pre-compute the inner Derive-Secret stage of the exporter computation   for all those labels, then erase the [early_]exporter_master_secret,   followed by each inner value as soon as it is known that it will not   be needed again.
 
E.1.5.  Post-Compromise Security
 
   TLS does not provide security for handshakes which take place after   the peer's long-term secret (signature key or external PSK) is   compromised.  It therefore does not provide post-compromise security   [CCG16], sometimes also referred to as backward or future secrecy.   This is in contrast to KCI resistance, which describes the security   guarantees that a party has after its own long-term secret has been   compromised.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
E.1.6.  External References
 
   The reader should refer to the following references for analysis of   the TLS handshake: [DFGS15], [CHSV16], [DFGS16], [KW16], [Kraw16],   [FGSW16], [LXZFH16], [FG17], and [BBK17].
 
E.2.  Record Layer
 
   The record layer depends on the handshake producing strong traffic   secrets which can be used to derive bidirectional encryption keys and   nonces.  Assuming that is true, and the keys are used for no more   data than indicated in Section 5.5, then the record layer should   provide the following guarantees:
 
   Confidentiality:  An attacker should not be able to determine the      plaintext contents of a given record.
 
   Integrity:  An attacker should not be able to craft a new record      which is different from an existing record which will be accepted      by the receiver.
 
   Order protection/non-replayability:  An attacker should not be able      to cause the receiver to accept a record which it has already      accepted or cause the receiver to accept record N+1 without having      first processed record N.
 
   Length concealment:  Given a record with a given external length, the      attacker should not be able to determine the amount of the record      that is content versus padding.
 
   Forward secrecy after key change:  If the traffic key update      mechanism described in Section 4.6.3 has been used and the      previous generation key is deleted, an attacker who compromises      the endpoint should not be able to decrypt traffic encrypted with      the old key.
 
   Informally, TLS 1.3 provides these properties by AEAD-protecting the   plaintext with a strong key.  AEAD encryption [RFC5116] provides   confidentiality and integrity for the data.  Non-replayability is   provided by using a separate nonce for each record, with the nonce   being derived from the record sequence number (Section 5.3), with the   sequence number being maintained independently at both sides; thus,   records which are delivered out of order result in AEAD deprotection   failures.  In order to prevent mass cryptanalysis when the same   plaintext is repeatedly encrypted by different users under the same   key (as is commonly the case for HTTP), the nonce is formed by mixing</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   the sequence number with a secret per-connection initialization   vector derived along with the traffic keys.  See [BT16] for analysis   of this construction.
 
   The rekeying technique in TLS 1.3 (see Section 7.2) follows the   construction of the serial generator as discussed in [REKEY], which   shows that rekeying can allow keys to be used for a larger number of   encryptions than without rekeying.  This relies on the security of   the HKDF-Expand-Label function as a pseudorandom function (PRF).  In   addition, as long as this function is truly one way, it is not   possible to compute traffic keys from prior to a key change (forward   secrecy).
 
   TLS does not provide security for data which is communicated on a   connection after a traffic secret of that connection is compromised.   That is, TLS does not provide post-compromise security/future   secrecy/backward secrecy with respect to the traffic secret.  Indeed,   an attacker who learns a traffic secret can compute all future   traffic secrets on that connection.  Systems which want such   guarantees need to do a fresh handshake and establish a new   connection with an (EC)DHE exchange.
 
E.2.1.  External References
 
   The reader should refer to the following references for analysis of   the TLS record layer: [BMMRT15], [BT16], [BDFKPPRSZZ16], [BBK17], and   [PS18].
 
E.3.  Traffic Analysis
 
   TLS is susceptible to a variety of traffic analysis attacks based on   observing the length and timing of encrypted packets [CLINIC]   [HCJC16].  This is particularly easy when there is a small set of   possible messages to be distinguished, such as for a video server   hosting a fixed corpus of content, but still provides usable   information even in more complicated scenarios.
 
   TLS does not provide any specific defenses against this form of   attack but does include a padding mechanism for use by applications:   The plaintext protected by the AEAD function consists of content plus   variable-length padding, which allows the application to produce   arbitrary-length encrypted records as well as padding-only cover   traffic to conceal the difference between periods of transmission and   periods of silence.  Because the padding is encrypted alongside the   actual content, an attacker cannot directly determine the length of   the padding but may be able to measure it indirectly by the use of   timing channels exposed during record processing (i.e., seeing how   long it takes to process a record or trickling in records to see</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   which ones elicit a response from the server).  In general, it is not   known how to remove all of these channels because even a   constant-time padding removal function will likely feed the content   into data-dependent functions.  At minimum, a fully constant-time   server or client would require close cooperation with the   application-layer protocol implementation, including making that   higher-level protocol constant time.
 
   Note: Robust traffic analysis defenses will likely lead to inferior   performance due to delays in transmitting packets and increased   traffic volume.
 
E.4.  Side-Channel Attacks
 
   In general, TLS does not have specific defenses against side-channel   attacks (i.e., those which attack the communications via secondary   channels such as timing), leaving those to the implementation of the   relevant cryptographic primitives.  However, certain features of TLS   are designed to make it easier to write side-channel resistant code:
 
   -  Unlike previous versions of TLS which used a composite MAC-then-      encrypt structure, TLS 1.3 only uses AEAD algorithms, allowing      implementations to use self-contained constant-time      implementations of those primitives.
 
   -  TLS uses a uniform "bad_record_mac" alert for all decryption      errors, which is intended to prevent an attacker from gaining      piecewise insight into portions of the message.  Additional      resistance is provided by terminating the connection on such      errors; a new connection will have different cryptographic      material, preventing attacks against the cryptographic primitives      that require multiple trials.
 
   Information leakage through side channels can occur at layers above   TLS, in application protocols and the applications that use them.   Resistance to side-channel attacks depends on applications and   application protocols separately ensuring that confidential   information is not inadvertently leaked.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
E.5.  Replay Attacks on 0-RTT
 
   Replayable 0-RTT data presents a number of security threats to TLS-   using applications, unless those applications are specifically   engineered to be safe under replay (minimally, this means idempotent,   but in many cases may also require other stronger conditions, such as   constant-time response).  Potential attacks include:
 
   -  Duplication of actions which cause side effects (e.g., purchasing      an item or transferring money) to be duplicated, thus harming the      site or the user.
 
   -  Attackers can store and replay 0-RTT messages in order to reorder      them with respect to other messages (e.g., moving a delete to      after a create).
 
   -  Exploiting cache timing behavior to discover the content of 0-RTT      messages by replaying a 0-RTT message to a different cache node      and then using a separate connection to measure request latency,      to see if the two requests address the same resource.
 
   If data can be replayed a large number of times, additional attacks   become possible, such as making repeated measurements of the speed of   cryptographic operations.  In addition, they may be able to overload   rate-limiting systems.  For a further description of these attacks,   see [Mac17].
 
   Ultimately, servers have the responsibility to protect themselves   against attacks employing 0-RTT data replication.  The mechanisms   described in Section 8 are intended to prevent replay at the TLS   layer but do not provide complete protection against receiving   multiple copies of client data.  TLS 1.3 falls back to the 1-RTT   handshake when the server does not have any information about the   client, e.g., because it is in a different cluster which does not   share state or because the ticket has been deleted as described in   Section 8.1.  If the application-layer protocol retransmits data in   this setting, then it is possible for an attacker to induce message   duplication by sending the ClientHello to both the original cluster   (which processes the data immediately) and another cluster which will   fall back to 1-RTT and process the data upon application-layer   replay.  The scale of this attack is limited by the client's   willingness to retry transactions and therefore only allows a limited   amount of duplication, with each copy appearing as a new connection   at the server.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   If implemented correctly, the mechanisms described in Sections 8.1   and 8.2 prevent a replayed ClientHello and its associated 0-RTT data   from being accepted multiple times by any cluster with consistent   state; for servers which limit the use of 0-RTT to one cluster for a   single ticket, then a given ClientHello and its associated 0-RTT data   will only be accepted once.  However, if state is not completely   consistent, then an attacker might be able to have multiple copies of   the data be accepted during the replication window.  Because clients   do not know the exact details of server behavior, they MUST NOT send   messages in early data which are not safe to have replayed and which   they would not be willing to retry across multiple 1-RTT connections.
 
   Application protocols MUST NOT use 0-RTT data without a profile that   defines its use.  That profile needs to identify which messages or   interactions are safe to use with 0-RTT and how to handle the   situation when the server rejects 0-RTT and falls back to 1-RTT.
 
   In addition, to avoid accidental misuse, TLS implementations MUST NOT   enable 0-RTT (either sending or accepting) unless specifically   requested by the application and MUST NOT automatically resend 0-RTT   data if it is rejected by the server unless instructed by the   application.  Server-side applications may wish to implement special   processing for 0-RTT data for some kinds of application traffic   (e.g., abort the connection, request that data be resent at the   application layer, or delay processing until the handshake   completes).  In order to allow applications to implement this kind of   processing, TLS implementations MUST provide a way for the   application to determine if the handshake has completed.
 
E.5.1.  Replay and Exporters
 
   Replays of the ClientHello produce the same early exporter, thus   requiring additional care by applications which use these exporters.   In particular, if these exporters are used as an authentication   channel binding (e.g., by signing the output of the exporter), an   attacker who compromises the PSK can transplant authenticators   between connections without compromising the authentication key.
 
   In addition, the early exporter SHOULD NOT be used to generate   server-to-client encryption keys because that would entail the reuse   of those keys.  This parallels the use of the early application   traffic keys only in the client-to-server direction.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
E.6.  PSK Identity Exposure
 
   Because implementations respond to an invalid PSK binder by aborting   the handshake, it may be possible for an attacker to verify whether a   given PSK identity is valid.  Specifically, if a server accepts both   external-PSK handshakes and certificate-based handshakes, a valid PSK   identity will result in a failed handshake, whereas an invalid   identity will just be skipped and result in a successful certificate   handshake.  Servers which solely support PSK handshakes may be able   to resist this form of attack by treating the cases where there is no   valid PSK identity and where there is an identity but it has an   invalid binder identically.
 
E.7.  Sharing PSKs
 
   TLS 1.3 takes a conservative approach to PSKs by binding them to a   specific KDF.  By contrast, TLS 1.2 allows PSKs to be used with any   hash function and the TLS 1.2 PRF.  Thus, any PSK which is used with   both TLS 1.2 and TLS 1.3 must be used with only one hash in TLS 1.3,   which is less than optimal if users want to provision a single PSK.   The constructions in TLS 1.2 and TLS 1.3 are different, although they   are both based on HMAC.  While there is no known way in which the   same PSK might produce related output in both versions, only limited   analysis has been done.  Implementations can ensure safety from   cross-protocol related output by not reusing PSKs between TLS 1.3 and   TLS 1.2.
 
E.8.  Attacks on Static RSA
 
   Although TLS 1.3 does not use RSA key transport and so is not   directly susceptible to Bleichenbacher-type attacks [Blei98], if TLS   1.3 servers also support static RSA in the context of previous   versions of TLS, then it may be possible to impersonate the server   for TLS 1.3 connections [JSS15].  TLS 1.3 implementations can prevent   this attack by disabling support for static RSA across all versions   of TLS.  In principle, implementations might also be able to separate   certificates with different keyUsage bits for static RSA decryption   and RSA signature, but this technique relies on clients refusing to   accept signatures using keys in certificates that do not have the   digitalSignature bit set, and many clients do not enforce this   restriction.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
Contributors
 
   Martin Abadi
   University of California, Santa Cruz
   abadi@cs.ucsc.edu
 
   Christopher Allen
   (co-editor of TLS 1.0)
   Alacrity Ventures
   ChristopherA@AlacrityManagement.com
 
   Richard Barnes
   Cisco
   rlb@ipv.sx
 
   Steven M. Bellovin
   Columbia University
   smb@cs.columbia.edu
 
   David Benjamin
   Google
   davidben@google.com
 
   Benjamin Beurdouche
   INRIA &amp; Microsoft Research
   benjamin.beurdouche@ens.fr
 
   Karthikeyan Bhargavan
   (editor of [RFC7627])
   INRIA
   karthikeyan.bhargavan@inria.fr
 
   Simon Blake-Wilson
   (co-author of [RFC4492])
   BCI
   sblakewilson@bcisse.com
 
   Nelson Bolyard
   (co-author of [RFC4492])
   Sun Microsystems, Inc.
   nelson@bolyard.com
 
   Ran Canetti
   IBM
   canetti@watson.ibm.com</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Matt Caswell
   OpenSSL
   matt@openssl.org
 
   Stephen Checkoway
   University of Illinois at Chicago
   sfc@uic.edu
 
   Pete Chown
   Skygate Technology Ltd
   pc@skygate.co.uk
 
   Katriel Cohn-Gordon
   University of Oxford
   me@katriel.co.uk
 
   Cas Cremers
   University of Oxford
   cas.cremers@cs.ox.ac.uk
 
   Antoine Delignat-Lavaud
   (co-author of [RFC7627])
   INRIA
   antdl@microsoft.com
 
   Tim Dierks
   (co-author of TLS 1.0, co-editor of TLS 1.1 and 1.2)
   Independent
   tim@dierks.org
 
   Roelof DuToit
   Symantec Corporation
   roelof_dutoit@symantec.com
 
   Taher Elgamal
   Securify
   taher@securify.com
 
   Pasi Eronen
   Nokia
   pasi.eronen@nokia.com
 
   Cedric Fournet
   Microsoft
   fournet@microsoft.com</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Anil Gangolli
   anil@busybuddha.org
 
   David M. Garrett
   dave@nulldereference.com
 
   Illya Gerasymchuk
   Independent
   illya@iluxonchik.me
 
   Alessandro Ghedini
   Cloudflare Inc.
   alessandro@cloudflare.com
 
   Daniel Kahn Gillmor
   ACLU
   dkg@fifthhorseman.net
 
   Matthew Green
   Johns Hopkins University
   mgreen@cs.jhu.edu
 
   Jens Guballa
   ETAS
   jens.guballa@etas.com
 
   Felix Guenther
   TU Darmstadt
   mail@felixguenther.info
 
   Vipul Gupta
   (co-author of [RFC4492])
   Sun Microsystems Laboratories
   vipul.gupta@sun.com
 
   Chris Hawk
   (co-author of [RFC4492])
   Corriente Networks LLC
   chris@corriente.net
 
   Kipp Hickman
 
   Alfred Hoenes
 
   David Hopwood
   Independent Consultant
   david.hopwood@blueyonder.co.uk</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Marko Horvat
   MPI-SWS
   mhorvat@mpi-sws.org
 
   Jonathan Hoyland
   Royal Holloway, University of London
   jonathan.hoyland@gmail.com
 
   Subodh Iyengar
   Facebook
   subodh@fb.com
 
   Benjamin Kaduk
   Akamai Technologies
   kaduk@mit.edu
 
   Hubert Kario
   Red Hat Inc.
   hkario@redhat.com
 
   Phil Karlton
   (co-author of SSL 3.0)
 
   Leon Klingele
   Independent
   mail@leonklingele.de
 
   Paul Kocher
   (co-author of SSL 3.0)
   Cryptography Research
   paul@cryptography.com
 
   Hugo Krawczyk
   IBM
   hugokraw@us.ibm.com
 
   Adam Langley
   (co-author of [RFC7627])
   Google
   agl@google.com
 
   Olivier Levillain
   ANSSI
   olivier.levillain@ssi.gouv.fr</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Xiaoyin Liu
   University of North Carolina at Chapel Hill
   xiaoyin.l@outlook.com
 
   Ilari Liusvaara
   Independent
   ilariliusvaara@welho.com
 
   Atul Luykx
   K.U. Leuven
   atul.luykx@kuleuven.be
 
   Colm MacCarthaigh
   Amazon Web Services
   colm@allcosts.net
 
   Carl Mehner
   USAA
   carl.mehner@usaa.com
 
   Jan Mikkelsen
   Transactionware
   janm@transactionware.com
 
   Bodo Moeller
   (co-author of [RFC4492])
   Google
   bodo@acm.org
 
   Kyle Nekritz
   Facebook
   knekritz@fb.com
 
   Erik Nygren
   Akamai Technologies
   erik+ietf@nygren.org
 
   Magnus Nystrom
   Microsoft
   mnystrom@microsoft.com
 
   Kazuho Oku
   DeNA Co., Ltd.
   kazuhooku@gmail.com</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Kenny Paterson
   Royal Holloway, University of London
   kenny.paterson@rhul.ac.uk
 
   Christopher Patton
   University of Florida
   cjpatton@ufl.edu
 
   Alfredo Pironti
   (co-author of [RFC7627])
   INRIA
   alfredo.pironti@inria.fr
 
   Andrei Popov
   Microsoft
   andrei.popov@microsoft.com
 
   Marsh Ray
   (co-author of [RFC7627])
   Microsoft
   maray@microsoft.com
 
   Robert Relyea
   Netscape Communications
   relyea@netscape.com
 
   Kyle Rose
   Akamai Technologies
   krose@krose.org
 
   Jim Roskind
   Amazon
   jroskind@amazon.com
 
   Michael Sabin
 
   Joe Salowey
   Tableau Software
   joe@salowey.net
 
   Rich Salz
   Akamai
   rsalz@akamai.com
 
   David Schinazi
   Apple Inc.
   dschinazi@apple.com</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Sam Scott
   Royal Holloway, University of London
   me@samjs.co.uk
 
   Thomas Shrimpton
   University of Florida
   teshrim@ufl.edu
 
   Dan Simon
   Microsoft, Inc.
   dansimon@microsoft.com
 
   Brian Smith
   Independent
   brian@briansmith.org
 
   Brian Sniffen
   Akamai Technologies
   ietf@bts.evenmere.org
 
   Nick Sullivan
   Cloudflare Inc.
   nick@cloudflare.com
 
   Bjoern Tackmann
   University of California, San Diego
   btackmann@eng.ucsd.edu
 
   Tim Taubert
   Mozilla
   ttaubert@mozilla.com
 
   Martin Thomson
   Mozilla
   mt@mozilla.com
 
   Hannes Tschofenig
   Arm Limited
   Hannes.Tschofenig@arm.com
 
   Sean Turner
   sn3rd
   sean@sn3rd.com
 
   Steven Valdez
   Google
   svaldez@google.com</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Filippo Valsorda
   Cloudflare Inc.
   filippo@cloudflare.com
 
   Thyla van der Merwe
   Royal Holloway, University of London
   tjvdmerwe@gmail.com
 
   Victor Vasiliev
   Google
   vasilvv@google.com
 
   Hoeteck Wee
   Ecole Normale Superieure, Paris
   hoeteck@alum.mit.edu
 
   Tom Weinstein
 
   David Wong
   NCC Group
   david.wong@nccgroup.trust
 
   Christopher A. Wood
   Apple Inc.
   cawood@apple.com
 
   Tim Wright
   Vodafone
   timothy.wright@vodafone.com
 
   Peter Wu
   Independent
   peter@lekensteyn.nl
 
   Kazu Yamamoto
   Internet Initiative Japan Inc.
   kazu@iij.ad.jp
 
Author's Address
 
   Eric Rescorla
   Mozilla
 
   Email: ekr@rtfm.com
 

 

 

 
</pre><br>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.129c, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>
