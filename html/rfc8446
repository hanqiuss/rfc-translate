<div class="content" style="float: left; margin: 0px 30%; width: 579px; font-size: 10pt;">
   <div style="height: 13px;">
      <div onmouseover="this.style.cursor='pointer';" onclick="showElem('legend');" onmouseout="hideElem('legend')" style="height: 6px; position: absolute; cursor: pointer;" class="pre noprint docinfo bgblue" title="Click for colour legend.">                                                                        </div>
      <div id="legend" class="docinfo noprint pre legend" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; " onmouseover="showElem('legend');" onmouseout="hideElem('legend');">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="../html/" title="Document search and retrieval page">Docs</a>] [<a href="/rfc/rfc8446.txt" title="Plaintext version of this document">txt</a>|<a href="/pdf/rfc8446" title="PDF version of this document">pdf</a>] [<a href="./draft-ietf-tls-tls13" title="draft-ietf-tls-tls13">draft-ietf-tls-...</a>] [<a href="https://datatracker.ietf.org/doc/rfc8446" title="IESG Datatracker information for this document">Tracker</a>] [<a href="/rfcdiff?difftype=--hwdiff&amp;url2=rfc8446" title="Inline diff (wdiff)">Diff1</a>] [<a href="/rfcdiff?url2=rfc8446" title="Side-by-side diff">Diff2</a>] [<a href="https://datatracker.ietf.org/ipr/search/?rfc=8446&amp;submit=rfc" title="IPR disclosures related to this document">IPR</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=8446">Errata</a>]</span><br>
<span class="pre noprint docinfo">                                                                        </span><br>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br>
<pre style="height: 780px; white-space: pre-wrap;">Internet Engineering Task Force (IETF)                       E. Rescorla
Request for Comments: 8446                                       Mozilla
Obsoletes: 5077, 5246, 6961                                  August 2018
Updates: 5705, 6066
类别: 标准跟踪
ISSN: 2070-1721
 

        The Transport Layer Security (TLS) Protocol Version 1.3
 
摘要
 
   本文档规定了传输层安全(TLS)协议的1.3版。TLS允许客户端/服务器应用程序通过
   Internet以一种旨在防止窃听、篡改和消息伪造的方式进行通信。
 
   本文档更新了RFC 5705和6066，并废弃了RFC 5077、5246和6961。本文档还指定了
   TLS 1.2实现的新要求。
 
备忘录状态
 
   这是Internet标准跟踪文档。
 
   本文档是Internet工程任务组(IETF)的产品。它代表了IETF社区的共识。它已经接受了
   公众的审查，并已被互联网工程指导小组(IESG)批准出版。有关Internet标准的更多信息，
   请参阅 RFC 7841 的第2节。
 
   有关本文档的当前状态、任何勘误表以及如何提供反馈的信息，请访问。
   https://www.rfc-editor.org/info/rfc8446.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
Copyright Notice

   Copyright (c) 2018 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (https://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
目录
 <p style="font-family: 新宋体;">
   1. 简介         ....................................................6
      1.1. 公约和术语                  ................................7
      1.2. 与 TLS 1.2 的主要区别          .............................8
      1.3. 影响 TLS 1.2 的更新       ..................................9
   2. 协议概述          ..............................................10
      2.1. 不正确的 DHE 共享   .......................................14
      2.2. 恢复和预共享密钥(PSK)               .......................15
      2.3. 0-RTT数据  ................................................17
   3. 演示语言              ..........................................19
      3.1. 基本块大小       ..........................................19
      3.2. 杂项          .............................................20
      3.3. 数字    ...................................................20
      3.4. 向量    ...................................................20
      3.5. 枚举        ...............................................21
      3.6. 构造类型          .........................................22
      3.7. 常量      .................................................23
      3.8. 变体     ..................................................23
   4. 握手协议           .............................................24
      4.1. 密钥交换消息          .....................................25
           4.1.1. 加密协商                  ..........................26
           4.1.2. Client Hello .......................................27
           4.1.3. Server Hello .......................................31
           4.1.4. Hello重试请求       ................................33
      4.2. 扩展       ................................................35
           4.2.1. 支持的版本         .................................39
           4.2.2. Cookie .............................................40
           4.2.3. 签名算法             ...............................41
           4.2.4. 证书颁发机构            ............................45
           4.2.5. OID过滤器   ........................................45
           4.2.6. 握手后客户端身份验证                 ...............47
           4.2.7. 支持的组         ...................................47
           4.2.8. 密钥共享  ..........................................48
           4.2.9. 预共享密钥交换模式            ......................51
           4.2.10. 早期数据指示          .............................52
           4.2.11. 预共享密钥扩展           ..........................55
      4.3. 服务器参数        .........................................59
           4.3.1. 加密扩展             ...............................60
           4.3.2. 证书请求            ................................60
      4.4. 身份验证消息            ...................................61
           4.4.1. The Transcript Hash ................................63
           4.4.2. Certificate ........................................64
           4.4.3. Certificate Verify .................................69
           4.4.4. Finished ...........................................71
      4.5. 早期数据结束      .........................................72
</p></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

  <p style="font-family: 新宋体;">
      4.6. 握手后消息              ...................................73
           4.6.1. 新会话票证消息             .........................73
           4.6.2. 握手后身份验证                ......................75
           4.6.3. 密钥和初始化矢量更新                 ...............76
   5. 记录协议        ................................................77
      5.1. 记录层       ..............................................78
      5.2. 记录有效负载保护          .................................80
      5.3. Per-Record随机数 ..........................................82
      5.4. Record 填充    ............................................83
      5.5. 密钥使用限制        .......................................84
   6. 警报协议       .................................................85
      6.1. 关闭警报       ............................................87
      6.2. 错误警报     ..............................................88
   7. 密码计算                   .....................................90
      7.1. 密钥明细表   ..............................................91
      7.2. 更新流通密码             ..................................94
      7.3. 流通密码计算            ...................................95
      7.4. (EC)DHE共享密钥计算               .........................95
           7.4.1. 有限域Diffie-Hellman        ........................95
           7.4.2. 椭圆曲线Diffie-Hellman        ......................96
      7.5. 导出器    .................................................97
   8. 0-RTT 和防重放        ..........................................98
      8.1. 单次票据           ........................................99
      8.2. Client Hello Recording ....................................99
      8.3. Freshness Checks .........................................101
   9. 合规要求                .......................................102
      9.1. 强制实施密码套件                     .....................102
      9.2. 强制实施扩展                      ........................103
      9.3. 协议不变量          ......................................104
   10. 安全注意事项            ......................................106
   11. IANA 注意事项       ..........................................106
   12. 参考       ...................................................109
      12.1. 标准参考             ....................................109
      12.2. 信息参考               ..................................112
   附录 A. 状态机            ........................................120
     A.1. Client ....................................................120
     A.2. Server ....................................................121
   附录B. 协议数据结构和常量值                              .........122
     B.1. Record Layer ..............................................122
     B.2. Alert Messages ............................................123
     B.3. Handshake Protocol ........................................124
       B.3.1. Key Exchange Messages .................................125
       B.3.2. Server Parameters Messages ............................131
       B.3.3. Authentication Messages ...............................132
       B.3.4. Ticket Establishment ..................................132
       B.3.5. Updating Keys .........................................133
     B.4. Cipher Suites .............................................133
</p></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

  <p style="font-family: 新宋体;">
   附录C. 实施说明                  .................................134
     C.1. 随机数生成和种子                     ......................134
     C.2. 证书和身份验证                  ...........................135
     C.3. 实施陷阱                ...................................135
     C.4. 客户跟踪预防               ................................137
     C.5. 未经认证的操作            .................................137
   附录D. 向后兼容性                  ...............................138
     D.1. 与旧服务器协商                   ..........................139
     D.2. 与旧客户端协商                   ..........................139
     D.3. 0-RTT 向后兼容性             ..............................140
     D.4. 中间盒兼容模式               ..............................140
     D.5. 与向后兼容性相关的安全限制                    .............141
   附录E. 安全属性概述                         ......................142
     E.1. 握手      .................................................142
       E.1.1. 密钥推导和HKDF          ...............................145
       E.1.2. 客户端身份验证        .................................146
       E.1.3. 0-RTT .................................................146
       E.1.4. Exporter Independence .................................146
       E.1.5. 妥协后的安全             ..............................146
       E.1.6. 外部参考            ...................................147
     E.2. 记录层       ..............................................147
       E.2.1. 外部参考            ...................................148
     E.3. 流量分析         ..........................................148
     E.4. 旁路攻击             ......................................149
     E.5. 0-RTT上的重播攻击       ...................................150
       E.5.1. 回放和导出器         ..................................151
     E.6. PSK身份暴露           .....................................152
     E.7. 共享PSK      ..............................................152
     E.8. 对静态 RSA 的攻击     .....................................152
   贡献者       .....................................................153
   Author's Address .................................................160
</p></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
1.  简介
 
   TLS的主要目标是在两个通信对等体之间提供安全通道；底层传输的唯一要求是可靠、有序的
   数据流。具体地说，安全通道应提供以下属性：
 
   -  身份验证: 通道的服务器端始终经过身份验证;客户端是可选的身份验证。身份验证可以
      通过非对称加密（例如，RSA [RSA]、椭圆曲线数字签名算法 （ECDSA） [ECDSA] 或
      Edwards-Curve曲线数字签名算法 （EdSA） [RFC8032]） 或对称预共享密钥
     （PSK） 进行。
 
   -  机密性: 建立后通过通道发送的数据只对端点可见。TLS不会隐藏它传输的数据的长度，
      尽管端点可以填充TLS记录，以掩盖长度并改进针对流量分析技术的保护。
 
   -  完整性: 在建立后通过通道发送的数据，攻击者对其进行修改会被发现。
 
   即使面对完全控制网络的攻击者，这些属性也应该是正确的，如[RFC3552]中所述。有关安全
   属性的更完整声明，请参见附录E。
 
   TLS由两个主要组件组成：
 
   -  握手协议(第4节)，用于验证通信方，协商加密模式和参数，并建立共享密钥材料。握手
      协议旨在抵抗篡改；主动攻击者不应能够强制对等协商与未受到攻击时协商的连接参数
     不同的参数。
 
   -  记录协议(第5节)，使用握手协议建立的参数来保护通信对等体之间的流量。记录协议
      将流量划分为一系列记录，每个记录使用流量密钥独立保护。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   TLS是独立于应用协议的；更高级别的协议可以透明地叠加在TLS之上。然而，TLS标准没有
   指定协议如何使用TLS增加安全性；如何启动TLS握手以及如何解释交换的认证证书，留给
   运行在TLS之上的协议的设计者和实现者来判断。
 
   本文档定义了 TLS 1.3 版。虽然 TLS 1.3 不直接与以前的版本兼容，但TLS的所有版本
   都包含了一个版本控制机制，该机制允许客户端和服务器互操作地协商一个共同的版本(如果
   两个对等体都支持一个版本)。
 
   本文档取代并废弃了TLS的以前版本，包括版本 1.2[RFC5246]。它还废弃了[RFC5077]中
   定义的TLS票证机制，并用2.2节中定义的机制取代了它。由于 TLS 1.3 更改了派生密钥的
   方式，因此它会更新[RFC5705]，如7.5节所述。它还改变了在线证书状态协议(OCSP)消息
   的携带方式，因此更新[RFC6066]并废弃[RFC6961]，如第4.4.2.1节所述。
 
1.1.  约定和术语
 
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and   "OPTIONAL" in this document are to be interpreted as described in   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all   capitals, as shown here.
 
   使用以下术语：
 
   客户端：发起TLS连接的端点。
 
   连接：两个端点之间的传输层连接。
 
   端点：连接的客户端或服务器。
 
   握手：客户端和服务器之间的初始协商，用于在TLS内建立其后续交互的参数。
 
   Peer：端点。当讨论特定端点时，“对等”指的是非主要讨论主题的端点。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   接收方：接收记录的端点。
 
   发送方：正在传输记录的端点。
 
   服务器：非启动TLS连接的端点。
 
1.2.  与TLS 1.2的主要区别
 
   以下是 TLS 1.2 和 TLS 1.3 之间主要功能差异的列表。 它不是详尽无遗的，还有许多
   细微的差别。
 
   -  已删除支持的对称加密算法列表中所有被视为遗留的算法。剩下的都是带关联数据的认证
      加密(AEAD)算法。密码套件的概念已经改变，以将认证和密钥交换机制与记录保护算法
     (包括秘密密钥长度)和散列分开，以便与密钥导出函数和握手消息认证码(MAC)一起使用。
 
   -  添加了零往返时间(0-RTT)模式，节省了某些应用数据的连接建立时的往返行程，但代价
      是某些安全属性。
 
   -  静态RSA和Diffie-Hellman密码套件已被删除；所有基于公钥的密钥交换机制现在都
      提供向前保密。
 
   -  ServerHello之后的所有握手消息现在都已加密。新引入的加密扩展消息允许以前在
      ServerHello中明文发送的各种扩展也享有机密性保护。
 
   -  重新设计了密钥派生函数。由于其改进的密钥分离特性，新的设计允许密码学家更容易
      进行分析。基于HMAC的提取和扩展密钥导出函数(HKDF)用作底层原语。
 
   -  握手状态机进行了显著的重构，使其更加一致，并去除了ChangeCipherSpec等多余的
      消息(中间盒兼容性需要时除外)。
 
   -  椭圆曲线算法现在基础规范中，并且包括了新的签名算法，例如EdDSA。TLS 1.3 删除
      了点格式协商，支持每条曲线的单点格式。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   -  进行了其他加密改进，包括更改RSA填充以使用RSA概率签名方案(RSASSA-PSS)，以及
      删除压缩、数字签名算法(DSA)和自定义临时Diffie-Hellman(DHE)组。
 
   -  TLS 1.2版本协商机制已被弃用，取而代之的是扩展中的版本列表。这增加了与不正确
      实现版本协商的现有服务器的兼容性。
 
   -  具有服务器端状态和无服务器端状态的会话恢复以及早期 TLS 版本的基于 PSK 的密码
      套件已被单个新的 PSK 交换所取代。
 
   -  参考资料已适当更新，指向RFC的更新版本(例如，RFC 5280而不是RFC 3280)。
 
1.3.  影响TLS 1.2的更新
 
   本文档定义了几个有选择地影响TLS 1.2实现的更改，包括那些也不支持TLS 1.3的更改：
 
   -  版本降级保护机制在第 4.1.3 节中介绍。
 
   -  RSASSA-PSS 签名方案在第 4.2.3 节中定义。
 
   -  “Supported_Versions”ClientHello扩展可用于协商要使用的TLS版本，优先于
      ClientHello的Legacy_Version字段。
 
   -  “Signature_Algorithms_cert”扩展允许客户端指明它可以在X.509证书中验证
      哪些签名算法。
 
   此外，本文档还澄清了TLS早期版本的一些合规性要求；参见第9.3节。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
2.  协议概述
 
   安全通道使用的加密参数由 TLS 握手协议生成。 此 TLS 子协议由客户端和服务器在首次
   相互通信时使用。 握手协议允许对等方协商协议版本、选择加密算法、选择相互验证以及
   建立共享密钥材料。 握手完成后，对等方将使用已建立的密钥来保护应用程序层流量。
 
   握手失败或其他协议错误会触发连接终止，可选择在此之前发送警告消息(第6节)。
 
   TLS支持三种基本的密钥交换模式：
 
   -  (EC)DHE(有限域或椭圆曲线上的Diffie-Hellman)。
 
   -  PSK-only
 
   -  PSK with (EC)DHE</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Figure 1 below shows the basic full TLS handshake:

       Client                                           Server

Key  ^ ClientHello
Exch | + key_share*
     | + signature_algorithms*
     | + psk_key_exchange_modes*
     v + pre_shared_key*       --------&gt;
                                                  ServerHello  ^ Key
                                                 + key_share*  | Exch
                                            + pre_shared_key*  v
                                        {EncryptedExtensions}  ^  Server
                                        {CertificateRequest*}  v  Params
                                               {Certificate*}  ^
                                         {CertificateVerify*}  | Auth
                                                   {Finished}  v
                               &lt;--------  [Application Data*]
     ^ {Certificate*}
Auth | {CertificateVerify*}
     v {Finished}              --------&gt;
       [Application Data]      &lt;-------&gt;  [Application Data]
 
              +  表示在前面的消息中发送的值得注意的扩展。
 
              *  表示并非总是发送的可选或依赖于情况的消息/扩展。
 
              {} 握手阶段加密消息
 
              [] 握手完成后的加密消息
 
                  图 1：完整的 TLS 握手消息流
 
   握手可视为具有三个阶段（如上图所示）：
 
   -  密钥交换：建立共享密钥材料并选择加密参数。 此阶段后的所有内容都已加密。
 
   -  服务器参数：建立其他握手参数（客户端是否经过身份验证、应用程序层协议支持等）。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   -  身份验证：对服务器（以及（可选）的客户端进行身份验证，并提供密钥确认和握手
      完整性。
 
   在密钥交换阶段，客户端发送ClientHello(第4.1.2节)消息，其中包含随机
   nonce(ClientHello.random)；其提供的协议版本；对称密码/HKDF散列对的列表；一组
   Diffie-Hellman密钥共享(在“KEY_SHARE”(第4.2.8节)扩展中)；一组预共享密钥标签
   (在“PRE_SHARED_KEY”(第4.2.11节)扩展中)，或两者；以及潜在的附加扩展。也可以
   存在额外的字段和/或消息以实现中间盒兼容性。
 
   服务器处理ClientHello并为连接确定适当的加密参数。然后，它用自己的ServerHello
   (第4.1.3节)进行响应，指示协商的连接参数。ClientHello和ServerHello的组合确定
   共享密钥。如果正在使用(EC)DHE密钥建立，则ServerHello包含带有服务器短暂
   Diffie-Hellman共享的“key_share”扩展；服务器共享必须与客户端共享之一在同一组
   中。如果正在使用PSK密钥建立，则ServerHello包含“pre_shared_key”扩展，指示
   选择了客户端提供的PSK中的哪一个。请注意，实现可以同时使用(EC)DHE和PSK，在这种
   情况下，将同时提供这两个扩展。
 
   然后，服务器发送两条消息以建立服务器参数：
 
   EncryptedExtensions：对ClientHello扩展的响应，这些扩展不是确定加密参数所必需
      的，特定于单个证书的参数除外。[第4.3.1条]。
 
   CertificateRequest：如果需要基于证书的客户端身份验证，则需要该证书的所需参数。
      如果不需要客户端身份验证，则省略此消息。[第4.3.2条]</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   最后，客户端和服务器交换身份验证消息。每次需要基于证书的身份验证时，TLS都使用
   相同的消息集。(基于PSK的身份验证是密钥交换的副作用。)。具体而言：
 
   Certificate：端点的证书和任何每个证书扩展。如果服务器未使用证书进行身份验证，
      则此消息将被服务器省略；如果服务器未发送CertificateRequest，则客户端将省略
      此消息(从而表明客户端不应使用证书进行身份验证)。请注意，如果原始公钥[RFC7250]
      或缓存信息扩展[RFC7924]正在使用中，则此消息将不包含证书，而是包含与服务器的
      长期密钥相对应的其他值。[第4.4.2条]。
 
   CertificateVerify:  在整个握手过程中使用与证书消息中的公钥对应的私钥进行签名。
      如果端点不是通过证书进行身份验证，则忽略此消息。[第4.4.3条]。
 
   Finished:  整个握手过程中的MAC(消息验证码)。此消息提供密钥确认，将端点的身份
      绑定到交换的密钥，并且在PSK模式下还会验证握手。[第4.4.4条]。
 
   在接收到服务器的消息后，客户端用其身份验证消息(Certificate和CertificateVerify
   (如果请求)进行响应，并 Finished 。
 
   此时，握手完成，客户端和服务器导出记录层所需的密钥材料，以交换通过身份验证加密保护
   的应用层数据。除第2.3节规定外，在发送 Finished 消息之前不得发送应用程序数据。请
   注意，虽然服务器可能在接收客户端的身份验证消息之前发送应用程序数据，但此时发送的
   任何数据当然是发送给未经过身份验证的对等体。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
2.1.  不正确的 DHE 共享
 
   如果客户端没有提供足够的“key_share”扩展(例如，它只包括服务器不能接受或不支持的
   DHE 或 ECDHE 组)，则服务器用 HelloRetryRequest 纠正不匹配，并且客户端需要用
   适当的 “key_share” 扩展重新启动握手，如图2所示。如果无法协商公共密码参数，则
   服务器必须中止握手并发出适当的警报。
 
        Client                                               Server

        ClientHello
        + key_share             --------&gt;
                                                  HelloRetryRequest
                                &lt;--------               + key_share
        ClientHello
        + key_share             --------&gt;
                                                        ServerHello
                                                        + key_share
                                              {EncryptedExtensions}
                                              {CertificateRequest*}
                                                     {Certificate*}
                                               {CertificateVerify*}
                                                         {Finished}
                                &lt;--------       [Application Data*]
        {Certificate*}
        {CertificateVerify*}
        {Finished}              --------&gt;
        [Application Data]      &lt;-------&gt;        [Application Data]
 
                 图 2：具有不匹配参数的完整握手的消息流
 
   注意：握手记录包含初始ClientHello/HelloRetryRequest交换；它不会使用新的
   ClientHello重置。
 
   TLS还允许基本握手的几个优化变体，如以下各节所述。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
2.2.  恢复和预共享密钥(PSK)
 
   虽然TLS PSK可以在带外建立，但是PSK也可以在以前的连接中建立，然后用于建立新的连接
   (使用PSK“会话恢复”或“恢复”)。一旦握手完成，服务器就可以向客户端发送一个PSK身份，
   该PSK身份对应于从初始握手导出的唯一密钥(参见4.6.1节)。然后，客户端可以在将来的
   握手中使用该PSK身份来协商相关PSK的使用。如果服务器接受PSK，则新连接的安全上下文被
   加密地绑定到原始连接，并且从初始握手导出的密钥被用于引导加密状态而不是完全握手。在
   TLS 1.2 及更低版本中，此功能由“session IDs”和“session tickets”[RFC5077]
   提供。这两种机制在TLS 1.3中都已过时。
 
   PSK可以与(EC)DHE密钥交换一起使用，以便结合共享密钥提供前向保密性，或者可以单独
   使用，但代价是失去应用数据的前向保密性。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   图3显示了一对握手，其中第一次握手建立PSK，第二次握手使用PSK：
 
          Client                                               Server

   Initial Handshake:
          ClientHello
          + key_share               --------&gt;
                                                          ServerHello
                                                          + key_share
                                                {EncryptedExtensions}
                                                {CertificateRequest*}
                                                       {Certificate*}
                                                 {CertificateVerify*}
                                                           {Finished}
                                    &lt;--------     [Application Data*]
          {Certificate*}
          {CertificateVerify*}
          {Finished}                --------&gt;
                                    &lt;--------      [NewSessionTicket]
          [Application Data]        &lt;-------&gt;      [Application Data]


   Subsequent Handshake:
          ClientHello
          + key_share*
          + pre_shared_key          --------&gt;
                                                          ServerHello
                                                     + pre_shared_key
                                                         + key_share*
                                                {EncryptedExtensions}
                                                           {Finished}
                                    &lt;--------     [Application Data*]
          {Finished}                --------&gt;
          [Application Data]        &lt;-------&gt;      [Application Data]
 
                          图3：恢复和PSK的消息流
 
   由于服务器通过PSK进行身份验证，因此它不会发送Certificate或CertificateVerify
   消息。当客户端通过PSK提供恢复时，它还应该向服务器提供“key_share”扩展，以允许
   服务器拒绝恢复并回退到完全握手(如果需要)。服务器用“pre_shared_key”扩展响应以
   协商PSK密钥建立的使用，并且可以(如此处所示)用“key_share”扩展响应以进行(EC)DHE
   密钥建立，从而提供前向保密性。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   当 PSK 在带外预配时，还必须预配要与 PSK 一起使用的 PSK 标识和 KDF 哈希算法。
 
   注意：当使用带外预配的预共享密钥时，一个关键的考虑因素是在密钥生成期间使用足够的
   熵，如 [RFC4086] 中所述。 从密码或其他低熵源派生共享密钥不安全。 低熵机密或密码
   会根据 PSK 活页夹进行字典攻击。 指定的 PSK 身份验证不是强基于密码的身份验证密钥
   交换，即使与 Diffie-Hellman 密钥建立一起使用也是如此。 具体而言，它不会阻止可以
   观察握手的攻击者对密码/预共享密钥执行暴力攻击。
 
2.3.  0-RTT Data
 
   当客户端和服务器共享PSK(通过外部获取或通过先前的握手获得)时，TLS 1.3允许客户端
   在第一波发送时发送数据(“早期数据”)。客户端使用PSK对服务器进行身份验证，并对早期
   数据进行加密。
 
   如图4所示，0-RTT数据只是添加到第一波发送中的1-RTT握手。握手的其余部分使用与具有
   PSK恢复的1-RTT握手相同的消息。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
         Client                                               Server

         ClientHello
         + early_data
         + key_share*
         + psk_key_exchange_modes
         + pre_shared_key
         (Application Data*)     --------&gt;
                                                         ServerHello
                                                    + pre_shared_key
                                                        + key_share*
                                               {EncryptedExtensions}
                                                       + early_data*
                                                          {Finished}
                                 &lt;--------       [Application Data*]
         (EndOfEarlyData)
         {Finished}              --------&gt;
         [Application Data]      &lt;-------&gt;        [Application Data]
 
              +  表示在前面的消息中发送的值得注意的扩展。
 
              *  表示并非总是发送的可选或依赖于情况的消息/扩展。

              ()表示使用从client_early_traffic_secret派生的密钥保护的消息。
 
              {} 握手阶段加密消息
 
              [] 握手完成后的加密消息
 
                            图4：0-RTT握手的消息流</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   重要说明：0-RTT数据的安全属性比其他类型的TLS数据的安全属性弱。具体而言：
 
   1.  此数据不是前向秘密，因为它仅在使用所提供的PSK导出的密钥下加密。
 
   2.  连接之间不能保证不重放。普通 TLS 1.3 1-RTT 数据的重放保护通过服务器的
       Random值提供，但 0-RTT 数据不依赖于 ServerHello ，因此具有较弱的保证。
       如果使用TLS客户端身份验证或在应用程序协议内部对数据进行身份验证，则这一点
       尤其重要。同样的警告也适用于 early_exporter_master_secret 的任何用法。
 
   0-RTT 数据不能在一个连接内复制(即，服务器不会为相同的连接处理相同的数据两次)，
   并且攻击者将无法使 0-RTT 数据看起来是 1-RTT 数据(因为它受到不同密钥的保护)。
   附录E.5 包含对潜在攻击的描述，第8节描述了服务器可用于限制重放影响的机制。
 
3.  演示语言
 
   本文档处理外部表示中的数据格式。将使用以下非常基本且有些随意定义的表示语法。
 
3.1.  基本块大小
 
   明确指定所有数据项的表示。基本数据块大小是一个字节(即，8位)。多字节数据项是字节
   的串联，从左到右，从上到下。从字节流中，多字节项(以下示例中的数字)通过以下方式
   形成(使用C表示法)：
 
      value = (byte[0] &lt;&lt; 8*(n-1)) | (byte[1] &lt;&lt; 8*(n-2)) |
              ... | byte[n-1];
 
   多字节值的字节排序是常见的网络字节顺序或大字节格式。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
3.2.  杂项
 
   注释以“/*”开头，以“*/”结尾。
 
   可选组件通过将其括在“[[]]”(双括号)中来表示。
 
   包含未解释数据的单字节实体属于不透明类型。
 
   现有类型T的类型别名T‘定义如下：
 
      T T';
 
3.3.  数字
 
   基本的数字数据类型是无符号字节(Uint8)。所有较大的数值数据类型都是由固定长度的
   字节序列构造的，这些字节序列按照3.1节中的描述连接起来，并且也是无符号的。以下数值
   类型是预定义的。
 
      uint8 uint16[2];
      uint8 uint24[3];
      uint8 uint32[4];
      uint8 uint64[8];
 
   所有值（此处和规范中的其他地方）均按网络字节（大端）顺序传输;由十六进制 
   01 02 03 04 表示的 uint32 等效于十进制值 16909060。
 
3.4.  向量
 
   向量(一维数组)是同构数据元素的流。矢量的大小可以在文档编制时指定，或者直到运行时
   才指定。在任何一种情况下，长度都声明向量中的字节数，而不是元素数。用于指定新类型
   T‘(即T类型的定长向量)的语法是。
 
      T T'[n];
 
   这里，T‘占据数据流中的n个字节，其中 n 是T的大小的倍数。向量的长度不包括在
   编码流中。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   在下面的示例中，Datum 被定义为协议不解释的三个连续字节，而 Data 是三个连续的
   Datum，总共消耗九个字节。
 
      opaque Datum[3];      /* three uninterpreted bytes */
      Datum Data[9];        /* three consecutive 3-byte vectors */
 
   可变长度向量是通过指定合法长度的子范围来定义的，使用表示法 &lt;下限..上限&gt; 。
   当这些被编码时，实际长度在字节流中的向量内容之前。长度将采用数字的形式，消耗的
   字节数与保持矢量指定的最大(上限)长度所需的字节数相同。实际长度字段为零的可变长度
   向量称为空向量。
 
      T T'&lt;floor..ceiling&gt;;
 
   在下面的示例中，“mandatory” 是一个必须包含300到400个不透明类型的字节的向量。
   它永远不会是空的。“实际长度”字段消耗两个字节，即uint16，这足以表示值400(参见
   第3.3节)。类似地，“longer”可以表示多达800字节的数据，或400个uint16元素，并且
   它可以是空的。它的编码将包括两个字节的实际长度字段，放在向量的前面。编码向量的长度必须是单个元素长度的精确倍数(例如，uint16的17字节向量是非法的)。
 
      opaque mandatory&lt;300..400&gt;;
            /* length field is two bytes, cannot be empty */
      uint16 longer&lt;0..800&gt;;
            /* zero to 400 16-bit unsigned integers */
 
3.5.  枚举
 
   其他稀疏数据类型（称为 "枚举"）。 每个定义都是不同的类型。 只能分配或比较相同类型
   的枚举。 枚举的每个元素都必须分配一个值，如以下示例所示。 由于枚举的元素不排序，
   因此可以按任意顺序为其分配任何唯一值。
 
      enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;
 
   将来对协议的扩展或添加可以定义新值。实现需要能够解析和忽略未知值，除非字段的定义
   另有说明。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   枚举在字节流中占用的空间与其定义的最大序数值一样多。下面的定义将使用一个字节
   携带Color类型的字段。
 
      enum { red(3), blue(5), white(7) } Color;
 
   可以任选地指定一个没有其关联标签的值，以强制宽度定义，而不定义多余的元素。
 
   在下面的示例中，Taste将占用数据流中的两个字节，但只能在协议的当前版本中取值
   1、2或4。
 
      enum { sweet(1), sour(2), bitter(4), (32000) } Taste;
 
   枚举元素的名称在定义的类型中限定作用域。在第一个示例中，对枚举的第二个元素的完全
   限定引用将是Color.blue。如果指定的目标明确，则不需要这种资格。
 
      Color color = Color.blue;     /* overspecified, legal */
      Color color = blue;           /* correct, type implicit */
 
   枚举元素的名称在定义的类型中限定作用域。在第一个示例中，对枚举的第二个元素的完全
   限定引用将是Color.blue。如果指定的目标明确，则不需要这种限制。
 
      enum { sad(0), meh(1..254), happy(255) } Mood;
 
3.6.  结构类型

   为方便起见，可以从基元类型构造结构类型。每个规范都声明了一个新的、唯一的类型。
   用于定义的语法非常类似于C。
 
      struct {
          T1 f1;
          T2 f2;
          ...
          Tn fn;
      } T;
 
   使用标准向量语法允许固定和可变长度向量域。变体示例(3.8节)中的结构V1和V2证明了
   这一点。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   结构中的字段可以使用类型的名称进行指定，其语法非常类似于枚举可用的语法。例如，
   T.f2是指前一个声明的第二个字段。
 
3.7.  常量
 
   可以使用“=”为字段和变量分配固定值，如：
 
      struct {
          T1 f1 = 8;  /* T.f1 must always be 8 */
          T2 f2;
      } T;
 
3.8.  变体
 
   定义的结构可能具有基于环境中可用的某些知识的变体。选择器必须是枚举类型，用于定义
   结构定义的可能变体。SELECT的每个分支(见下图)都指定了该变量的字段类型和可选的字段
   标签。在运行时选择变体的机制不是由表示语言规定的。
 
      struct {
          T1 f1;
          T2 f2;
          ....
          Tn fn;
          select (E) {
              case e1: Te1 [[fe1]];
              case e2: Te2 [[fe2]];
              ....
              case en: Ten [[fen]];
          };
      } Tv;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   For example:
 
      enum { apple(0), orange(1) } VariantTag;
 
      struct {
          uint16 number;
          opaque string&lt;0..10&gt;; /* variable length */
      } V1;
 
      struct {
          uint32 number;
          opaque string[10];    /* fixed length */
      } V2;
 
      struct {
          VariantTag type;
          select (VariantRecord.type) {
              case apple:  V1;
              case orange: V2;
          };
      } VariantRecord;
 
4.  握手协议
 
   握手协议用于协商连接的安全参数。握手消息被提供给TLS记录层，在那里它们被封装在一个
   或多个 TLSPlaintext 或 TLSCiphertext 结构中，这些结构按照当前活动连接的状态
   进行处理和传输。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
      enum {
          client_hello(1),
          server_hello(2),
          new_session_ticket(4),
          end_of_early_data(5),
          encrypted_extensions(8),
          certificate(11),
          certificate_request(13),
          certificate_verify(15),
          finished(20),
          key_update(24),
          message_hash(254),
          (255)
      } HandshakeType;
 
      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* remaining bytes in message */
          select (Handshake.msg_type) {
              case client_hello:          ClientHello;
              case server_hello:          ServerHello;
              case end_of_early_data:     EndOfEarlyData;
              case encrypted_extensions:  EncryptedExtensions;
              case certificate_request:   CertificateRequest;
              case certificate:           Certificate;
              case certificate_verify:    CertificateVerify;
              case finished:              Finished;
              case new_session_ticket:    NewSessionTicket;
              case key_update:            KeyUpdate;
          };
      } Handshake;
 
   协议消息必须按照第4.4.1节中定义的顺序发送，并在第2节的图表中显示。以意外顺序接收
   握手消息的对等体必须中止握手并发出 “unexpected_message” 警报。
 
   新的握手消息类型由IANA分配，如第11节所述。
 
4.1.  Key Exchange 消息
 
   密钥交换消息用于确定客户端和服务器的安全能力，并建立共享密钥，包括用于保护其余
   握手和数据的业务密钥。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.1.1.  加密协商
 
   在TLS中，加密协商通过客户端在 ClientHello 中提供以下四组选项来进行：
 
   -  密码套件列表，指示客户端支持的 AEAD算法/HKDF散列对。
 
   -  “supported_groups”(4.2.7节)扩展，表示客户端支持的(EC)DHE组；
      “key_share”(4.2.8节)扩展，包含部分或所有这些组的(EC)DHE共享。
 
   -  “signature_algorithms”(第4.2.3节)扩展，表示客户端可以接受的签名算法。
      还可以添加“signature_algorithms_cert”扩展(第4.2.3节)，以指示证书特定的
      签名算法。
 
   -  “pre_shared_key”(第4.2.11节)扩展，其中包含客户端已知的对称密钥身份列表，
      以及“psk_key_exchange_modes”(第4.2.9节)扩展，该扩展指示可与PSK一起
      使用的密钥交换模式。
 
   如果服务器不选择PSK，则这些选项中的前三个选项完全正交：服务器独立地选择密码组、
   (EC)DHE组和密钥共享用于密钥建立，以及签名算法/证书对以向客户端验证其自身。如果
   接收到的“supported_groups”与服务器支持的组之间没有重叠，则服务器必须中止握手，
   并发出“handshake_failure”或“insufficient_security”警报。
 
   如果服务器选择PSK，则它还必须从客户端的“psk_key_exchange_modes”扩展所指示的
   集合中选择密钥建立模式(目前，PSK单独或与(EC)DHE一起)。请注意，如果PSK可以在没有
   (EC)DHE的情况下使用，则“supported_groups”参数中的不重叠不一定是致命的，就像
   上一段中讨论的非PSK情况一样。
 
   如果服务器选择(EC)DHE组，并且客户端没有在初始 ClientHello 中提供兼容的
   “key_share”扩展，则服务器必须使用 HelloRetryRequest(第4.1.4节)消息进行
   响应。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   如果服务器成功选择参数且不需要 HelloRetryRequest，则ServerHello中选择的参数
   如下：
 
   -  如果正在使用PSK，则服务器将发送“pre_shared_key”扩展，指示所选密钥。
 
   -  使用(EC)DHE时，服务器还将提供“key_share”扩展。如果未使用PSK，则始终使用
      (EC)DHE和基于证书的身份验证。
 
   -  在进行证书身份验证时，服务器将发送 Certificate (第4.4.2节)和
      CertificateVerify(第4.4.3节)消息。在本文档定义的TLS 1.3中，始终使用PSK
      或证书，但不能同时使用。未来的文档可能会定义如何将它们一起使用。
 
   如果服务器无法协商支持的一组参数(即客户端和服务器参数之间没有重叠)，则必须中止
   握手，并发出“handshake_failure”或“insufficient_security”致命警报
   (参见第6节)。
 
4.1.2.  Client Hello
 
   当客户端首次连接到服务器时，需要发送ClientHello作为其第一个TLS消息。当服务器使用
   HelloRetryRequest 响应其 ClientHello 时，客户端还将发送 ClientHello 。在
   这种情况下，客户端必须发送相同的 ClientHello 而不进行修改，以下情况除外：
 
   -  如果 HelloRetryRequest 中提供了“key_share”扩展，则将共享列表替换为
      包含指定组中单个 KeyShareEntry 的列表。
 
   -  如果存在“early_data”扩展(第4.2.10节)，则删除该扩展。
      HelloRetryRequest 之后不允许早期数据。
 
   -  如果HelloRetryRequest中提供了“cookie”扩展，则包括“cookie”扩展。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   -  更新“pre_shared_key”扩展(如果存在)，方法是重新计算
      “obfuscated_ticket_age”和绑定器值，并(可选)删除与服务器指示的密码套件
      不兼容的任何PSK。
 
   -  可选地添加、删除或更改扩展的“填充”长度[RFC7685]。
 
   -  未来定义的扩展可能允许的其他修改，并且存在于 HelloRetryRequest 中。
 



   由于 TLS 1.3 禁止重新协商，因此如果服务器已经协商了 TLS 1.3 并在任何其他时间
   收到ClientHello，则它必须终止连接并发出“unexpected_message”警报。
 

   如果服务器与以前版本的 TLS 建立了 TLS 连接，并在重新协商中收到
   TLS 1.3 ClientHello，则它必须保留以前的协议版本。特别是，它不能协商TLS 1.3。
 


   Structure of this message:
 
      uint16 ProtocolVersion;
      opaque Random[32];
 
      uint8 CipherSuite[2];    /* Cryptographic suite selector */
 
      struct {
          ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
          Random random;
          opaque legacy_session_id&lt;0..32&gt;;
          CipherSuite cipher_suites&lt;2..2^16-2&gt;;
          opaque legacy_compression_methods&lt;1..2^8-1&gt;;
          Extension extensions&lt;8..2^16-1&gt;;
      } ClientHello;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   legacy_version:  在TLS的早期版本中，此字段用于版本协商，表示客户端支持的最高
      版本号。经验表明，许多服务器没有正确实现版本协商，导致
      “version intolerance”， 即服务器拒绝一个本来可以接受的 ClientHello，
     其版本号高于它所支持的版本号。在TLS 1.3中，客户端在 “supported_versions”
     扩展(第4.2.1节)中指明其版本首选项，并且 Legacy_Version 字段必须设置为
     0x0303，这是 TLS 1.2 的版本号。TLS 1.3 ClientHellos被标识为具有0x0303
     的 legacy_version 和 supported_versions 扩展，其中0x0304是其中指示的
     最高版本。(有关向后兼容性的详细信息，请参阅附录D。)。





   random:  由安全随机数生成器生成的32个字节。有关更多信息，请参见附录C。
 

   legacy_session_id:  TLS 1.3 之前的TLS版本支持“会话恢复”功能，该功能已与此
      版本中的预共享密钥合并(参见第2.2节)。具有由TLS 1.3之前的服务器设置的缓存
      会话ID 的客户端应将该字段设置为该值。在兼容模式下(参见附录D.4)，此字段必须
      非空，因此未提供TLS 1.3之前的会话的客户端必须生成新的32字节值。这个值不需要是
      随机的，但是应该是不可预测的，以避免实现专注于特定的值(也称为渗透)。否则，必须
      将其设置为零长度向量(即，零值单字节长度字段)。
 




   cipher_suites:  客户端支持的对称密码选项列表，指定记录层保护算法(包括密钥长度)
      和要与HKDF一起使用的散列，按客户端首选项的降序排列。值在附录B.4 中定义。如果
      列表中包含服务器不识别、不支持或不希望使用的密码套件，则服务器必须忽略这些
      密码套件，并像往常一样处理其余的密码套件。如果客户端正在尝试PSK密钥建立，则它
      应该通告至少一个指示与PSK相关联的散列的密码套件。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   legacy_compression_methods:  1.3之前的TLS版本支持压缩，支持的压缩方法列表
      在此字段中发送。对于每个 TLS 1.3 ClientHello，此向量必须正好包含一个字节，
      设置为零，这与以前版本的TLS中的“null”压缩方法相对应。如果接收到的TLS 1.3 
      ClientHello 具有此字段中的任何其他值，则服务器必须中止握手并发出
      “illegal_parameter” 警报。请注意，TLS 1.3 服务器可能会收到包含其他压缩
      方法的TLS 1.2或以前的ClientHellos，并且(如果协商这样的以前版本)必须遵循
      适用于TLS以前版本的过程。
 



   extensions:  客户端通过发送扩展字段中的数据从服务器请求扩展功能。实际的
      “Extension” 格式在4.2节中定义。在 TLS 1.3中，某些扩展的使用是强制性的，
      因为功能已经转移到扩展中，以保持 ClientHello 与以前版本的TLS的兼容性。服务器
      必须忽略无法识别的扩展。
 


   TLS的所有版本都允许扩展字段可选地跟随在 compression_methods 字段之后。
   TLS 1.3 ClientHello 消息始终包含扩展(最低限度为“supported_versions”，
   否则，它们将被解释为TLS 1.2 ClientHello 消息)。但是，TLS 1.3 服务器可能会从
   以前版本的TLS接收没有扩展字段的 ClientHello 消息。扩展的存在可以通过确定
   ClientHello末尾的 compression_methods 字段后面是否有字节来检测。请注意，这种
   检测可选数据的方法不同于具有可变长度字段的常规TLS方法，但它用于在定义扩展之前与
   TLS 兼容。TLS 1.3 服务器需要首先执行此检查，并且只有在存在
   “supported_versions”扩展时才会尝试协商 TLS 1.3。如果协商1.3之前的TLS版本，
   则服务器必须检查消息是否在 legacy_compression_methods 之后不包含数据，或者
   它是否包含有效的扩展块，后面没有数据。如果不是，则必须中止握手并发出
   “decode_error” 警报。
 
   在客户端使用扩展请求附加功能并且该功能不是由服务器提供的情况下，客户端可能会中止
   握手。
 
   发送 ClientHello 消息后，客户端等待 ServerHello 或 HelloRetryRequest消息。
   如果正在使用早期数据，则客户端可以在等待下一次握手消息的同时传输早期应用数据
   (第2.3节)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.1.3.  Server Hello
 
   如果服务器能够基于ClientHello协商可接受的握手参数集，则服务器将响应
   ClientHello 消息发送此消息以继续进行握手。
 
   Structure of this message:
 
      struct {
          ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
          Random random;
          opaque legacy_session_id_echo&lt;0..32&gt;;
          CipherSuite cipher_suite;
          uint8 legacy_compression_method = 0;
          Extension extensions&lt;6..2^16-1&gt;;
      } ServerHello;
 
   legacy_version:  在TLS的以前版本中，此字段用于版本协商，并表示连接的选定
      版本号。不幸的是，一些中间件在提供新值时会失败。在TLS 1.3中，TLS服务器使用
      “supported_versions”扩展(第4.2.1节)指示其版本，并且legacy_version字段
      必须设置为0x0303，这是TLS 1.2的版本号。(有关向后兼容性的详细信息，请参阅
      附录D。)
 



   random:  由安全随机数生成器生成的32字节。有关更多信息，请参见附录C。如果协商
      TLS 1.2 或 TLS 1.1 ，则必须覆盖后8个字节，如下所述，但其余字节必须是
      随机的。此结构由服务器生成，并且必须独立于 ClientHello.random 生成。


 
   legacy_session_id_echo:  客户端的 legacy_session_id 字段的内容。请注意，
      即使客户端的值对应于服务器已选择不恢复的缓存的TLS 1.3之前的会话，也会回显此
      字段。接收到与其在 ClientHello中发送的字段不匹配的legacy_session_id_echo
      字段的客户端必须中止握手，并发出“illegal_parameter”警报。



 
   cipher_suite:  服务器从 ClientHello.cipher_suites 中的列表中选择的单个密码
      套件。接收到未提供的密码套件的客户端必须中止握手，并发出“illegal_parameter”
      警报。
 
   legacy_compression_method:  必须具有值0的单个字节。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   extensions:  扩展的列表.   ServerHello 必须仅包含建立加密上下文和协商协议
      版本所需的扩展。 所有 TLS 1.3 ServerHello 消息必须包含
      "supported_versions" 扩展。 当前 ServerHello 消息还包含
      "pre_shared_key"扩展或"key_share"扩展，或两者（当 PSK 与 （EC）DHE 
      密钥建立时）。 其他扩展（请参阅第 4.2 节）在加密扩展消息中单独发送。
 
   出于与中间件向后兼容的原因(参见附录D.4)，HelloRetryRequest 消息使用与
   ServerHello相同的结构，但 Random 设置为 “HelloRetryRequest” 的SHA-256的
   特殊值：
 
     CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91
     C2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C
 
   在接收到 server_hello 类型的消息时，实现必须首先检查 Random 值，如果它与此值
   匹配，则按照4.1.4节中的描述对其进行处理。
 
   TLS 1.3在服务器的随机值中嵌入了降级保护机制。为响应 ClientHello 而协商
   TLS 1.2 或更低版本的 TLS 1.3 服务器必须特别在其 ServerHello 中设置其随机值
   的最后8个字节。
 
   如果协商 TLS 1.2，TLS 1.3 服务器必须将其随机值的最后8个字节设置为字节：
 
     44 4F 57 4E 47 52 44 01
 
   如果协商TLS 1.1或更低版本，则 TLS 1.3 服务器必须，并且TLS 1.2服务器应将其
   ServerHello.Random 值的最后8个字节设置为字节：
 
     44 4F 57 4E 47 52 44 00
 
   TLS 1.3客户端收到指示TLS 1.2或更低版本的ServerHello时，必须检查最后8个字节
   是否不等于这些值中的任何一个。如果ServerHello指示TLS 1.1或更低，TLS 1.2客户端
   还应检查最后8个字节是否等于第二个值。如果找到匹配项，客户端必须中止握手并发出
   “illegal_parameter”警报。此机制提供有限的保护，以防止在完成的交换所提供的内容
   之上的降级攻击：因为存在于TLS 1.2及更低版本中的消息 ServerKeyExchange 包括
   对两个随机值的签名，因此只要使用短暂的密码，主动攻击者就不可能在未检测的情况下
   修改随机值。使用静态RSA时，它不提供降级保护。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 




 
   注意：这是对[RFC5246]的更改，因此在实践中许多TLS 1.2客户端和服务器将不会像
   上面指定的那样工作。
 
   与TLS 1.2或更早版本执行重新协商并且在重新协商期间接收到 TLS 1.3 ServerHello
   的传统TLS客户端必须中止握手并发出“protocol_version”警报。请注意，当TLS 1.3
   已被协商时，重新协商是不可能的。
 
4.1.4.  Hello Retry Request
 
   如果服务器能够找到一组可接受的参数，但 ClientHello 没有包含足够的信息来继续
   进行握手，则服务器将发送此消息以响应 ClientHello 消息。如第4.1.3节所述，
   HelloRetryRequest 具有与 ServerHello 消息相同的格式，Legacy_Version、
   Legacy_Session_id_echo、cipher_Suite 和 Legacy_Compression_Method字段
   具有相同的含义。然而，为了方便起见，我们在整个文档中讨论 “HelloRetryRequest”，
   就好像它是一条截然不同的消息一样。
 
   服务器的扩展必须包含“supported_versions”。此外，它应该包含客户端生成正确
   的 ClientHello 对所需的最小扩展集。与 ServerHello 一样，HelloRetryRequest
   不得包含客户端在其 ClientHello 中首先提供的任何扩展，但可选的 “cookie” 
   (参见第4.2.2节)扩展除外。
 




   收到 HelloRetryRequest 后，客户端必须按照第4.1.3节的规定检查
   Legacy_Version、Legacy_Session_id_echo、cipher_Suite和
   Legacy_Compression_Method，然后处理扩展，首先使用“Supported_Versions”
   确定版本。如果HelloRetryRequest不会导致ClientHello中的任何更改，则客户端必须
   中止握手并发出“illegal_parameter”警报。如果客户端在同一连接中接收到第二个
   HelloRetryRequest(即ClientHello本身响应HelloRetryRequest)，则它必须中止
   握手并发出“unexpected_message”警报。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   否则，客户端必须处理HelloRetryRequest中的所有扩展，并发送第二个更新的
   ClientHello。本规范中定义的HelloRetryRequest扩展包括：
 
   -  supported_versions (see Section 4.2.1)
 
   -  cookie (see Section 4.2.2)
 
   -  key_share (see Section 4.2.8)
 
   接收到未提供密码套件的客户端必须中止握手。服务器必须确保在接收符合更新的
   ClientHello 时协商相同的密码套件(如果服务器选择密码套件作为协商的第一步，则这
   将自动发生)。在接收到ServerHello后，客户端必须检查 ServerHello 中提供的密码
   套件与HelloRetryRequest中提供的密码套件是否相同，否则会中止握手并发出
   “illegal_parameter”警报。

 
   此外，在其更新的ClientHello中，客户端不应提供与所选密码套件的散列以外的散列
   相关联的任何预共享密钥。这允许客户端避免必须为第二ClientHello中的多个散列计算
   部分散列转录本。
 
   HelloRetryRequest的“supported_versions”扩展中 selected_version 的值
   必须保留在 ServerHello 中，并且如果值更改，客户端必须中止握手并发出
   “illegal_parameter”警报。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.  Extensions
 
   许多TLS消息包含标记长度值编码的扩展结构。
 
    struct {
        ExtensionType extension_type;
        opaque extension_data&lt;0..2^16-1&gt;;
    } Extension;
 
    enum {
        server_name(0),                             /* RFC 6066 */
        max_fragment_length(1),                     /* RFC 6066 */
        status_request(5),                          /* RFC 6066 */
        supported_groups(10),                       /* RFC 8422, 7919 */
        signature_algorithms(13),                   /* RFC 8446 */
        use_srtp(14),                               /* RFC 5764 */
        heartbeat(15),                              /* RFC 6520 */
        application_layer_protocol_negotiation(16), /* RFC 7301 */
        signed_certificate_timestamp(18),           /* RFC 6962 */
        client_certificate_type(19),                /* RFC 7250 */
        server_certificate_type(20),                /* RFC 7250 */
        padding(21),                                /* RFC 7685 */
        pre_shared_key(41),                         /* RFC 8446 */
        early_data(42),                             /* RFC 8446 */
        supported_versions(43),                     /* RFC 8446 */
        cookie(44),                                 /* RFC 8446 */
        psk_key_exchange_modes(45),                 /* RFC 8446 */
        certificate_authorities(47),                /* RFC 8446 */
        oid_filters(48),                            /* RFC 8446 */
        post_handshake_auth(49),                    /* RFC 8446 */
        signature_algorithms_cert(50),              /* RFC 8446 */
        key_share(51),                              /* RFC 8446 */
        (65535)
    } ExtensionType;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Here:
 
   -  "extension_type" 标识特定的扩展类型。
 
   -  "extension_data" 包含特定于特定扩展类型的信息。
 
   扩展类型列表由IANA维护，如第11节所述。
 
   扩展通常是以请求/响应的方式构造的，尽管一些扩展只是没有相应响应的指示。客户端
   在ClientHello消息中发送其扩展请求，服务器在ServerHello、
   EncryptedExtensions、HelloRetryRequest和Certificate消息中发送其扩展响应。
   服务器在CertificateRequest消息中发送扩展请求，客户端可以用证书消息来响应。
   服务器也可以在NewSessionTicket中发送未经请求的扩展，尽管客户端不直接响应这些
   扩展。
 
   如果远程端点没有发送相应的扩展请求，则实现不得发送扩展响应，HelloRetryRequest
   中的“cookie”扩展除外。在接收到这样的扩展时，端点必须中止握手并发出
   “unsupported_extension”警报。
 
   下表显示给定扩展可能出现的消息，使用以下表示法：CH(ClientHello)、
   SH(ServerHello)、EE(EncryptedExtensions)、CT(Certificate)、
   CR(CertificateRequest)、NST(NewSessionTicket)和
   HRR(HelloRetryRequest)。如果实现接收到它识别的扩展，并且没有为它出现的消息
   指定该扩展，则它必须中止握手并发出“illegal_parameter”警报。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   +--------------------------------------------------+-------------+
   | Extension                                        |     TLS 1.3 |
   +--------------------------------------------------+-------------+
   | server_name [RFC6066]                            |      CH, EE |
   |                                                  |             |
   | max_fragment_length [RFC6066]                    |      CH, EE |
   |                                                  |             |
   | status_request [RFC6066]                         |  CH, CR, CT |
   |                                                  |             |
   | supported_groups [RFC7919]                       |      CH, EE |
   |                                                  |             |
   | signature_algorithms (RFC 8446)                  |      CH, CR |
   |                                                  |             |
   | use_srtp [RFC5764]                               |      CH, EE |
   |                                                  |             |
   | heartbeat [RFC6520]                              |      CH, EE |
   |                                                  |             |
   | application_layer_protocol_negotiation [RFC7301] |      CH, EE |
   |                                                  |             |
   | signed_certificate_timestamp [RFC6962]           |  CH, CR, CT |
   |                                                  |             |
   | client_certificate_type [RFC7250]                |      CH, EE |
   |                                                  |             |
   | server_certificate_type [RFC7250]                |      CH, EE |
   |                                                  |             |
   | padding [RFC7685]                                |          CH |
   |                                                  |             |
   | key_share (RFC 8446)                             | CH, SH, HRR |
   |                                                  |             |
   | pre_shared_key (RFC 8446)                        |      CH, SH |
   |                                                  |             |
   | psk_key_exchange_modes (RFC 8446)                |          CH |
   |                                                  |             |
   | early_data (RFC 8446)                            | CH, EE, NST |
   |                                                  |             |
   | cookie (RFC 8446)                                |     CH, HRR |
   |                                                  |             |
   | supported_versions (RFC 8446)                    | CH, SH, HRR |
   |                                                  |             |
   | certificate_authorities (RFC 8446)               |      CH, CR |
   |                                                  |             |
   | oid_filters (RFC 8446)                           |          CR |
   |                                                  |             |
   | post_handshake_auth (RFC 8446)                   |          CH |
   |                                                  |             |
   | signature_algorithms_cert (RFC 8446)             |      CH, CR |
   +--------------------------------------------------+-------------+</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   当存在多个不同类型的扩展时，扩展可以任何顺序出现，除了“pre_shared_key”
   (第4.2.11节)，它必须是ClientHello中的最后一个扩展 (但可以出现在ServerHello
   Extensions块的任何地方)。给定的扩展块中不能有多个相同类型的扩展。
 
   在TLS 1.3中，与TLS 1.2不同，即使在恢复PSK模式下，也会为每次握手协商扩展。
   然而，0-RTT 参数是在前一次握手中协商的参数；不匹配可能需要拒绝0-RTT
   (参见4.2.10节)。
 
   在这个协议中，新功能和现有功能之间可能会发生一些微妙的(也不是那么微妙的)交互作用，
   这可能会导致总体安全性的显着降低。设计新扩展时应考虑以下注意事项：
 
   -  服务器不同意扩展的某些情况是错误条件(例如，握手不能继续)，而有些情况只是拒绝
      支持特定功能。通常，前者应使用错误警报，后者应在服务器扩展响应中使用一个字段。
 
   -  扩展应尽可能设计为防止通过操纵握手消息来强制使用(或不使用)特定功能的任何攻击。
      无论是否认为该功能会导致安全问题，都应遵循此原则。通常，扩展字段被包括在完成
      的消息散列的输入中的事实将是足够的，但是当扩展改变在握手阶段发送的消息的含义
      时，需要格外小心。设计者和实现者应该意识到这样一个事实：在握手得到验证之前，
      主动攻击者可以修改消息并插入、删除或替换扩展。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.1.  Supported Versions
 
      struct {
          select (Handshake.msg_type) {
              case client_hello:
                   ProtocolVersion versions&lt;2..254&gt;;
 
              case server_hello: /* and HelloRetryRequest */
                   ProtocolVersion selected_version;
          };
      } SupportedVersions;
 
   “supported_versions”扩展由客户端用来指示它支持的TLS版本，服务器用来指示它
   正在使用的版本。该扩展包含按优先顺序排列的受支持版本的列表，最首选的版本排在第一
   位。本规范的实现必须在ClientHello中发送此扩展，其中包含它们准备协商的所有TLS
   版本(对于本规范，这意味着最低限度为0x0304，但如果允许协商TLS的以前版本，则它们
   也必须存在)。
 
   如果不存在此扩展，则符合本规范且支持TLS 1.2的服务器必须按照[RFC5246]中的规定
   协商TLS 1.2或更早版本，即使ClientHello.legacy_version 为0x0304或更高版本
   也是如此。服务器可能会在接收到具有legacy_version 0x0304或更高版本的
   ClientHello时中止握手。
 
   协商TLS 1.3之前的TLS版本的服务器必须设置ServerHello.version，并且不能发送
   “supported_versions”扩展。协商TLS 1.3的服务器必须通过发送包含所选版本值
   (0x0304)的“supported_versions”扩展来响应。它必须将
   ServerHello.legacy_version 字段设置为0x0303(TLS 1.2)。客户端必须在处理
   ServerHello的其余部分之前检查此扩展(尽管它们必须解析ServerHello才能读取扩展)。
   如果存在此扩展，则客户端必须忽略 ServerHello.legacy_version 值，并且必须
   仅使用“supported_versions”扩展来确定所选版本。如果ServerHello中的
   “supported_versions”扩展包含客户端未提供的版本或包含TLS 1.3之前的版本，则
   客户端必须中止握手并发出“illegal_parameter”警报。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 







 
4.2.2.  Cookie
 
      struct {
          opaque cookie&lt;1..2^16-1&gt;;
      } Cookie;
 
   Cookie有两个主要用途：
 
   -  允许服务器强制客户端在其明显的网络地址展示可达性(从而提供DoS保护措施)。这
      主要用于非面向连接的传输(参见[RFC6347]中的一个例子)。
 
   -  允许服务器将状态卸载到客户端，从而允许它发送HelloRetryRequest而不存储任何
      状态。服务器可以通过将ClientHello的散列存储在HelloRetryRequest cookie
      (用一些适当的完整性保护算法保护)中来做到这一点。
 
   当发送HelloRetryRequest时，服务器可以向客户端提供“cookie”扩展(这是通常
   规则的例外，即可能发送的唯一扩展是那些出现在ClientHello中的扩展)。当发送
   新的ClientHello时，客户端必须将HelloRetryRequest中接收到的扩展的内容复制到
   新ClientHello中的“cookie”扩展中。在后续连接中，客户端不得在其初始
   ClientHello中使用Cookie。
 
   当服务器无状态运行时，它可能会在第一个ClientHello和第二个ClientHello之间接收
   change_cipher_spec类型的不受保护的记录(参见第5节)。由于服务器没有存储任何
   状态，这将看起来好像它是要接收的第一条消息。无状态运行的服务器必须忽略这些记录。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.3.  Signature Algorithms
 
   TLS 1.3提供了两个扩展，用于指示在数字签名中可以使用哪些签名算法。
   “signature_algorithms_cert” 扩展适用于证书中的签名，而最初出现在TLS 1.2中的
   “signature_algorithms”扩展适用于 CertificateVerify 消息中的签名。证书中找
   到的密钥还必须是与其一起使用的签名算法的适当类型。这是RSA密钥和PSS签名的特殊
   问题，如下所述。如果不存在“signature_algorithms_cert”扩展，则
   “signature_algorithms”扩展也适用于证书中出现的签名。希望服务器通过证书对自身
   进行身份验证的客户端必须发送“signature_algorithms”扩展。如果服务器通过证书进行
   身份验证，而客户端尚未发送“signature_algorithms”扩展，则服务器必须中止握手
   并发出“missing_extension”警报(参见第9.2节)。
 
   添加了"signature_algorithms_cert"扩展，以允许支持证书和 TLS 本身的不同
   算法集的实现清楚地发出其功能信号。  TLS 1.2 实现也应处理此扩展。在这两种情况下
   具有相同策略的实现可能会省略"signature_algorithms_cert"扩展。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   这些扩展的“extension_data”字段包含SignatureSchemeList 值：
 
      enum {
          /* RSASSA-PKCS1-v1_5 algorithms */
          rsa_pkcs1_sha256(0x0401),
          rsa_pkcs1_sha384(0x0501),
          rsa_pkcs1_sha512(0x0601),
 
          /* ECDSA algorithms */
          ecdsa_secp256r1_sha256(0x0403),
          ecdsa_secp384r1_sha384(0x0503),
          ecdsa_secp521r1_sha512(0x0603),
 
          /* RSASSA-PSS algorithms with public key OID rsaEncryption */
          rsa_pss_rsae_sha256(0x0804),
          rsa_pss_rsae_sha384(0x0805),
          rsa_pss_rsae_sha512(0x0806),
 
          /* EdDSA algorithms */
          ed25519(0x0807),
          ed448(0x0808),
 
          /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */
          rsa_pss_pss_sha256(0x0809),
          rsa_pss_pss_sha384(0x080a),
          rsa_pss_pss_sha512(0x080b),
 
          /* Legacy algorithms */
          rsa_pkcs1_sha1(0x0201),
          ecdsa_sha1(0x0203),
 
          /* Reserved Code Points */
          private_use(0xFE00..0xFFFF),
          (0xFFFF)
      } SignatureScheme;
 
      struct {
          SignatureScheme supported_signature_algorithms&lt;2..2^16-2&gt;;
      } SignatureSchemeList;
 
   注意：这个枚举被命名为“SignatureScheme”，因为在TLS 1.2中已经有一个
   “SignatureAlgorithm”类型，这将被替换。我们在整个文本中使用术语
   “signature algorithm”。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   每个SignatureScheme值列出了客户端愿意验证的单个签名算法。这些值以首选项的降序
   表示。请注意，签名算法将任意长度的消息而不是摘要作为输入。传统上作用于摘要的算法
   应该在TLS中定义，以首先使用指定的散列算法对输入进行散列，然后照常进行。上面列出
   的码点组有以下含义：
 
   RSASSA-PKCS1-v1_5 algorithms:  表示使用 RSASSA-PKCS1-v1_5[RFC8017]
      和[SHS]中定义的相应散列算法的签名算法。这些值仅指出现在证书中的签名(参见
      第4.4.2.2节)，并未定义为在签名的TLS握手消息中使用，尽管为了与TLS 1.2向后
      兼容，它们可能出现在“Signature_Algorithms”
      和“Signature_Algorithms_cert”中。
 
   ECDSA algorithms:  表示使用ECDSA[ECDSA]的签名算法，ANSI X9.62[ECDSA]
      和 FIPS 186-4[DSS]中定义的相应曲线，以及[SHS]中定义的相应散列算法。签名
      表示为DER编码的[X690]ECDSA-sig-value结构。
 
   RSASSA-PSS RSAE algorithms:  表示使用带有掩码生成函数1的
      RSASSA-PSS[RFC8017]的签名算法。掩码生成函数中使用的摘要和正在签名的摘要
      都是[SHS]中定义的相应散列算法。Salt的长度必须等于摘要算法的输出长度。如果
      公钥在X.509证书中携带，则必须使用rsaEncryption OID[RFC5280]。
 
   EdDSA algorithms:  表示使用[RFC8032]或其后继者中定义的EdDSA的签名算法。
      请注意，这些对应于“PureEdDSA”算法，而不是“Manage”变体。
 
   RSASSA-PSS PSS algorithms:  表示使用带有掩码生成函数1的
      RSASSA-PSS[RFC8017]的签名算法。掩码生成函数中使用的摘要和正在签名的摘要
      都是[SHS]中定义的相应散列算法。Salt的长度必须等于摘要算法的长度。如果公钥
      在X.509证书中携带，则必须使用 RSASSA-PSS OID[RFC5756]。在证书签名中使用
      时，必须对算法参数进行DER编码。如果存在相应的公钥参数，则签名中的参数必须与
      公钥中的参数相同。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Legacy algorithms:  表示由于使用具有已知弱点的算法而被弃用的算法，特别是在此
      上下文中与使用(1)RSASSA-PKCS1-v1_5或(2)ECDSA的RSA一起使用的SHA-1。这些
      值仅指出现在证书中的签名(参见第4.4.2.2节)，并未定义为在签名的TLS握手消息中
      使用，尽管为了与TLS 1.2向后兼容，它们可能出现在“Signature_Algorithms”和
      “Signature_Algorithms_cert”中。端点不应协商这些算法，但允许这样做只是
      为了向后兼容。提供这些值的客户端必须将它们列为最低优先级(列在
      SignatureSchemeList中的所有其他算法之后)。TLS 1.3服务器不得提供SHA-1
      签名的证书，除非没有它就无法产生有效的证书链(参见第4.4.2.2节)。
 
   自签名证书上的签名或作为信任锚的证书上的签名不会被验证，因为它们开始了一个证书路径
   (参见[RFC5280]，第 3.2节)。开始认证路径的证书可以使用在
   “signature_algorithms”扩展中未被宣传为受支持的签名算法。
 
   请注意，TLS 1.2对此扩展的定义有所不同。愿意协商TLS 1.2的TLS 1.3实现在协商
   该版本时必须符合[RFC5246]的要求。特别是：
 
   -  TLS 1.2客户端Hellos可以省略此扩展。
 
   -  在TLS 1.2中，扩展包含散列/签名对。这些对以两个二进制八位数编码，因此已
      分配SignatureScheme值以与TLS 1.2的编码对齐。一些遗留对未分配。从TLS 1.3
      开始，不推荐使用这些算法。任何实施都不能提供或协商它们。特别是，不能使用
      MD5[SLOTH]、SHA-224和DSA。
 
   -  ECDSA签名方案与TLS 1.2的ECDSA散列/签名对一致。然而，旧的语义并没有约束
      签名曲线。如果TLS 1.2被协商，实现必须准备接受使用他们在“supported_groups”
      扩展中通告的任何曲线的签名。
 
   -  发布对 RSASSA-PSS 的支持（TLS 1.3 中是强制性的）的实现必须准备好接受使用
      该方案的签名，即使协商 TLS 1.2 也是如此。 在 TLS 1.2 中，RSASSA-PSS 与
      RSA 密码套件一起使用。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.4.  Certificate Authorities
 
   “certificate_authority” 扩展用于指示端点支持的证书颁发机构(CA)，以及接收端点
   应该使用哪些证书颁发机构来指导证书选择。
 
   “certificate_authority”扩展的主体由CertificateAuthoritiesExtension结构
   组成。
 
      opaque DistinguishedName&lt;1..2^16-1&gt;;
 
      struct {
          DistinguishedName authorities&lt;3..2^16-1&gt;;
      } CertificateAuthoritiesExtension;
 
   authorities:  可接受的证书颁发机构的可分辨名称[X501]的列表，以DER编码的
      [X690]格式表示。这些可分辨名称为信任锚或从属CA指定了所需的可分辨名称；因此，
      此消息可用于描述已知的信任锚以及所需的授权空间。
 
   客户端可以在ClientHello消息中发送“certificate_authority”扩展。服务器可以
   在 CertificateRequest 消息中发送它。
 
   “Trusted_ca_keys”扩展[RFC6066]具有类似的用途，但更为复杂，在TLS 1.3中
   未使用(尽管它可能出现在来自提供先前版本的TLS的客户端的ClientHello消息中)。
 
4.2.5.  OID Filters
 
   “oid_filters”扩展允许服务器提供一组OID/值对，它希望客户端的证书匹配这些
   OID/值对。如果服务器提供此扩展，则只能在 CertificateRequest 消息中发送。
 
      struct {
          opaque certificate_extension_oid&lt;1..2^8-1&gt;;
          opaque certificate_extension_values&lt;0..2^16-1&gt;;
      } OIDFilter;
 
      struct {
          OIDFilter filters&lt;0..2^16-1&gt;;
      } OIDFilterExtension;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   filters:  证书扩展OID[RFC5280]及其允许值的列表，并以DER编码的[X690]格式
      表示。一些证书扩展OID允许多个值(例如，扩展密钥用法)。如果服务器包含非空筛选器
      列表，则响应中包含的客户端证书必须包含客户端识别的所有指定扩展OID。对于客户端
      识别的每个扩展OID，所有指定的值都必须存在于客户端证书中(但证书也可以具有其他
      值)。但是，客户端必须忽略并跳过任何无法识别的证书扩展OID。如果客户端忽略了一些
      所需的证书扩展OID，并提供了一个不满足请求的证书，则服务器可以在不进行客户端
      身份验证的情况下继续连接，或者通过“unsupported_certificate”警报中止握手。
      任何给定的OID不得在筛选器列表中出现一次以上。
 
   PKIX RFC定义了各种证书扩展OID及其相应的值类型。根据类型的不同，匹配的证书扩展值
   不一定是逐位相等的。预计TLS实现将依赖于其PKI库来使用证书扩展OID执行证书选择。
 
   本文档为[RFC5280]中定义的两个标准证书扩展定义了匹配规则：
 
   -  当请求中断言的所有密钥使用位也在密钥使用证书扩展中断言时，证书中的密钥使用扩展
      与请求相匹配。
 
   -  证书中的扩展密钥使用扩展与请求匹配，此时请求中存在的所有关键用途 OID 也位于
      扩展密钥使用证书扩展中。 请求中不得使用任何扩展密钥使用 OID 的特殊键。
 
   单独的规范可以为其他证书扩展定义匹配规则。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.6.  Post-Handshake Client Authentication
 
   “post_handshak_auth”扩展用于表示客户端愿意执行握手后身份验证(第4.6.2节)。
   服务器不能向不提供此扩展的客户端发送握手后CertificateRequest。服务器不得发送
   此扩展。
 
      struct {} PostHandshakeAuth;
 
   “post_handshak_auth”扩展的“extension_data”字段长度为零。
 
4.2.7.  Supported Groups
 
   当客户端发送时，“supported_groups”扩展表示客户端支持的用于密钥交换的命名组，
   按从最优先到最不优先的顺序排列。
 
   注意：在TLS 1.3之前的TLS版本中，此扩展为“椭圆曲线”，并且仅包含椭圆曲线组。
   参见[RFC8422]和[RFC7919]。此扩展也用于协商ECDSA曲线。签名算法现在是独立协商
   的(参见第4.2.3节)。
 
   此扩展的“extension_data”字段包含一个“NamedGroupList”值：
 
      enum {
 
          /* Elliptic Curve Groups (ECDHE) */
          secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
          x25519(0x001D), x448(0x001E),
 
          /* Finite Field Groups (DHE) */
          ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),
          ffdhe6144(0x0103), ffdhe8192(0x0104),
 
          /* Reserved Code Points */
          ffdhe_private_use(0x01FC..0x01FF),
          ecdhe_private_use(0xFE00..0xFEFF),
          (0xFFFF)
      } NamedGroup;
 
      struct {
          NamedGroup named_group_list&lt;2..2^16-1&gt;;
      } NamedGroupList;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Elliptic Curve Groups (ECDHE):  表示支持相应的命名曲线，在FIPS 186-4[DSS]
      或[RFC7748]中定义。值0xFE00至0xFEFF保留供私人使用[RFC8126]。
 
   Finite Field Groups (DHE):  表示对[RFC7919]中定义的相应有限域组的支持。
      值0x01FC至0x01FF保留供私人使用。
 
   named_group_list 中的项目根据发件方的偏好排序(最优先选择)。
 
   从TLS 1.3开始，允许服务器向客户端发送“supported_groups”扩展。在成功完成握手
   之前，客户端不能根据在“supported_groups”中找到的任何信息采取行动，但可以使用从
   成功完成的握手中学到的信息来更改它们在后续连接中使用的“key_share”扩展中的组。
   如果服务器具有比“key_share”扩展中的组更喜欢的组，但仍愿意接受ClientHello，则
   应发送“supported_groups”以更新客户端的首选项视图；此扩展应包含服务器支持的所有
   组，无论客户端当前是否支持这些组。
 
4.2.8.  Key Share
 
   “key_share”扩展包含端点的加密参数。
 
   客户端可能会发送空的client_shares 向量，以便向服务器请求组选择，代价是额外的往返
   (参见第4.1.4节)。
 
      struct {
          NamedGroup group;
          opaque key_exchange&lt;1..2^16-1&gt;;
      } KeyShareEntry;
 
   group:  正在交换的密钥的命名组。
 
   key_exchange:  密钥交换信息。此字段的内容由指定的组及其相应的定义确定。有限域
      Diffie-Hellman[DH76]参数在4.2.8.1节中描述；椭圆曲线Diffie-Hellman参数
      在4.2.8.2节中描述。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   在ClientHello消息中，该扩展的“extension_data”字段包含一个
   “KeyShareClientHello”值：
 
      struct {
          KeyShareEntry client_shares&lt;0..2^16-1&gt;;
      } KeyShareClientHello;
 
   client_shares:  按客户端首选项的降序排列的提供的KeyShareEntry值的列表。
 
   如果客户端正在请求HelloRetryRequest，则此向量可能为空。每个KeyShareEntry值
   必须对应于“supported_groups”扩展中提供的组，并且必须以相同的顺序出现。然而，
   这些值可以是“supported_groups”扩展的非连续子集，并且可以省略最优选的组。如果
   最优先的群体是新的，而且不太可能在足够的地方得到支持，以便预先生成关键份额，则
   可能会出现这种情况。
 
   客户端可以提供与其提供的支持组数量相同的KeyShareEntry值，每个组代表一组密钥交换
   参数。例如，客户可能提供几条椭圆曲线或多个FFDHE组的份额。必须独立生成每个
   KeyShareEntry的key_exchange值。客户端不能为同一组提供多个KeyShareEntry值。
   客户端不得为客户端的“Supported_Groups”扩展中未列出的组提供任何KeyShareEntry
   值。服务器可以检查是否违反了这些规则，如果有违反，则中止握手，并发出
   “illegal_parameter”警报。
 
   在HelloRetryRequest消息中，此扩展的“extension_data”字段包含
   KeyShareHelloRetryRequest值：
 
      struct {
          NamedGroup selected_group;
      } KeyShareHelloRetryRequest;
 
   selected_group:  服务器打算协商的相互支持的组，并请求重试的客户端
      Hello/KeyShare。
 
   在HelloRetryRequest中接收到此扩展后，客户端必须验证(1)selected_group字段
   对应于原始ClientHello中的“supported_groups”扩展中提供的组，以及
   (2)selected_group字段不对应于原始 ClientHello 中的 “Key_Share”扩展中提供
   的组。如果这两个检查中的任何一个失败，则客户端必须中止握手并发出
   “illegal_parameter”警报。否则，在发送新的 ClientHello 时，客户端必须将原始
   的“key_share”扩展替换为仅包含触发HelloRetryRequest的selected_group字段中
   指示的组的新KeyShareEntry的扩展。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 


 
   在ServerHello消息中，此扩展的“extension_data”字段包含KeyShareServerHello
   值：
 
      struct {
          KeyShareEntry server_share;
      } KeyShareServerHello;
 
   server_share:  与client's shares之一在同一组中的单个KeyShareEntry值。
 
   如果使用(EC)DHE密钥建立，服务器在ServerHello中只提供一个KeyShareEntry。
   此值必须与服务器为协商的密钥交换选择的客户端提供的KeyShareEntry值在同一组中。
   服务器不得为客户端的“Supported_Groups”扩展中未指明的任何组发送
   KeyShareEntry，也不得在使用“PSK_ke”PskKeyExchangeMode时发送
   KeyShareEntry。如果客户端收到使用(EC)DHE密钥建立和包含“KEY_SHARE”扩展
   的HelloRetryRequest，则客户端必须验证ServerHello中选定的NamedGroup与
   HelloRetryRequest中的NamedGroup相同。如果此检查失败，客户端必须中止握手并
   发出“illegal_parameter”警报。
 
4.2.8.1.  Diffie-Hellman Parameters
 
   客户端和服务器的Diffie-Hellman[DH76]参数都编码在KeyShare结构中
   KeyShareEntry的不透明KEY_EXCHANGE字段中。OPAQUE值包含指定组的
   Diffie-Hellman公共值(Y=g^X mod p)(有关组定义，请参阅[RFC7919])，编码为
   大端整数，并在左侧填充0，大小为p(以字节为单位)。
 
   注意：对于给定的Diffie-Hellman组，填充会导致所有公钥具有相同的长度。
 
   对等点必须通过确保1</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.8.2.  ECDHE Parameters
 
   客户端和服务器的ECDHE参数都编码在KeyShare结构中KeyShareEntry的不透明
   KEY_EXCHANGE字段中。
 
   对于secp256r1、secp384r1和secp521r1，内容是以下struct的序列化值：
 
      struct {
          uint8 legacy_form = 4;
          opaque X[coordinate_length];
          opaque Y[coordinate_length];
      } UncompressedPointRepresentation;
 
   X和Y分别是网络字节顺序中x和y值的二进制表示。没有内部长度标记，因此每个数字表示
   占用与曲线参数所暗示的一样多的二进制八位数。对于P-256，这意味着X和Y中的每一个都
   使用32个二进制八位数，如有必要，在左侧用零填充。对于P-384，他们每个采取48个八位
   组。对于P-521，他们每个采取66个八位组。
 
   对于曲线secp256r1、secp384r1和secp521r1，对等节点必须通过确保该点是椭圆曲线
   上的有效点来验证彼此的公共值Q。适当的验证程序在[ECDSA]的第4.3.7节中定义，或者在
   [KEYAGREEMENT]的第5.6.2.3节中定义。这个过程包括三个步骤：(1)验证q不是无穷远处
   的点(O)，(2)验证对于q=(x，y)整数x和y都在正确的区间内，以及(3)确保(x，y)是椭圆
   曲线方程的正确解。对于这些曲线，实现者不需要验证正确子组中的成员资格。
 
   对于X25519和X448，公共值的内容是[RFC7748]中定义的相应函数的字节串输入和
   输出：X25519为32字节，X448为56字节。
 
   注意：1.3之前的TLS版本允许点格式协商；TLS 1.3删除了此功能，支持每条曲线的
   单点格式。
 
4.2.9.  Pre-Shared Key Exchange Modes
 
   为了使用PSK，客户端还必须发送“psk_key_exchange_modes”扩展。此扩展的语义是
   客户端仅支持使用具有这些模式的PSK，这限制了在此ClientHello中提供的PSK的使用，
   以及服务器可能通过NewSessionTicket提供的PSK的使用。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   如果客户端提供“pre_shared_key”扩展，则它必须提供“psk_key_exchange_modes”
   扩展。如果客户端提供的“pre_shared_key”不带“psk_key_exchange_modes”扩展，
   则服务器必须中止握手。服务器不得选择客户端未列出的密钥交换模式。此扩展还限制了
   用于PSK恢复的模式。服务器不应发送带有与通告模式不兼容的票证的NewSessionTicket；
   但是，如果服务器这样做，其影响只会是客户端的恢复尝试失败。
 
   服务器不得发送“psk_key_exchange_modes”扩展。
 
      enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;
 
      struct {
          PskKeyExchangeMode ke_modes&lt;1..255&gt;;
      } PskKeyExchangeModes;
 
   psk_ke:  仅PSK密钥建立。在此模式下，服务器不得提供“key_share”值。
 
   psk_dhe_ke:  PSK与(EC)DHE密钥建立。在此模式下，客户端和服务器必须提供
       “key_share”值，如第4.2.8节所述。
 
   分配的任何未来值必须确保传输的协议消息明确地标识服务器选择了哪种模式；目前，这是
   由ServerHello中存在的“key_share”指示的。
 
4.2.10.  Early Data Indication
 
   当使用PSK并且允许该PSK的早期数据时，客户端可以在其第一次发送消息时发送应用程序
   数据。如果客户端选择这样做，它必须同时提供“pre_shared_key”和“Early_Data”
   扩展。
 
   此扩展的“extension_data”字段包含一个“EarlyDataIndication”值。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
      struct {} Empty;
 
      struct {
          select (Handshake.msg_type) {
              case new_session_ticket:   uint32 max_early_data_size;
              case client_hello:         Empty;
              case encrypted_extensions: Empty;
          };
      } EarlyDataIndication;
 
   有关max_early_data_size 字段使用的详细信息，请参阅第4.6.1节。
 
   0-RTT数据的参数(版本、对称密码组、应用层协议协商(ALPN)[RFC7301]协议等)。是与
   正在使用的PSK相关联的那些。对于外部调配的PSK，关联值是与密钥一起调配的值。对于
   通过 NewSessionTicket 消息建立的PSK，关联值是在建立 PSK 的连接中协商的那些
   值。用于加密早期数据的PSK必须是客户端的“pre_shared_key”扩展中列出的第一个PSK。
 
   对于通过 NewSessionTicket 提供的PSK，服务器必须验证所选PSK身份(通过从
   PskIdentity.obfuscated_ticket_age % 2^32 - Ticket_age_add计算)的票龄
   在自票证发出后的时间容差内(参见第8节)。如果不是，则服务器应继续握手，但拒绝
   0-RTT，并且不应采取任何其他假定此ClientHello是新的操作。
 
   在第一个航班中发送的0-RTT消息与在其他航班中发送的相同类型的消息(握手和应用数据)
   具有相同的(加密的)内容类型，但受到不同密钥的保护。在接收到服务器的完成消息后，
   如果服务器已经接受了早期数据，则会发送EndOfEarlyData消息以指示密钥更改。此消息
   将使用0-RTT业务密钥进行加密。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   接收“early_data”扩展的服务器必须采用以下三种方式之一：
 
   -  忽略扩展并返回常规的 1-RTT 响应。 然后，服务器会跳过过去的早期数据，尝试使用
      握手流密钥取消对接收到的记录层的保护，丢弃未能取消保护的记录数据（最多为配置的
      max_early_data_size）。 一旦记录层被成功取消保护，它将被视为客户端第二次
      消息的开始，服务器继续执行普通 1-RTT 握手。
 
   -  请求客户端通过响应 HelloRetryRequest 发送另一个 ClientHello 。 客户端
      不得在其后续 ClientHello 中包含"early_data"扩展。 然后，服务器通过跳过
      外部内容类型为"application_data"（指示它们已加密）的所有记录来忽略早期
      数据，最长为已配置的 max_early_data_size。
 
   -  在EncryptedExtensions中返回自己的“early_data”扩展，表示打算处理早期数据。
      服务器不可能仅接受早期数据消息的子集。即使服务器发送接受早期数据的消息，实际的
      早期数据本身在服务器生成此消息时可能已经在运行。
 








   为了接受早期数据，服务器必须接受PSK密码套件并选择客户端的“pre_shared_key”扩展
   中提供的第一个密钥。此外，它必须验证以下值是否与所选PSK关联的值相同：
 
   -  TLS版本号
 
   -  选定的密码套件
 
   -  所选ALPN[RFC7301]协议(如果有)
 
   这些要求是使用所讨论的 PSK 执行 1-RTT 握手所需的那些要求的超集。对于外部建立的
   PSK，关联值是与密钥一起提供的值。对于通过 NewSessionTicket 消息建立的 PSK，
   关联值是在建立票证的连接中协商的那些值。
 
   未来的扩展必须定义它们与0-RTT的交互。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   如果这些检查中的任何一个失败，服务器必须不响应扩展，并且必须使用上面列出的前两个
   机制之一丢弃所有的第一波发送数据(因此回退到1-RTT或2-RTT)。如果客户端尝试0-RTT
   握手，但服务器拒绝它，则服务器通常不具有0-RTT记录保护密钥，并且必须改为使用试用
   解密(或者使用1-RTT握手密钥，或者通过在HelloRetryRequest的情况下通过查找明文
   ClientHello)来找到第一个非0-RTT消息。
 
   如果服务器选择接受“early_data”扩展，则在处理早期数据记录时，它必须符合为所有
   记录指定的相同错误处理要求。具体地说，如果服务器在接受的“early_data”扩展之后
   未能解密0-RTT记录，则必须按照5.2节的规定使用“bad_record_mac”警报终止连接。
 
   如果服务器拒绝“early_data”扩展，则一旦握手完成，客户端应用程序可以选择重新传输
   先前在early_data中发送的应用程序数据。注意，早期数据的自动重传可能导致关于连接
   状态的不正确假设。例如，当协商的连接选择与用于早期数据的ALPN协议不同的ALPN协议
   时，应用程序可能需要构造不同的消息。同样，如果早期数据假定有关连接状态的任何内容，
   则可能在握手完成后错误地发送。
 
   TLS实现不应自动重新发送早期数据；应用程序可以更好地决定何时重新传输是合适的。
   除非协商的连接选择相同的ALPN协议，否则TLS实现不得自动重新发送早期数据。
 












4.2.11.  Pre-Shared Key Extension
 
   “pre_shared_key”扩展用于协商与PSK密钥建立关联的给定握手使用的预共享密钥的身份。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   此扩展的“extension_data”字段包含“PreSharedKeyExtension”值：
 
      struct {
          opaque identity&lt;1..2^16-1&gt;;
          uint32 obfuscated_ticket_age;
      } PskIdentity;
 
      opaque PskBinderEntry&lt;32..255&gt;;
 
      struct {
          PskIdentity identities&lt;7..2^16-1&gt;;
          PskBinderEntry binders&lt;33..2^16-1&gt;;
      } OfferedPsks;
 
      struct {
          select (Handshake.msg_type) {
              case client_hello: OfferedPsks;
              case server_hello: uint16 selected_identity;
          };
      } PreSharedKeyExtension;
 
   identity:  密钥标签。例如，票证(如附录B.3.4中所定义)或外部建立的预共享密钥的
      标签。
 
   obfuscated_ticket_age:  密钥年龄的模糊版本。第4.2.11.1节描述了如何为通过
      NewSessionTicket 消息建立的身份形成此值。对于外部建立的身份，应使用0的
      obfuscated_ticket_age，并且服务器必须忽略该值。
 
   identities:  客户端愿意与服务器协商的身份列表。如果与“early_data”扩展一起发送
      (参见第4.2.10节)，则第一个身份是用于0-RTT数据的身份。
 
   binders:  一系列HMAC值，每个值对应身份列表中的每个值，并按相同的顺序进行计算，
      如下所述。
 
   selected_identity:  服务器选择的标识，表示为客户端列表中标识的(从0开始)索引。
 






   每个PSK与单个散列算法相关联。对于通过票证机制建立的PSK(第4.6.1节)，这是建立
   票证的连接上的KDF哈希算法。对于外部建立的PSK，在建立PSK时必须设置Hash算法，如果
   未定义此类算法，则默认设置为SHA-256。服务器必须确保它选择兼容的PSK(如果有的话)
   和密码套件。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   
 
   在TLS 1.3之前的TLS版本中，服务器名称标识(SNI)值旨在与会话相关联(
   [RFC6066]的第3节)，要求服务器强制与会话关联的SNI值与恢复握手中指定的SNI值相
   匹配。然而，在现实中，对于它们将使用两个提供的SNI值中的哪一个，实现并不一致，导致
   客户端事实上强制执行一致性要求。在TLS 1.3中，SNI值总是在恢复握手中显式指定，
   服务器不需要将SNI值与票证相关联。然而，客户应将SNI与PSK一起存储，以满足
   第4.6.1节的要求。
 








   实现者注意：当会话恢复是PSK的主要用例时，实现PSK/密码套件匹配要求的最直接的方法
   是首先协商密码套件，然后排除任何不兼容的PSK。应该简单地忽略任何未知的PSK(例如，
   不在PSK数据库中或用未知密钥加密的PSK)。如果未找到可接受的PSK，则服务器应执行
   非PSK握手(如果可能)。如果向后兼容性很重要，客户端提供的外部建立的PSK应该会影响
   密码套件的选择。
 



   在接受PSK密钥建立之前，服务器必须验证相应的绑定器值(参见下面的4.2.11.2节)。
   如果此值不存在或未验证，则服务器必须中止握手。服务器不应尝试验证多个绑定器；相反，
   它们应该选择单个PSK并仅验证对应于该PSK的绑定器。有关此要求的安全理由，请参见
   第8.2节和附录E.6。为了接受PSK密钥建立，服务器发送指示所选身份的
   “pre_shared_key”扩展。
 
   客户端必须验证服务器的selected_identity是否在客户端提供的范围内，服务器是否
   选择了指示与PSK关联的哈希的密码套件，以及如果 ClientHello
   “psk_key_exchange_modes”扩展需要，服务器“key_share”扩展是否存在。如果这些值
   不一致，客户端必须中止握手并发出“illegal_parameter”警报。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   如果服务器提供了“early_data”扩展名，则客户端必须验证服务器的selected_identity
   是否为0。如果返回任何其他值，则客户端必须中止握手并发出“illegal_parameter”
   警报。
 
   “pre_shared_key”扩展名必须是ClientHello中的最后一个扩展名(这便于实现，如下
   所述)。服务器必须检查它是否是最后一个扩展名，否则握手失败，并显示
   “illegal_parameter” 警报。
 
4.2.11.1.  Ticket Age
 
   客户端对票龄的看法是自收到 NewSessionTicket 消息以来的时间。客户端不得尝试使用
   年龄大于随票证提供的“ticket_lifetime”值的票证。每个PskIdentity的
   “obfuscated_ticket_age” 字段包含一个模糊版本的票龄，其形成方式是以毫秒为单位
   取年龄并添加票证附带的“ticket_age_add”值(参见第4.6.1节)，模数为2^32。此添加
   可防止被动观察者关联连接，除非重新使用票证。请注意，NewSessionTicket消息中的
   “ticket_lifetime”字段以秒为单位，而“obfuscated_ticket_age”以毫秒为单位。
   由于票证寿命被限制为一周，因此32位足以表示任何合理的年龄，即使以毫秒为单位。
 
4.2.11.2.  PSK Binder
 
   PSK 绑定器值在 PSK 和当前握手之间形成绑定，以及在生成 PSK 的握手（如果通过
   NewSessionTicket消息）和当前握手之间的绑定。绑定器列表中的每个条目都被计算为
   基于包含部分ClientHello的哈希值，包括PreSharedKeyExtension.identities的
   HMAC。也就是说，它包括所有ClientHello，但不包括绑定器列表本身。消息的长度字段
   (包括总长度、扩展块的长度和“pre_shared_key”扩展的长度)都被设置为好像存在正确
   长度的绑定器一样。
 
   PskBinderEntry的计算方法与Finished消息相同(第4.4.4节)，但BaseKey是通过密钥
   进度表从提供的相应PSK导出的binder_key(参见7.1节)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   如果握手包括 HelloRetryRequest，则初始客户端Hello和 HelloRetry请求将连同
   新的ClientHello一起包含在记录中。 例如，如果客户端发送 ClientHello1，其
   绑定器将通过以下方式计算：
 
      Transcript-Hash(Truncate(ClientHello1))
 
   其中 Truncate() 从ClientHello 中删除绑定器列表。
 
   如果服务器响应HelloRetryRequest，然后客户端发送ClientHello2，则将计算其绑定：
 
      Transcript-Hash(ClientHello1,
                      HelloRetryRequest,
                      Truncate(ClientHello2))
 
   完整的ClientHello1/ClientHello2包含在所有其他握手散列计算中。请注意，在
   第一波发送中，Truncate(ClientHello1)直接进行散列，但在第二波发送中，对
   ClientHello1进行散列，然后作为“message_hash”消息重新注入，如第4.4.1节所述。
 
4.2.11.3.  Processing Order
 
   允许客户端“流式传输”0-RTT数据，直到它们接收到服务器完成，然后才发送
   EndOfEarlyData消息，然后是握手的其余部分。为了避免死锁，在接受“early_data”
   时，服务器必须处理客户端的ClientHello，然后立即发送它们的消息，而不是在发送
   ServerHello之前等待客户端的EndOfEarlyData消息。
 
4.3.  Server Parameters
 
   接下来来自服务器的两条消息 EncryptedExtensions 和 CertificateRequest 包含
   来自服务器的信息，这些信息决定了握手的其余部分。使用从
   server_handshake_traffic_secret派生的密钥对这些消息进行加密。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.3.1.  Encrypted Extensions
 
   在所有握手中，服务器必须在ServerHello消息之后立即发送EncryptedExtensions
   消息。这是在从server_handshak_traffic_secret派生的密钥下加密的第一条消息。
 
   加密扩展消息包含可受保护的扩展，即任何不需要建立加密上下文但不与单个证书关联的
   扩展。客户端必须检查EncryptedExtensions是否存在任何禁止的扩展，如果发现任何
   扩展，则必须中止握手并发出“illegal_parameter”警报。
 
   Structure of this message:
 
      struct {
          Extension extensions&lt;0..2^16-1&gt;;
      } EncryptedExtensions;
 
   extensions:  扩展列表。有关更多信息，请参见4.2节中的表格。
 
4.3.2.  Certificate Request
 
   使用证书进行身份验证的服务器可以可选地向客户端请求证书。如果发送此消息，则必须在
   EncryptedExtensions之后。
 
   Structure of this message:
 
      struct {
          opaque certificate_request_context&lt;0..2^8-1&gt;;
          Extension extensions&lt;2..2^16-1&gt;;
      } CertificateRequest;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   certificate_request_context:  标识证书请求并将在客户端的证书消息中回显的
      字符串。certificate_request_context 在此连接范围内必须是唯一的(从而防止
      客户端 CertificateVerify 消息的重播)。此字段应为零长度，除非用于4.6.2节
      中描述的握手后身份验证交换。当请求握手后身份验证时，服务器应使上下文对客户端
      不可预测(例如，通过随机生成上下文)，以防止对客户端私钥具有临时访问权限的
      攻击者预先计算有效的CertificateVerify消息。
 
   extensions:  描述所请求证书的参数的一组扩展。必须指定“signature_algorithms”
      扩展，如果为此消息定义了其他扩展，则可以选择包括其他扩展。客户端必须忽略无法
      识别的扩展。
 







   在TLS的以前版本中，CertificateRequest消息包含服务器将接受的签名算法和证书颁发
   机构的列表。在TLS 1.3中，前者通过发送“signature_algorithms”和可选的
   “signature_algorithms_cert”扩展来表示。后者通过发送
   “certificate_authority”扩展来表示(参见第4.2.4节)。
 
   使用PSK进行身份验证的服务器不得在主握手中发送CertificateRequest消息，尽管它们
   可以在握手后身份验证中发送该消息(参见第4.6.2节)，但前提是客户端已发送
   “post_handshak_auth”扩展(参见第4.2.6节)。
 

4.4.  Authentication Messages
 
   如第2节所述，TLS通常使用一组通用的消息进行身份验证、密钥确认和握手
   完整性：Certificate、CertificateVerify和Finish。(PSK绑定器也以类似的方式
   执行密钥确认。)。这三条消息总是作为他们握手发送中的最后一条消息发送。Certificate
   和CertificateVerify 消息仅在某些情况下发送，定义如下。完成的消息始终作为身份
   验证块的一部分发送。这些消息在从 [sender]_handshake_traffic_secret 派生的
   密钥下进行加密。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   验证消息的计算都统一采用以下输入:
 
   -  要使用的证书和签名密钥
 
   -  握手上下文，由要包含在记录散列中的一组消息组成。
 
   -  用于计算MAC密钥的基础密钥。
 
   基于这些输入，消息随后添加：
 
   Certificate:  用于身份验证的证书，以及链中的任何支持证书。请注意，基于证书的
      客户端身份验证在PSK握手流(包括0-RTT)中不可用。
 
   CertificateVerify:  Hash(Handshake Context, Certificate)的签名
 
   Finished:  使用从基密钥派生的MAC密钥在 Transcript-Hash(Handshake   
      Context, Certificate，CertificateVerify) 的值上进行MAC。
 
   下表定义了每个场景的握手上下文和MAC基础密钥：
 
   +-----------+-------------------------+-----------------------------+
   | Mode      | Handshake Context       | Base Key                    |
   +-----------+-------------------------+-----------------------------+
   | Server    | ClientHello ... later   | server_handshake_traffic_   |
   |           | of EncryptedExtensions/ | secret                      |
   |           | CertificateRequest      |                             |
   |           |                         |                             |
   | Client    | ClientHello ... later   | client_handshake_traffic_   |
   |           | of server               | secret                      |
   |           | Finished/EndOfEarlyData |                             |
   |           |                         |                             |
   | Post-     | ClientHello ... client  | client_application_traffic_ |
   | Handshake | Finished +              | secret_N                    |
   |           | CertificateRequest      |                             |
   +-----------+-------------------------+-----------------------------+</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.4.1.  The Transcript Hash
 
   TLS 中的许多加密计算都使用Transcript哈希。 此值是通过对包含的每个握手消息（包括
   包含握手消息类型和长度字段的握手消息标头）的串联进行哈希计算的，但不包括记录层
   标头。即：
 
    Transcript-Hash(M1, M2, ... Mn) = Hash(M1 || M2 || ... || Mn)
 
   作为此一般规则的例外情况，当服务器使用 HelloRetryRequest 响应 ClientHello
   时，ClientHello1  的值将替换为包含哈希（ClientHello1）的握手类型为
   "message_hash" 的特殊合成握手消息。 即
 
  Transcript-Hash(ClientHello1, HelloRetryRequest, ... Mn) =
      Hash(message_hash ||        /* Handshake type */
           00 00 Hash.length  ||  /* Handshake message length (bytes) */
           Hash(ClientHello1) ||  /* Hash of ClientHello1 */
           HelloRetryRequest  || ... || Mn)
 
   这种构造的原因是允许服务器通过在cookie中仅存储ClientHello1的散列来执行无状态
   HelloRetryRequest，而不是要求它导出整个中间散列状态(参见第4.2.2节)。
 
   为具体起见，始终从以下握手消息序列中提取记录散列，从第一个ClientHello开始，并且
   仅包括发送的那些消息：ClientHello，HelloRetryRequest，ClientHello，
   ServerHello，EncryptedExtensions，server CertificateRequest，
   server Certificate，server CertificateVerify，Server Finish，
   EndOfEarlyData，Client Certificate，Client CertificateVerify，
   Client Finish。

 
   通常，实现可以通过基于协商的散列保持运行的Transcript Hash来实现抄本。然而，
   请注意，后续的握手后身份验证不包括彼此，只包括通过主握手结束的消息。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.4.2.  Certificate
 
   此消息将端点的证书链传递给对等体。
 
   每当商定的密钥交换方法使用证书进行身份验证时，服务器必须发送证书消息(这包括本文档
   中定义的所有密钥交换方法，PSK除外)。
 
   当且仅当服务器通过CertificateRequest消息请求客户端身份验证时，客户端必须发送
   证书消息(第4.3.2节)。如果服务器请求客户端身份验证，但没有合适的证书可用，则客户端
   必须发送不包含证书的证书消息(即，“certificate_list”字段的长度为0)。无论证书
   消息是否为空，都必须发送 Finished 消息。
 
   Structure of this message:
 
      enum {
          X509(0),
          RawPublicKey(2),
          (255)
      } CertificateType;
 
      struct {
          select (certificate_type) {
              case RawPublicKey:
                /* From RFC 7250 ASN.1_subjectPublicKeyInfo */
                opaque ASN1_subjectPublicKeyInfo&lt;1..2^24-1&gt;;
 
              case X509:
                opaque cert_data&lt;1..2^24-1&gt;;
          };
          Extension extensions&lt;0..2^16-1&gt;;
      } CertificateEntry;
 
      struct {
          opaque certificate_request_context&lt;0..2^8-1&gt;;
          CertificateEntry certificate_list&lt;0..2^24-1&gt;;
      } Certificate;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   certificate_request_context:  如果此消息响应CertificateRequest，则为该
      消息中certificate_request_context的值。否则(在服务器身份验证的情况下)，
      此字段应为零长度。
 
   certificate_list:  CertificateEntry结构的序列(链)，每个结构包含一个证书和
      一组扩展。
 
   extensions:  CertificateEntry的一组扩展值。“扩展”格式在4.2节中定义。目前
      服务器证书的有效扩展包括OCSP状态扩展[RFC6066]和
      SignedCertificateTimestamp扩展[RFC6962]；也可以为此消息定义未来的扩展。
      来自服务器的证书消息中的扩展必须对应于ClientHello消息中的扩展。来自客户端
      的证书消息中的扩展必须对应于来自服务器的CertificateRequest消息中的扩展。
      如果扩展应用于整个链，则应将其包括在第一个CertificateEntry中。
 
   如果在EncryptedExtensions中未协商相应的证书类型扩展
   (“server_certificate_type” 或 “client_certificate_type”)，或者协商了
   X.509证书类型，则每个 CertificateEntry 都包含一个 DER 编码的 X.509证书 。
   发送者的证书必须位于列表中的第一个 CertificateEntry 中。每一个紧随其后的证书
   都应直接证明紧接其前的证书。因为证书验证需要独立分发信任锚点，所以可以从链中省略
   指定信任锚点的证书，前提是所支持的对等体已知拥有任何省略的证书。
 
   注意：在TLS 1.3之前，“certificate_list”排序要求每个证书对紧接它之前的证书
   进行认证；然而，一些实现允许一些灵活性。服务器有时会出于过渡目的同时发送当前和
   不推荐使用的中间件，而其他服务器只是配置不正确，但这些情况仍然可以正确地进行验证。
   为了获得最大的兼容性，所有实现都应该准备好处理来自任何TLS版本的可能无关的证书
   和任意顺序，但第一个证书必须是发送者的证书。
 
   如果协商了RawPublicKey证书类型，则certificate_list必须包含不超过一个
   CertificateEntry，其中包含一个 ASN1_SubjectPublicKeyInfo 值，
   如[RFC7250]第3节所定义。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   OpenPGP证书类型[RFC6091]不能与TLS 1.3一起使用。
 
   服务器的certificate_list必须始终为非空。如果客户端没有要发送的适当证书来响应
   服务器的身份验证请求，则它将发送一个空的certificate_list。
 
4.4.2.1.  OCSP Status and SCT Extensions
 
   [RFC6066]和[RFC6961]提供扩展以协商服务器向客户端发送OCSP响应。在TLS 1.2及
   更低版本中，服务器以空扩展回复以指示此扩展的协商，并且在CertificateStatus消息中
   携带OCSP信息。在TLS 1.3中，服务器的OCSP信息在包含相关证书的CertificateEntry
   中的扩展中携带。具体地说，来自服务器的“status_request”扩展的主体必须是
   [RFC6066]中定义的CertificateStatus结构，其解释为[RFC6960]中定义的。
 
   注意：status_request_v2 扩展[RFC6961]已弃用。在处理ClientHello消息时，
   TLS 1.3 服务器不得根据其存在或其中的信息进行操作；尤其是，它们不得在
   EncryptedExtensions、CertificateRequest 或 Certificate消息中发送
   status_request_v2扩展。TLS 1.3 服务器必须能够处理包含它的ClientHello消息，
   因为它可能由在早期协议版本中使用它的客户端发送。
 
   服务器可以通过在其CertificateRequest消息中发送空的“status_request”扩展来
   请求客户端将OCSP响应与其证书一起呈现。如果客户端选择发送OCSP响应，其
   “status_request”扩展的主体必须是[RFC6066]中定义的CertificateStatus结构。
 
   类似地，[RFC6962]为服务器提供了一种机制，用于在TLS 1.2及更低版本的ServerHello
   中发送签名证书时间戳(Signed Certificate Timestamp，SCT)作为扩展。在
   TLS 1.3中，服务器的 SCT 信息在CertificateEntry中的扩展中携带。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.4.2.2.  服务器证书选择
 
   以下规则适用于服务器发送的证书：
 
   -  证书类型必须是X.509v3[RFC5280]，除非明确协商(例如，[RFC7250])。
 
   -  服务器的最终实体证书的公钥(及相关限制)必须与从客户端的
      “signature_algorithms”扩展(当前为RSA、ECDSA或EdDSA)中选择的身份验证
      算法兼容。
 
   -  证书必须允许使用密钥进行签名(即，如果存在密钥使用扩展，则必须设置
      digitalSignature位)，并在客户端的
      “signature_algorithms”/“signature_algorithms_cert”扩展中指定签名方案
      (参见第4.2.3节)。
 
   -  “server_name”[RFC6066]和“certificate_authority”扩展名用于指导证书
      选择。由于服务器可能需要存在“server_name”扩展，因此客户端应发送此扩展
      (如果适用)。
 
   如果服务器能够提供这样的链，则服务器提供的所有证书都必须使用客户端公布的签名算法
   进行签名(见第4.2.3节)。自签名的证书或预期为信任锚的证书不作为链的一部分进行验证，
   因此可以使用任何算法进行签名。
 
   如果服务器不能产生仅通过所指示的支持的算法签名的证书链，则它应该通过向客户端发送
   其选择的证书链来继续握手，该证书链可能包括不知道客户端支持的算法。此回退链一般
   不应使用已弃用的SHA-1哈希算法，但如果客户端的广告允许，则可以这样做，否则不得
   这样做。
 
   如果客户端无法使用提供的证书构建可接受的链，并决定中止握手，则必须使用适当的证书
   相关警报中止握手(默认情况下，为“unsupported_certificate”；有关更多信息，
   请参见第6.2节)。
 
   如果服务器有多个证书，它会根据上述标准(除了其他标准，如传输层端点、本地配置和
   首选项)选择其中一个。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.4.2.3.  客户端证书选择
 
   以下规则适用于客户端发送的证书：
 
   -  证书类型必须是X.509v3[RFC5280]，除非明确协商(例如，[RFC7250])。
 
   -  如果CertificateRequest消息中存在“certificate_authority”扩展，则
      证书链中的至少一个证书应由列出的CA之一颁发。
 
   -  必须使用可接受的签名算法对证书进行签名，如第4.3.2节所述。请注意，这将放宽
      TLS以前版本中对证书签名算法的限制。
 
   -  如果CertificateRequest消息包含非空的“oid_filters”扩展，则最终实体证书
      必须与客户端识别的扩展OID相匹配，如第4.2.5节所述。
 
4.4.2.4.  接收证书消息
 
   一般来说，详细的证书验证程序超出了TLS的范围(参见[RFC5280])。本节提供特定于TLS
   的要求。
 
   如果服务器提供空的证书消息，则客户端必须中止握手并发出“decode_error”警报。
 
   如果客户端不发送任何证书(即，它发送空的证书消息)，则服务器可以在不进行客户端身份
   验证的情况下继续握手，或者使用“certificate_required”警报中止握手。此外，如果
   证书链的某些方面是不可接受的(例如，它不是由已知的、受信任的CA签署的)，则服务器
   可以根据其判断继续握手(考虑到客户端未认证)或中止握手。
 
   任何接收到需要使用任何签名算法(使用MD5散列)验证的证书的端点必须中止握手并发出
   “bad_certificate”警报。SHA-1已弃用，建议接收需要使用SHA-1散列的任何签名算法
   验证的任何证书的任何端点使用“bad_certificate”警报中止握手。为了清楚起见，
   这意味着端点可以接受自签名证书或信任锚证书的这些算法。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   建议所有端点尽快过渡到SHA-256或更好的版本，以保持与当前正在逐步取消SHA-1支持的
   实施的互操作性。
 
   注意，包含一个签名算法的密钥的证书可以使用不同的签名算法(例如，用ECDSA密钥签名
   的RSA密钥)进行签名。
 
4.4.3.  Certificate Verify
 
   此消息用于提供端点拥有与其证书相对应的私钥的明确证明。CertificateVerify 消息
   还为目前为止的握手提供了完整性。服务器在通过证书进行身份验证时必须发送此消息。
   每当通过证书进行身份验证时(即证书消息非空时)，客户端都必须发送此消息。发送时，
   此消息必须立即出现在证书消息之后，并紧接着出现在完成消息之前。
 
   Structure of this message:
 
      struct {
          SignatureScheme algorithm;
          opaque signature&lt;0..2^16-1&gt;;
      } CertificateVerify;
 
   算法字段指定使用的签名算法(有关此类型的定义，请参见第4.2.3节)。签名是使用该算法
   的数字签名。签名所涵盖的内容是第4.4.1节所述的哈希输出，即：
 
      Transcript-Hash(Handshake Context, Certificate)
 
   然后通过以下级联计算数字签名：
 
   -  由重复64次的八位字节32(0x20)组成的字符串。
 
   -  上下文字符串。
 
   -  作为分隔符的单个0字节。
 
   -  要签名的内容</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   此结构旨在防止对以前版本的TLS的攻击，其中ServerKeyExchange格式意味着攻击者
   可以获得具有所选32字节前缀(ClientHello.random)的消息的签名。初始的64字节填充
   清除该前缀以及服务器控制的ServerHello.random。
 
   服务器签名的上下文字符串是“TLS 1.3，server CertificateVerify”。客户端签名的
   上下文字符串是“TLS 1.3，Client CertificateVerify”。它用于提供在不同上下文中
   进行的签名之间的分离，有助于防止潜在的跨协议攻击。
 
   例如，如果记录散列为32字节01(此长度对于SHA-256有意义)，则服务器
   CertificateVerify 的数字签名所涵盖的内容将为：
 
      2020202020202020202020202020202020202020202020202020202020202020
      2020202020202020202020202020202020202020202020202020202020202020
      544c5320312e332c207365727665722043657274696669636174655665726966
      79
      00
      0101010101010101010101010101010101010101010101010101010101010101
 
   在发送方，CertificateVerify消息的签名字段的计算过程作为输入：
 
   -  数字签名覆盖的内容。
 
   -  前一条消息中发送的证书对应的私有签名密钥。
 
   如果CertificateVerify消息是由服务器发送的，则签名算法必须是客户端的
   “Signature_Algorithms”扩展中提供的算法，除非在没有不支持的算法的情况下无法
   生成有效的证书链(参见4.2.3节)。
 
   如果由客户端发送，则签名中使用的签名算法必须是CertificateRequest消息中
   “signature_algorithms”扩展的supported_signature_algorithms字段中存在的
   算法之一。
 
   此外，签名算法必须与发送方的最终实体证书中的密钥兼容。RSA签名必须使用RSASSA-PSS
   算法，无论“signature_algorithms”中是否出现RSASSA-PKCS1-v1_5算法。不能在
   CertificateVerify 消息的任何签名中使用SHA-1算法。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   本规范中的所有SHA-1签名算法都是专为在传统证书中使用而定义的，对于
   CertificateVerify签名无效。
 
   CertificateVerify消息的接收方必须验证签名字段。验证过程采用以下输入：
 
   -  数字签名覆盖的内容。
 
   -  包含在相关证书消息中找到的对方证书中的公钥。
 
   -  CertificateVerify消息的Signature字段中收到的数字签名。
 
   如果验证失败，接收方必须终止握手并发出“decrypt_error”警报。
 
4.4.4.  Finished
 
   Finished消息是身份验证块中的最终消息。它对于提供握手和计算出的密钥的认证是
   必不可少的。
 
   Finished消息的接收者必须验证内容是否正确，如果不正确，则必须使用
   “decrypt_error”警报终止连接。
 
   一旦一方发送了其 Finished 消息并从其对等方接收并验证了 Finished 消息，它就
   可以开始通过连接发送和接收应用程序数据。允许在接收对等体的 Finished 之前发送
   数据的设置有两种：
 
   1.  客户端发送第4.2.10节所述的0-RTT数据。
 
   2.  服务器可在发送第一波发送后发送数据，但由于握手尚未完成，因此无法保证对等方
       的身份或其活动性（即，ClientHello 可能已被重播）。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   用于计算完成消息的密钥是使用HKDF根据4.4节中定义的基本密钥计算的(参见7.1节)。
   具体而言：
 
   finished_key =
       HKDF-Expand-Label(BaseKey, "finished", "", Hash.length)
 
   Structure of this message:
 
      struct {
          opaque verify_data[Hash.length];
      } Finished;
 
   The verify_data value is computed as follows:
 
      verify_data =
          HMAC(finished_key,
               Transcript-Hash(Handshake Context,
                               Certificate*, CertificateVerify*))
 
      * Only included if present.
 
   HMAC[RFC2104]使用哈希算法进行握手。如上所述，HMAC输入通常可以通过正在运行的
   散列(即，仅在此时的握手散列)来实现。
 
   在TLS的早期版本中，VERIFY_DATA始终是12个八位字节的长度。在TLS 1.3中，它是
   用于握手的哈希的HMAC输出的大小。
 
   注意：警报和任何其他非握手记录类型不是握手消息，不包括在散列计算中。
 
   Finished消息之后的任何记录都必须按照第7.2节所述，在适当的应用流密钥下进行加密。
   特别是，这包括服务器为响应客户端Certificate 和CertificateVerify消息而发送的
   任何警报。
 
4.5.  End of Early Data
 
      struct {} EndOfEarlyData;
 
   如果服务器在EncryptedExtensions中发送了“early_data”扩展，则客户端必须在
   接收服务器 Finished 后发送 EndOfEarlyData 消息。如果服务器不在
   EncryptedExtensions中发送“early_data”扩展，则客户端不能发送EndOfEarlyData
   消息。该消息指示所有 0-RTT application_data 消息(如果有的话)都已被传输，并且
   以下记录在握手业务密钥下受到保护。服务器不能发送此消息，接收此消息的客户端必须终止
   连接，并发出“unexpected_message”警报。此消息在从
   client_early_traffic_secret派生的密钥下加密。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 


 
4.6.  Post-Handshake Messages
 
   TLS还允许在主握手之后发送其他消息。这些消息使用握手内容类型，并在适当的应用流
   密钥下加密。
 
4.6.1.  New Session Ticket Message
 
   在服务器接收到客户端 Finished 消息后的任何时间，它都可以发送NewSessionTicket
   消息。该消息在票据值和从恢复主秘密导出的秘密PSK之间创建唯一的关联(参见第7节)。
 
   客户端可以通过在其ClientHello(第4.2.11节)中的“pre_shared_key”扩展中包含
   票证值，从而将此PSK用于未来的握手。服务器可以在单个连接上发送多个票证，可以在连接
   之后立即发送，也可以在特定事件之后发送(参见附录C.4)。例如，服务器可能在握手后
   身份验证后发送新票证，以便封装额外的客户端身份验证状态。多张票证对客户有多种用途，
   包括：
 
   -  打开多个并行HTTP连接。
 
   -  通过(例如)Happy Eyeballs[RFC8305]或相关技术跨接口和寻址系列执行连接竞速。
 
   任何票证只能使用与用于建立原始连接的KDF哈希算法相同的密码套件恢复。
 
   仅当新的SNI值对原始会话中提供的服务器证书有效时，客户端才能恢复，并且仅当SNI值
   与原始会话中使用的SNI值匹配时才应恢复。后者是一种性能优化：通常，没有理由期望单个
   证书覆盖的不同服务器能够接受彼此的票证；因此，在这种情况下尝试恢复将浪费单次使用
   票证。如果提供了这样的指示(外部或通过任何其他方式)，则客户端可以使用不同的SNI值
   恢复。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   在恢复时，如果向调用应用程序报告SNI值，则实现必须使用在恢复ClientHello中发送的
   值，而不是在前一个会话中发送的值。请注意，如果服务器实现拒绝具有不同SNI值的所有
   PSK身份，则这两个值总是相同的。
 
   注意：虽然恢复主密钥取决于客户端的第二波发送，但不请求客户端身份验证的服务器可以
   独立计算成绩单的剩余部分，然后在发送完成后立即发送 NewSessionTicket ，而不是
   等待客户端完成。例如，在期望客户端并行打开多个TLS连接并且将受益于恢复握手的减少
   的开销的情况下，这可能是适当的。
 
      struct {
          uint32 ticket_lifetime;
          uint32 ticket_age_add;
          opaque ticket_nonce&lt;0..255&gt;;
          opaque ticket&lt;1..2^16-1&gt;;
          Extension extensions&lt;0..2^16-2&gt;;
      } NewSessionTicket;
 
   ticket_lifetime:  表示从票证签发时起按网络字节顺序以秒为单位的32位无符号整数
      的生存期。服务器不得使用任何大于604800秒(7天)的值。值为零表示应立即丢弃票证。
      客户端缓存票证的时间不得超过7天，无论ticket_lifetime如何，并且可以根据本地
      策略提前删除票证。服务器可能会将票证视为有效期比ticket_lifetime中规定的时间
      更短的一段时间。
 
   ticket_age_add:  安全生成的随机32位值，用于模糊客户端包含在“pre_shared_key”
      扩展中的票证的年龄。将客户端票证年龄与此值模2^32相加，以获得由客户端传输的值。
      服务器必须为它发送的每个票证生成一个新值。
 
   ticket_nonce:  在此连接上签发的所有票证中唯一的每次票值。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   ticket:  用作 PSK 标识的票证的值。 票证本身是一个字符串。 它可能是数据库查找
      密钥，也可以是自加密和自验证的值。
 
   extensions:  票据的一组扩展值。“扩展”格式在4.2节中定义。客户端必须忽略无法
      识别的扩展名。
 
   目前为NewSessionTicket定义的唯一扩展名是“early_data”，表示票据可用于发送
   0-RTT数据(第4.2.10节)。它包含下列值：
 
   max_early_data_size:  客户端在使用此票证时允许发送的最大0-RTT数据量，以字节
      为单位。仅计算应用数据有效载荷(即，明文而不是填充或内部内容类型字节)。接收到
      超过max_arly_data_size字节的0-RTT数据的服务器应终止连接，并发出
      “unexpected_message”警报。请注意，由于缺少加密材料而拒绝早期数据的服务器
      将无法区分填充与内容，因此客户端不应依赖能够在早期数据记录中发送大量填充。
 
   与票证关联的PSK计算如下：
 
       HKDF-Expand-Label(resumption_master_secret,
                        "resumption", ticket_nonce, Hash.length)
 
   由于Ticket_Nonce值对于每个NewSessionTicket消息是不同的，因此将为每个票证
   派生不同的PSK。
 
   请注意，原则上可以继续颁发新票证，从而无限期地延长最初派生自初始非 PSK 握手
   （很可能与对等方证书相关）的密钥材料的生存期。 建议实施对此类密钥材料的总使用寿命
   进行限制;这些限制应考虑对等方证书的生存期、干预吊销的可能性以及对等方联机证书验证
   签名后的时间。
 
4.6.2.  Post-Handshake Authentication
 
   当客户端发送了“post_handshake_auth”扩展(参见第4.2.6节)时，服务器可以在握手
   完成后的任何时间通过发送CertificateRequest消息来请求客户端身份验证。客户端
   必须使用适当的身份验证消息进行响应(参见第4.4节)。如果客户端选择进行身份验证，则
   必须发送Certificate、CertificateVerify和Finished。如果拒绝，则必须发送
   不包含证书的 Certificate 消息，后跟 Finished 。给定响应的所有客户端消息必须
   连续出现在线路上，不能插入其他类型的消息。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 






   如果客户端接收CertificateRequest消息而没有发送“post_handshak_auth”扩展，
   则必须发送“unexpected_message”致命警报。
 
   注意：因为客户端身份验证可能涉及提示用户，所以服务器必须为一些延迟做好准备，包括
   在发送CertificateRequest和接收响应之间接收任意数量的其他消息。此外，紧密接连
   收到多个CertificateRequest的客户端可能会以与收到它们的顺序不同的顺序响应它们
   (certificate_request_context值允许服务器消除响应的歧义)。
 


4.6.3.  密钥和初始化向量更新
 
   KeyUpdate握手消息用于指示发送方正在更新其发送的加密密钥。该消息可以在发送
   Finished 消息之后由任何一个对等体发送。在接收完成消息之前接收到KeyUpdate消息
   的实现必须终止连接，并发出“unexpected_message”警报。发送KeyUpdate消息后，
   发送方应使用新密钥发送其所有数据，按第7.2节所述计算。在接收到KeyUpdate后，
   接收方必须更新其接收密钥。
 
      enum {
          update_not_requested(0), update_requested(1), (255)      } KeyUpdateRequest;
 
      struct {
          KeyUpdateRequest request_update;
      } KeyUpdate;
 
   request_update:  指示KeyUpdate的接收者是否应使用自己的KeyUpdate进行响应。
      如果一个实现接收到任何其他值，它必须终止连接并发出“illegal_parameter”警报。
 
   如果request_update 字段设置为 “update_requested”，则在发送其下一个应用数据
   记录之前，接收方必须发送自己的带有request_update 设置为
   “update_not_requested”的KeyUpdate。此机制允许任何一方强制对整个连接进行
   更新，但会导致接收多个KeyUpdates的实现在静默状态下使用单个更新进行响应。请注意，
   在发送request_update设置为“update_request”的KeyUpdate和接收对等体的
   KeyUpdate之间，实现可能会接收任意数量的消息，因为这些消息可能已经在传输中。然而，
   因为发送和接收密钥是从独立的数据密钥中派生出来的，所以保留接收数据密钥不会威胁到
   在发送方更改密钥之前发送的数据的前向保密性。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 




 
   如果实现独立地发送自己的KeyUpdates，request_update设置为“update_request”，
   并且它们在发送中交叉，那么每一端也将发送响应，结果是每一端增加两代。
 
   发送方和接收方都必须使用旧密钥对其KeyUpdate消息进行加密。此外，在接受用新密钥
   加密的任何消息之前，双方必须强制接收到具有旧密钥的KeyUpdate。如果不这样做，则
   可能允许邮件截断攻击。
 
5.  记录协议
 
   TLS记录协议接收要传输的消息，将数据分段为可管理的块，保护记录，并传输结果。对
   接收到的数据进行验证、解密、重新组装，然后将其传递给更高级别的客户端。
 
   TLS记录是分类的，这允许在同一记录层上多路复用多个更高级别的协议。本文档指定了
   四种内容类型：握手、application_data、alert和change_cipher_spec。
   change_cipher_spec记录仅用于兼容性目的(参见附录D.4)。
 
   在发送或接收第一个 ClientHello 消息之后以及在接收到对等体的 Finished 消息
   之前的任何时间，实现可以接收由单字节值 0x01 组成的类型 change_cipher_spec 的
   未加密记录，并且必须简单地丢弃它而无需进一步处理。请注意，此记录可能出现在握手时
   实现预期受保护记录的某一点，因此有必要在尝试解除记录保护之前检测此条件。接收任何
   其他 change_cipher_spec 值或接收到受保护的 change_cipher_spec 记录的实现
   必须中止握手，并发出“unexpected_message”警报。如果实现检测到
   change_cipher_spec 记录在第一个 ClientHello 消息之前或对等体的 Finished 
   消息之后接收，则必须将其视为意外的记录类型(尽管无状态服务器可能无法将这些情况与
   允许的情况区分开来)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   实现不得发送本文档中未定义的记录类型，除非通过某些扩展进行协商。如果TLS实现接收
   到意外的记录类型，则它必须终止连接并发出“unexpected_message”警报。新的记录
   内容类型值由IANA在TLS Content Type注册表中分配，如第11节所述。
 
5.1.  记录层
 
   记录层将信息块分片成TLSPlaintext记录，这些记录以2^14字节或更少的块为单位承载
   数据。消息边界的处理方式取决于底层的contentType。任何未来的内容类型都必须指定
   适当的规则。请注意，这些规则比TLS 1.2中强制实施的规则更严格。
 
   握手消息可以合并到单个TLSPlaintext记录中，也可以在多个记录之间进行分段，前提是：
 
   -  握手消息不得与其他记录类型交错。也就是说，如果握手消息被拆分为两个或多个记录，
      则它们之间不能有任何其他记录。
 
   -  握手消息不得跨越密钥更改。实现必须验证紧接在键更改之前的所有消息是否与记录
      边界对齐；如果不是，则它们必须终止连接，并发出“unexpected_message”警报。
      因为ClientHello、EndOfEarlyData、ServerHello、Finish和KeyUpdate消息
      可以紧跟在键更改之前，所以实现必须按照记录边界发送这些消息。
 
   实现不能发送握手类型的零长度片段，即使这些片段包含填充。
 
   报警消息(第6节)不能在记录之间分割，并且不能将多个报警消息合并到单个
   TLSPlaintext记录中。换句话说，具有Alert类型的记录必须恰好包含一条消息。
 
   应用程序数据消息包含对TLS不透明的数据。应用程序数据消息始终受到保护。可以发送应用
   数据的零长度片段，因为它们作为流量分析对策是潜在有用的。应用程序数据片段可以跨多个
   记录拆分或合并为单个记录。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
      enum {
          invalid(0),
          change_cipher_spec(20),
          alert(21),
          handshake(22),
          application_data(23),
          (255)
      } ContentType;
 
      struct {
          ContentType type;
          ProtocolVersion legacy_record_version;
          uint16 length;
          opaque fragment[TLSPlaintext.length];
      } TLSPlaintext;
 
   type:  用于处理包含的片段的更高级别的协议。
 
   legacy_record_version:  对于由TLS 1.3实现生成的除初始ClientHello之外的
      所有记录(即，在HelloRetryRequest之后未生成的记录)，必须将其设置为0x0303，
      其中出于兼容性目的，也可以设置为0x0301。此字段已弃用，在任何情况下都必须忽略。
      在某些情况下，以前版本的TLS会在此字段中使用其他值。
 
   length:  以下TLSPlaintext.Fragment的长度(以字节为单位)。长度不能超过2^14
      字节。接收到超过此长度的记录的端点必须使用“record_overflow”警报终止连接。
 
   fragment:  正在传输的数据。这个值是透明的，并且被视为一个独立的块，由type字段
      指定的更高级别的协议来处理。
 
   本文档介绍TLS 1.3，它使用版本0x0304。此版本值是历史的，源自对TLS 1.0使用
   0x0301和对SSL 3.0使用0x0300。为了最大化向后兼容性，包含初始ClientHello的
   记录应该具有版本0x0301(反射TLS 1.0)，而包含第二个ClientHello或ServerHello
   的记录必须具有版本0x0303(反射TLS 1.2)。在协商TLS的先前版本时，端点遵循附录D中
   提供的程序和要求。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   当尚未启用记录保护时，直接将TLSPlaintext结构写入导线上。一旦开始记录保护，
   TLSPlaintext记录就会被保护并发送，如下节所述。请注意，应用程序数据记录不得写入
   未受保护的线路(详情请参阅第2节)。
 
5.2.  记录负载保护
 
   记录保护功能将TLSPlaintext结构转换为TLSCiphertext结构。去保护功能反转该过程。
   在TLS 1.3中，与以前版本的TLS不同，所有密码都被建模为“带关联数据的身份验证加密”
   (AEAD)[RFC5116]。EAAD函数提供统一的加密和认证操作，其将明文转换成认证的密文，
   然后再返回。每个加密记录都由一个明文头和一个加密体组成，加密体本身包含一个类型和
   可选的填充。
 
      struct {
          opaque content[TLSPlaintext.length];
          ContentType type;
          uint8 zeros[length_of_padding];
      } TLSInnerPlaintext;
 
      struct {
          ContentType opaque_type = application_data; /* 23 */
          ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */
          uint16 length;
          opaque encrypted_record[TLSCiphertext.length];
      } TLSCiphertext;
 
   content:  TLSPlaintext.Fragment值，包含握手或警报消息的字节编码，或要发送
      的应用程序数据的原始字节。
 
   type:  包含记录内容类型的TLSPlaintext.type值。
 
   zeros:  零值字节的任意长度游程可能出现在类型字段之后的明文中。这为发件人提供了
      将任何TLS记录填充选定数量的机会，只要总数保持在记录大小限制内即可。更多细节
      见5.4节。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   opaque_type:  TLSCiphertext记录的外部opaque_type 字段始终设置为值23
      (APPLICATION_DATA)，以便与习惯于解析以前版本的TLS的中间件保持向外兼容性。
      解密后，可以在TLSInnerPlaintext.type中找到记录的实际内容类型。
 
   legacy_record_version:  Legacy_Record_Version字段始终为0x0303。TLS 1.3
      TLSCiphertext直到TLS 1.3被协商后才会生成，因此在可能接收到其他值的地方没有
      历史兼容性问题。请注意，握手协议(包括ClientHello和ServerHello消息)验证协议
      版本，因此此值是冗余的。
 
   length:  以下TLSCiphertext.encrypted_record 的长度(以字节为单位)，它是
      内容和填充的长度之和，加上内部内容类型的1长度，再加上由aead算法添加的任何
      扩展。长度不能超过2^14+256字节。接收到超过此长度的记录的端点必须使用
      “record_overflow”警报终止连接。
 
   encrypted_record:  序列化的TLSInnerPlaintext结构的aead加密形式。
 
   AEAD 算法将单个密钥、nonce、纯文本和"附加数据"作为输入包含在身份验证检查中，
   如 [RFC5116] 第 2.1 节所述。 密钥是client_write_key 或
   server_write_key，nonce派生自序列号和client_write_iv 或server_write_iv 
   （请参阅第 5.3 节），其他数据输入是记录标头。
 
   I.e.,
 
      additional_data = TLSCiphertext.opaque_type ||
                        TLSCiphertext.legacy_record_version ||
                        TLSCiphertext.length
 
   AEAD算法的明文输入是编码的TLSInnerPlaintext结构。数据密钥的推导在7.3节中定义。
 
   AEAD输出由来自AEAD加密操作的密文输出组成。由于包含TLSInnerPlaintext.type和
   发送方提供的任何填充，明文的长度大于相应的TLSPlaintext.length。AEAD输出的
   长度通常将大于明文，但数量随AEAD算法而变化。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   由于密码可能包含填充，因此开销的量可以随明文的不同长度而变化。象征性的
 
      AEADEncrypted =
          AEAD-Encrypt(write_key, nonce, additional_data, plaintext)
 
   TLSCiphertext的 encrypted_record 字段设置为AEADEncrypted。
 
   为了解密和验证，算法以密钥、随机数、附加数据和AEADEncrypted值作为输入。输出
   要么是明文，要么是指示解密失败的错误。没有单独的完整性检查。象征性的
 
      plaintext of encrypted_record =
          AEAD-Decrypt(peer_write_key, nonce,
                       additional_data, AEADEncrypted)
 
   如果解密失败，接收方必须终止连接并发出“bad_record_mac”警报。
 
   TLS 1.3中使用的AEAD算法不得产生大于255个八位组的扩展。从其对等端接收
   TLSCiphertext.length大于2^14+256个八位字节的记录的端点必须使用
   “record_overflow”警报终止连接。此限制由最大TLSInnerPlaintext长度2^14个
   八位字节+ContentType的1个八位字节+255个八位字节的最大aead扩展得出。
 
5.3.  Per-Record Nonce
 
   64位序列号被单独维护，用于读取和写入记录。在读取或写入每个记录后，适当的序列号
   递增1。在连接开始时和每当密钥改变时，每个序列号都被设置为零；在特定业务下加密
   传输的第一个记录必须使用序列号0。
 
   因为序列号的大小是64位，所以它们不应该换行。如果TLS实现需要包装序列号，则必须
   重新设置密钥(第4.6.3节)或终止连接。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   每个 AEAD 算法将为每个记录的随机数指定可能的长度范围，从 N_MIN 字节到
   输入的 N_MAX 字节 [RFC5116]。  对于 AEAD 算法， TLS每条记录随机数的
   长度被（iv_length）设置为 8 字节和 N_MIN 中较大的一个（参见 [RFC5116]，
   第 4 节）。 N_MAX 小于 8 字节的 AEAD 算法不得与 TLS 一起使用。 AEAD 构造的
   每个记录的随机数格式如下：
 
   1.  64位记录序列号按网络字节顺序编码，左侧补零至iv_length。
 
   2.  填充的序列号与静态client_write_iv或server_write_iv进行异或
       (取决于角色)。
 
   得到的数量(长度为iv_length)用作每条记录的随机数。
 
   注意：这与TLS 1.2中的构造不同，TLS 1.2中指定了部分显式的nonce。
 
5.4.  记录填充
 
   可以填充所有加密的TLS记录以扩大TLSCiphertext的大小。这允许发送者对观察者隐藏
   流量的大小。
 
   当生成TLSCiphertext记录时，实现可以选择填充。未填充的记录只是填充长度为零的
   记录。填充是加密前附加到contentType字段的零值字节字符串。在加密之前，实现必须
   将填充八位组设置为全零。
 
   如果发送者需要，应用数据记录可以包含零长度的TLSInnerPlaintext.content。这
   允许在活动的存在或不存在可能是敏感的上下文中生成合理大小的覆盖流量。实现不得发送
   长度为零的TLSInnerPlaintext.content的握手和警报记录；如果接收到这样的消息，
   则接收实现必须终止连接，并发出“unexpected_message”警报。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   发送的填充由记录保护机制自动验证；在成功解密TLSCiphertext.Encrypted_Record
   后，接收实现从末尾向开始扫描字段，直到找到非零的二进制八位数。这个非零的二进制
   八位数是消息的内容类型。之所以选择这种填充方案，是因为它允许以任意大小(从零到TLS
   记录大小限制)填充任何加密的TLS记录，而不引入新的内容类型。该设计还强制实施全零
   填充八位组，这允许快速检测填充错误。
 
   实现必须将其扫描限制为从aead解密返回的明文。如果接收实现在明文中找不到非零的
   二进制八位数，则它必须终止连接，并发出“unexpected_message”警报。
 
   填充的存在不会改变总体记录大小限制：完整编码的TLSInnerPlaintext不得超过
   2^14+1个八位字节。如果减少了最大片段长度-例如，通过[RFC8449]的
   record_size_limit扩展-那么减少的限制适用于完整明文，包括内容类型和填充。
 
   选择建议何时填充以及填充多少的填充策略是一个复杂的主题，并且超出了本规范的范围。
   如果TLS之上的应用层协议有自己的填充，则最好在应用层内填充应用数据TLS记录。不过，
   加密握手或警报记录的填充仍必须在TLS层处理。稍后的文档可以通过TLS扩展或一些其他
   手段定义填充选择算法或定义填充策略请求机制。
 
5.5.  密钥使用限制
 
   在给定的密钥集下可以安全加密的纯文本数量有限制。 [AEAD-LIMITS] 在假定基础
   基元（AES 或 ChaCha20）没有弱点的情况下，对这些限制进行了分析。实现应在达到这些
   限制之前执行第 4.6.3 节中描述的密钥更新。
 
   对于AES-GCM，在给定连接上最多可以加密2^24.5条全尺寸记录(约2400万条)，同时保持
   大约2^-57的安全裕度，以保证身份验证加密(AE)安全性。对于CHACH20/Poly1305，
   记录序列号将在达到安全限值之前自动换行。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
6.  警报协议
 
   TLS提供警报内容类型以指示关闭信息和错误。与其他消息一样，警报消息按照当前连接状态
   进行加密。
 
   警报消息传达警报的描述和旧字段，该字段传达TLS早期版本中消息的严重性级别。警报分为
   两类：关闭警报和错误警报。在TLS 1.3中，严重性隐含在正在发送的警报类型中，并且可以
   安全地忽略“level”字段。“close_notify”警报用于指示连接的一个方向有序关闭。在
   接收到这样的警报时，TLS实现应该向应用程序指示数据结束。
 
   错误警报指示连接的中止关闭(参见第6.2节)。在接收到错误警报后，TLS实现应向应用程序
   指示错误，并且不得允许在连接上发送或接收任何进一步的数据。服务器和客户端必须忘记
   在失败的连接中建立的密码值和密钥，与会话票证关联的PSK除外，如果可能，应将其丢弃。
 
   6.2节中列出的所有警报必须使用AlertLevel=FATAL发送，并且在收到时必须被视为错误
   警报，而不管消息中的警报等级是什么。未知警报类型必须视为错误警报。
 
   注意：TLS定义了两个通用警报(参见第6节)，用于解析消息失败时使用。接收不能根据
   语法解析的消息的对等体(例如，具有超出消息边界的长度或包含超出范围的长度)必须
   用“decode_error”警报终止连接。接收到语法上正确但语义上无效的消息的对等体
   (例如，p-1的DHE共享或无效的枚举)必须以“illegal_parameter”警报终止连接。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
      enum { warning(1), fatal(2), (255) } AlertLevel;
 
      enum {
          close_notify(0),
          unexpected_message(10),
          bad_record_mac(20),
          record_overflow(22),
          handshake_failure(40),
          bad_certificate(42),
          unsupported_certificate(43),
          certificate_revoked(44),
          certificate_expired(45),
          certificate_unknown(46),
          illegal_parameter(47),
          unknown_ca(48),
          access_denied(49),
          decode_error(50),
          decrypt_error(51),
          protocol_version(70),
          insufficient_security(71),
          internal_error(80),
          inappropriate_fallback(86),
          user_canceled(90),
          missing_extension(109),
          unsupported_extension(110),
          unrecognized_name(112),
          bad_certificate_status_response(113),
          unknown_psk_identity(115),
          certificate_required(116),
          no_application_protocol(120),
          (255)
      } AlertDescription;
 
      struct {
          AlertLevel level;
          AlertDescription description;
      } Alert;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
6.1.  关闭警报
 
   客户端和服务器必须共享连接即将结束的信息，以避免截断攻击。
 
   close_notify:  此警报通知收件人发件人将不再在此连接上发送任何消息。必须忽略
      在接收到关闭警报之后接收到的任何数据。
 
   user_canceled:  此警报通知收件人发送方出于某种与协议故障无关的原因取消握手。
      如果用户在握手完成后取消操作，则通过发送“close_notify”关闭连接更合适。
      此警报后应紧跟“close_notify”。此警报通常具有AlertLevel=Warning。
 





   任何一方都可以通过发送“close_notify”警报来启动连接的写入端的关闭。必须忽略在
   接收到关闭警报之后接收到的任何数据。如果在“close_notify”之前接收到传输层关闭，
   则接收方无法知道发送的所有数据都已收到。
 
   每一方必须在关闭其连接的写入端之前发送“close_notify”警报，除非它已经发送了一些
   错误警报。这对连接的读取端没有任何影响。请注意，这与TLS 1.3之前的TLS版本不同，
   在TLS 1.3之前的版本中，要求实现通过丢弃挂起的写入并立即发送自己的
   “close_Notify”警报来对“close_notification”作出反应。之前的要求可能会导致
   读取侧的截断。在关闭连接的读取端之前，双方不需要等待接收“close_notify”警报，
   尽管这样做会引入截断的可能性。
 




   如果使用TLS的应用协议规定在关闭TLS连接后可以在底层传输上携带任何数据，则在向
   应用层指示数据结束之前，TLS实现必须接收“close_notify”警报。本标准的任何部分都
   不应用于规定TLS的使用配置文件管理其数据传输的方式，包括何时打开或关闭连接。
 
   注意：假设关闭连接的写入端在销毁传输之前可靠地传递挂起的数据。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
6.2.  错误警报
 
   TLS中的错误处理非常简单。当检测到错误时，检测方向其对等方发送消息。在发送或接收到
   致命警报消息时，双方必须立即关闭连接。
 
   每当实现遇到致命错误条件时，它都应该发送适当的致命警报，并且必须在不发送或接收任何
   其他数据的情况下关闭连接。在本说明书的其余部分中，当在没有特定警报的情况下使用短语
   “终止连接”和“中止握手”时，意味着实现应该发送如下描述所指示的警报。短语
   “使用X警报终止连接”和“用X警报中止握手”意味着如果实现发送任何警报，则必须发送警报
   X。从TLS 1.3开始，本节中定义的所有警报以及所有未知警报都被普遍认为是致命的
   (参见第6节)。实现应该提供一种方便记录警报发送和接收的方法。
 
 






  已定义了以下错误警报:
 
   unexpected_message:  收到不适当的消息（例如，错误的握手消息、过早的应用程序
      数据等）。在正确实现之间的通信中，绝不应观察到此警报。
 


   bad_record_mac:  如果收到无法解除保护的记录，则返回此警报。因为aead算法结合了
      解密和验证，并且还为了避免旁道攻击，所以此警报用于所有解除保护失败。在正确实现
      的通信中绝不应观察到此警报，除非网络中的消息已损坏。
 



   record_overflow:  收到长度超过2^14+256字节的TLSCiphertext记录，或解密为
      超过2^14字节(或其他协商限制)的TLSPlaintext记录的记录。在正确实现的通信中
      绝不应观察到此警报，除非网络中的消息已损坏。
 


   handshake_failure:  收到“handshake_failure”警报消息表明，发送方在给定可用
      选项的情况下无法协商一组可接受的安全参数。

 
   bad_certificate:  证书已损坏，包含未正确验证的签名等。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   unsupported_certificate:  证书的类型不受支持。
 
   certificate_revoked:  证书被其签名者吊销。
 
   certificate_expired:  证书已过期或当前无效。
 
   certificate_unknown:  在处理证书的过程中出现了一些其他(未指定的)问题，
      使其不可接受。
 
   illegal_parameter:  握手中的某个字段不正确或与其他字段不一致。此警报用于符合
      正式协议语法但其他方面不正确的错误。
 


   unknown_ca:  收到有效的证书链或部分链，但未接受证书，因为找不到CA证书或无法与
      已知的信任锚点匹配。
 


   access_denied:  收到有效的证书或PSK，但当应用访问控制时，发送方决定不继续协商。
 

   decode_error:  无法解码消息，因为某些字段超出指定范围或消息长度不正确。此警报
      用于消息不符合正式协议语法的错误。在正确实现之间的通信中绝不应观察到此警报，
      除非网络中的消息已损坏。
 


   decrypt_error:  握手(非记录层)加密操作失败，包括无法正确验证签名或验证已完成
      的消息或PSK绑定器。
 

   protocol_version:  对等体尝试协商的协议版本被识别，但不受支持(参见附录D)。

 
   insufficient_security:  由于服务器需要比客户端支持的参数更安全的参数，在协商
      失败时返回，而不是返回“handshake_failure”。
 
   internal_error:  与对等体或协议的正确性无关的内部错误(如内存分配失败)使其无法
      继续。
 
   inappropriate_fallback:  由服务器发送，以响应来自客户端的无效连接重试尝试
      (参见[RFC7507])。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   missing_extension:  由接收握手消息的端点发送，该握手消息不包含对于所提供的
      TLS版本或其他协商参数强制发送的扩展。
 
   unsupported_extension:  由接收任何握手消息的端点发送，该握手消息包含已知禁止
      包含在给定握手消息中的扩展，或者包括ServerHello或证书中未首先在相应
      ClientHello或CertificateRequest中提供的任何扩展。
 
   unrecognized_name:  当不存在由客户端通过“server_name”扩展提供的名称标识的
      服务器时，由服务器发送(参见[RFC6066])。
 
   bad_certificate_status_response:  当服务器通过“status_request”扩展提供
      无效或不可接受的OCSP响应时，由客户端发送(参见[RFC6066])。
 



   unknown_psk_identity:  当需要PSK密钥建立但客户端没有提供可接受的PSK标识时，
      服务器发送。发送此警报是可选的；服务器可能会选择发送“decrypt_error”警报，
      以仅指示无效的PSK身份。
 
   certificate_required:  当需要客户端证书但客户端没有提供任何证书时，服务器
      发送。
 
   no_application_protocol:  当“application_layer_protocol_negotiation”
      扩展仅通告服务器不支持的协议时，由服务器发送(参见[RFC7301])。
 
   新的警报值由IANA分配，如第11节所述。
 
7.  密码计算
 
   TLS握手建立一个或多个输入密码，这些输入密钥被组合以创建实际工作密钥材料，如下
   所述。密钥导出过程合并了输入密码和握手记录。注意，因为握手记录包括来自Hello消息
   的随机值，所以任何给定的握手都将具有不同的业务密码，即使使用相同的输入密码，当
   相同的PSK用于多个连接时也是如此。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
7.1.  密钥表
 
   密钥派生过程利用为HKDF[RFC5869]定义的HKDF-Extract和HKDF-Expand函数，以及
   下面定义的函数：
 
       HKDF-Expand-Label(Secret, Label, Context, Length) =
            HKDF-Expand(Secret, HkdfLabel, Length)
 
       Where HkdfLabel is specified as:
 
       struct {
           uint16 length = Length;
           opaque label&lt;7..255&gt; = "tls13 " + Label;
           opaque context&lt;0..255&gt; = Context;
       } HkdfLabel;
 
       Derive-Secret(Secret, Label, Messages) =
            HKDF-Expand-Label(Secret, Label,
                              Transcript-Hash(Messages), Hash.length)
 
   Transcript-Hash 和 HKDF 使用的哈希函数是加密套件哈希算法。hash.length是其
   输出长度(以字节为单位)。消息是所指示的握手消息的串联，包括握手消息类型和长度字段，
   但不包括记录层报头。请注意，在某些情况下，零长度上下文(由""表示)被传递给
   HKDF-Expand-Label。本文档中指定的标签都是ASCII字符串，不包括尾部的NUL字节。
 
   注意：对于常用的散列函数，任何超过12个字符的标签都需要额外的散列函数迭代来计算。
   本说明书中的标签均已选择适合此限制。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   使用HKDF-Extract和Derve-Secret函数从两个输入密码派生密钥。添加新密码的一般
   模式是使用HKDF-Extract，其中Salt是当前密码状态，输入密钥材料(IKM)是要添加的
   新密码。在此版本的TLS 1.3中，两个输入密码是：
 
   -  PSK (外部建立的预共享密钥，或从前一个连接的resumption_master_secret 值
      派生而来的预共享密钥)。
 
   -  (EC)DHE 共享密钥 (Section 7.4)
 
   这会产生一个完整的密钥导出计划，如下图所示。在此图中，以下格式约定适用：
 
   -  HKDF-Extract绘制为采用顶部的Salt参数和左侧的IKM参数，其输出位于底部，输出的
      名称位于右侧。
 
   -  Derive-Secret 的Secret参数由传入箭头指示。例如，Early Secret是用于生成
      client_early_traffic_secret。
 
   -  "0" 表示设置为零的Hash.length字节字符串。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
             0
             |
             v
   PSK -&gt;  HKDF-Extract = Early Secret
             |
             +-----&gt; Derive-Secret(., "ext binder" | "res binder", "")
             |                     = binder_key
             |
             +-----&gt; Derive-Secret(., "c e traffic", ClientHello)
             |                     = client_early_traffic_secret
             |
             +-----&gt; Derive-Secret(., "e exp master", ClientHello)
             |                     = early_exporter_master_secret
             v
       Derive-Secret(., "derived", "")
             |
             v
   (EC)DHE -&gt; HKDF-Extract = Handshake Secret
             |
             +-----&gt; Derive-Secret(., "c hs traffic",
             |                     ClientHello...ServerHello)
             |                     = client_handshake_traffic_secret
             |
             +-----&gt; Derive-Secret(., "s hs traffic",
             |                     ClientHello...ServerHello)
             |                     = server_handshake_traffic_secret
             v
       Derive-Secret(., "derived", "")
             |
             v
   0 -&gt; HKDF-Extract = Master Secret
             |
             +-----&gt; Derive-Secret(., "c ap traffic",
             |                     ClientHello...server Finished)
             |                     = client_application_traffic_secret_0
             |
             +-----&gt; Derive-Secret(., "s ap traffic",
             |                     ClientHello...server Finished)
             |                     = server_application_traffic_secret_0
             |
             +-----&gt; Derive-Secret(., "exp master",
             |                     ClientHello...server Finished)
             |                     = exporter_master_secret
             |
             +-----&gt; Derive-Secret(., "res master",
                                   ClientHello...client Finished)
                                   = resumption_master_secret</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   这里的一般模式是，图的左侧显示的密码只是没有上下文的原始熵，而右侧的密码包括握手
   上下文，因此可以用于在没有其他上下文的情况下导出工作密钥。请注意，即使使用相同的
   密码，对Derve-Secret的不同调用也可能采用不同的消息参数。在0-RTT交换中，
   Derve-Secret用四个不同的转录本调用；在仅1-RTT的交换中，它用三个不同的转录本
   调用。
 
   如果给定的密码不可用，则使用由设置为零的Hash.length字节字符串组成的0值。请注意，
   这并不意味着跳过轮次，因此如果PSK不在使用中，则Early Secret仍将是
   HKDF-Extract(0，0)。对于binder_key的计算，标签是用于外部PSK(在TLS之外提供的
   那些)的“ext binder”和用于恢复PSK(那些被提供为先前握手的恢复主秘密的PSK)的
   “res binder”。不同的标签防止用一种类型的PSK替换另一种类型的PSK。
 
   根据服务器最终选择的PSK，有多个潜在的早期密码值。客户端将需要为每个潜在的PSK计算
   一次；如果没有选择PSK，则需要计算对应于零PSK的Early Secret。
 
   一旦计算了从给定秘密得到的所有值，该秘密就应该被擦除。
 
7.2.  更新 Traffic Secrets
 
   一旦握手完成，任何一方都可以使用第4.6.3节中定义的KeyUpdate握手消息更新其发送
   Traffic Secrets。下一代数据密钥的计算方法是：如本节所述，从
   client_/server_application_traffic_secret_N生成
   client_/server_application_traffic_secret_N+1，然后如第7.3节所述重新推导
   Traffic Secrets。
 
   下一代 application_traffic_secret 的计算方式为：
 
       application_traffic_secret_N+1 =
           HKDF-Expand-Label(application_traffic_secret_N,
                             "traffic upd", "", Hash.length)
 
   一旦计算出client_/server_application_traffic_secret_N+1及其关联的
   traffic_secret，实施应该删除client_/server_application_traffic_secret_N
   及其关联的traffic_secret。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
7.3.  Traffic Key 计算
 
   业务密钥材料由以下输入值生成：
 
   -  A secret value
 
   -  目的值，指示正在生成的特定值。
 
   -  生成的密钥长度。
 
   使用以下方法从输入的业务密码值生成业务密钥材料：
 
   [sender]_write_key = HKDF-Expand-Label(Secret, "key", "", key_length)
   [sender]_write_iv  = HKDF-Expand-Label(Secret, "iv", "", iv_length)
 
   [发送方]表示发送方。下表显示了每种记录类型的Secret值。
 
       +-------------------+---------------------------------------+
       | Record Type       | Secret                                |
       +-------------------+---------------------------------------+
       | 0-RTT Application | client_early_traffic_secret           |
       |                   |                                       |
       | Handshake         | [sender]_handshake_traffic_secret     |
       |                   |                                       |
       | Application Data  | [sender]_application_traffic_secret_N |
       +-------------------+---------------------------------------+
 
   每当基础密钥改变时(例如，当从握手改变为应用数据密钥时或在密钥更新时)，重新计算
   所有业务密钥材料。
 
7.4.  (EC)DHE 共享密码计算
 
7.4.1.  有限域 Diffie-Hellman
 
   对于有限域组，执行常规的 Diffie-Hellman[DH76] 计算。协商的密钥(Z)通过以大端
   字节顺序形式编码转换为字节串，并用零填充，直到素数的大小。该字节串用作如上所述的
   密钥调度中的共享秘密。
 
   请注意，此构造与以前版本的TLS不同，TLS删除了前导零。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
7.4.2.  Elliptic Curve Diffie-Hellman
 
   对于secp256r1、secp384r1和secp521r1，ECDH计算(包括参数和密钥生成以及
   共享秘密计算)是根据[IEEE1363]使用身份图作为密钥导出函数(KDF)的ECKAS-DH1方案
   来执行的，使得共享秘密是表示为八位字节串的ECDH共享秘密椭圆曲线点的x坐标。请
   注意，FE2OSP(Field Element To Octet String Conversion Primitive)输出
   的这个八位字节字符串(IEEE 1363术语中的“Z”)对于任何给定字段都具有恒定的长度；
   在此八位字节字符串中找到的前导零不得被截断。
 
   (请注意，这种身份KDF的使用是技术性的。完整的情况是，ECDH与非平凡的KDF一起使用，
   因为TLS不直接将此密码用于计算其他密码以外的任何事情。)。
 
   对于X25519和X448，ECDH计算如下：
 
   -  放入KeyShareEntry.key_exchange结构的公钥是将ECDH标量乘法函数应用于适当
      长度的密钥(放入标量输入)和标准公共基点(放入u坐标点输入)的结果。
 
   -  ECDH共享密钥是将ECDH标量乘法函数应用于密钥(进入标量输入)和对等体的公钥
      (进入u坐标点输入)的结果。输出是原始的，没有任何处理。
 
   对于这些曲线，实现应该使用[RFC7748]中指定的方法来计算Diffie-Hellman共享秘密。
   实现必须检查计算出的Diffie-Hellman共享机密是否为全零值，如果是，则中止，
   如[RFC7748]的第6节所述。如果实现者使用这些椭圆曲线的替代实现，他们应执行
   [RFC7748]的第7节中指定的附加检查。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
7.5.  导出器
 
   [RFC5705]根据TLS伪随机函数(PRF)定义TLS的密钥材料导出器。本文件将PRF替换为
   HKDF，因此需要新的结构。导出器界面保持不变。
 
   导出器的值计算如下：
 
   TLS-Exporter(label, context_value, key_length) =
       HKDF-Expand-Label(Derive-Secret(Secret, label, ""),
                         "exporter", Hash(context_value), key_length)
 
   其中Secret是 early_exporter_master_secret 或 exporter_master_secret。
   除非应用程序明确指定，否则实现必须使用 exporter_master_secret。
   early_exporter_master_secret 定义用于0-RTT数据需要导出器的设置中。建议为
   早期导出器提供单独的界面；这可以避免导出器用户在需要常规导出器时意外使用早期
   导出器，反之亦然。
 
   如果未提供上下文，则context_value的长度为零。因此，不提供上下文将计算与提供
   空上下文相同的值。这与以前版本的TLS有所不同，以前的TLS版本中，空上下文产生的输出
   与不存在的上下文不同。自本文档发布之日起，没有使用带有上下文和无上下文的已分配
   导出器标签。 未来的规范不得定义允许空上下文和具有相同标签的空上下文的导出器的
   使用。导出器的新用途应该在所有导出器计算中提供上下文，尽管值可以是空的。
 
   导出器标签格式的要求在[RFC5705]第4节中定义。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
8.  0-RTT and Anti-Replay
 
   如第2.3节和附录E.5所述，TLS不为0-RTT数据提供固有的重放保护。需要关注的潜在威胁
   有两个：
 
   -  通过简单复制0-RTT数据报进行重放攻击的网络攻击者。
 
   -  利用客户端重试行为安排服务器接收应用程序消息的多个副本的网络攻击者。这种威胁
      在某种程度上已经存在，因为重视健壮性的客户端通过尝试重试请求来响应网络错误。
      然而，0-RTT为不维护全局一致的服务器状态的任何服务器系统添加了额外的维度。
      具体地说，如果服务器系统有多个区域，在区域B中不接受区域A的票证，则攻击者可以
      将针对A的ClientHello和早期数据复制到A和B。在A，数据将在0-RTT中被接受，
      但是在B处，服务器将拒绝0-RTT数据，而是强制完全握手。如果攻击者阻止来自 A 的
      ServerHello，则客户端将完成与B的握手，并可能重试请求，从而导致整个服务器
      系统上的重复。
 
   可以通过共享状态来保证0-RTT数据最多接受一次来防止第一类攻击。服务器应通过实施本节
   中描述的方法之一或通过等效的方法来提供该级别的重放安全。然而，应该理解的是，由于
   操作方面的考虑，并不是所有的部署都会将状态保持在该级别。因此，在正常操作中，客户端
   将不知道服务器实际实现这些机制中的哪一种(如果有的话)，因此必须仅发送他们认为可以
   安全重放的早期数据。
 
   除了重放的直接影响外，还有一类攻击，其中即使通常被认为是幂等的操作也可以被大量的
   重放利用(定时攻击，资源限制耗尽等，如附录E.5所述)。这些可以通过确保每个0-RTT
   有效载荷只能被有限次数地重放来减轻。服务器必须确保它的任何实例(可以是机器、线程或
   相关服务基础设施内的任何其他实体)最多接受0-RTT进行同一握手；这将重放的次数
   限制为部署中的服务器实例的数量。这样的保证可以通过本地记录来自最近接收到的
   ClientHellos的数据并拒绝重复，或者通过提供相同或更强的保证的任何其他方法来实现。
   “每个服务器实例最多一次”保证是最低要求；如果可行，服务器应该进一步限制0-RTT重播。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 



 
   第二类攻击在TLS层无法防止，必须由任何应用程序处理。请注意，客户端实现任何类型的
   重试行为的任何应用程序都需要实现某种反重放防御。
 


8.1.  一次性票据
 
   最简单的反重放防御形式是服务器只允许每个会话票证使用一次。例如，服务器可以维护所有
   未完成的有效票证的数据库，在使用时从数据库中删除每个票证。如果提供了未知的票证，
   则服务器将回退到完全握手。
 
   如果票证不是自包含的，而是数据库 key，并且相应的PSK在使用时被删除，则使用PSK建立
   的连接享有前向保密性。这提高了在没有(EC)DHE的情况下使用PSK时所有0-RTT数据和PSK
   使用的安全性。
 
   由于此机制需要在具有多个分布式服务器的环境中的服务器节点之间共享会话数据库，与
   自加密票证相比，可能难以实现高成功率的PSK 0-RTT连接。与会话数据库不同，会话票证
   即使没有一致的存储，也可以成功地进行基于PSK的会话建立，尽管当允许0-RTT时，它们
   仍然需要一致的存储来防止0-RTT数据的重放，如下一节所述。
 




8.2.  Client Hello Recording
 
   反重放的另一种形式是记录从ClientHello派生的唯一值(通常是随机值或PSK绑定器)并
   拒绝重复。记录所有ClientHello会导致状态不受限制地增长，但是服务器可以在给定的
   时间窗口内记录ClientHello，并使用“obfuscated_ticket_age”确保票证不会在
   该窗口外重用。
 
   为了实现这一点，当接收到ClientHello时，服务器首先验证PSK绑定器，如第4.2.11节
   所述。然后，如下一节所述，它会计算expected_arrival_time ，如果0-RTT在记录
   窗口之外，则拒绝0-RTT，退回到1-RTT握手。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   如果expected_arrival_time 在窗口中，那么服务器检查它是否记录了匹配的
   ClientHello。如果找到一个，它要么中止握手并发出“illegal_parameter”警报，
   要么接受PSK但拒绝0-RTT。如果没有找到匹配的 ClientHello，那么它接受0-RTT，
   然后只要expected_arrival_time 在窗口内就存储ClientHello。服务器还可以实现
   具有假阳性的数据存储，例如Bloom过滤器，在这种情况下，它们必须通过拒绝0-RTT来
   响应明显的重放，但不能中止握手。
 
   服务器必须仅从ClientHello的已验证部分派生存储密钥。如果ClientHello包含多个
   PSK身份，则攻击者可以为不太首选的身份创建具有不同绑定器值的多个ClientHello，
   前提是服务器不会对其进行验证(如第4.2.11节所建议的)。即，如果客户端发送
   PSK A和B，但服务器偏好 A，则攻击者可以在不影响A的绑定器的情况下改变B的绑定器。
   如果B的绑定器是存储密钥的一部分，则该ClientHello将不会出现为副本，这将导致
   ClientHello 被接受，并且可能导致诸如重放高速缓存污染之类的副作用，尽管任何
   0-RTT数据都将是不可解密的，因为它将使用不同的密钥。如果将经过验证的绑定器或
   ClientHello.random用作存储密钥，则不可能进行这种攻击。
 
   因为这种机制不需要存储所有未完成的票据，所以它可能更容易在具有高恢复速率和0-RTT
   的分布式系统中实现，而代价是由于可靠地存储和检索所接收的ClientHello消息的困难，
   潜在的较弱的反重放防御。在许多这样的系统中，对所有接收到的ClientHellos进行全局
   一致的存储是不切实际的。在这种情况下，通过使单个存储区域对给定票证具有权威性，并在
   任何其他区域中拒绝该票证的0-RTT，来提供最佳的防重放保护。这种方法可以防止攻击者
   进行简单的重播，因为只有一个区域会接受0-RTT数据。较弱的设计是为每个区域实现单独
   的存储，但允许在任何区域中使用0-RTT。这种方法将每个区域的重放次数限制为一次。
   当然，无论采用哪种设计，应用程序消息复制都是可能的。
 
   当实施刚刚开始时，只要他们的记录窗口的任何部分与启动时间重叠，他们就应该拒绝
   0-RTT。否则，他们将面临接受在此期间最初发送的回放的风险。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   注意：如果客户端的时钟比服务器的时钟运行得快得多，那么将来可能会收到一个在窗口
   之外的ClientHello，在这种情况下，它可能会被1-RTT接受，导致客户端重试，然后再被
   0-RTT接受。这是第8节中描述的第二种攻击形式的另一种变体。
 
8.3.  新鲜度检查
 
   因为ClientHello指示客户端发送它的时间，所以可以有效地确定ClientHello是否可能是
   最近合理发送的，并且只接受这种ClientHello 的0-RTT，否则回退到1-RTT握手。这对于
   第8.2节中描述的ClientHello 存储机制是必要的，因为否则服务器需要存储无限数量的
   ClientHello，并且对于自包含的一次性票证是有用的优化，因为它允许高效拒绝不能
   用于0-RTT 的 ClientHello。
 
   为了实现这一机制，服务器需要存储服务器生成会话票证的时间，由客户端和服务器之间的
   往返时间的估计值偏移。即，
 
       adjusted_creation_time = creation_time + estimated_RTT
 
   这个值可以编码在票证中，从而避免了为每个未完成的票证保持状态的需要。服务器可以通过
   从客户端的“pre_shared_key”扩展中的“obfuscated_ticket_age”参数减去票证的
   “ticket_age_add”值来确定客户端对票龄的看法。服务端可以将ClientHello的
   expected_arrival_time 确定为：
 
     expected_arrival_time = adjusted_creation_time + clients_ticket_age
 
   当接收到新的ClientHello时，然后将expected_arrival_time 与当前的服务器时钟
   时间进行比较，如果它们相差超过某一量，则拒绝0-RTT，但允许完成1-RTT握手。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   有几个潜在的误差源可能会导致expected_arrival_time 和测量时间之间的不匹配。
   客户端和服务器时钟频率的变化可能是最小的，尽管潜在的绝对时间可能会偏离较大的值。
   网络传播延迟是导致经过时间的合法值不匹配的最有可能的原因。NewSessionTicket和
   ClientHello消息都可能被重新传输，因此会被延迟，这可能被TCP隐藏。对于Internet上
   的客户端，这意味着窗口在10秒左右，以说明时钟中的错误和测量中的变化；其他部署方案
   可能有不同的需求。时钟偏斜分布不是对称的，因此最佳权衡可能涉及允许不匹配值的
   不对称范围。
 
   请注意，仅进行新鲜度检查不足以防止重放，因为它不会在错误窗口期间检测到它们，根据
   带宽和系统容量，错误窗口可能包含数十亿次真实环境中的重播。此外，这种新鲜性检查仅在
   接收到ClientHello时进行，而不是在接收到后续的早期应用程序数据记录时进行。在接受
   早期数据之后，可以在更长的时间段内继续将记录流式传输到服务器。
 
9.  合规性要求
 
9.1.  强制实施密码套件
 
   在没有另有规定的应用程序配置文件标准的情况下：
 
   符合TLS的应用程序必须实现TLS_AES_128_GCM_SHA256[GCM]密码套件，并应实现
   TLS_AES_256_GCM_SHA384[GCM]和TLS_CHACHA20_POLY1305_SHA256[RFC8439]
   密码套件(参见附录B.4)。
 
   符合TLS的应用程序必须支持rsa_pkcs1_sha256(用于证书)、
   rsa_pss_rsae_sha256(用于CertificateVerify和证书)和
   ecdsa_secp256r1_sha256的数字签名。符合TLS的应用程序必须支持与
   secp256r1(NIST P-256)进行密钥交换，并应支持与 X25519[RFC7748]进行密钥交换。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
9.2.  强制实施扩展
 
   在没有另外指定的应用程序配置文件标准的情况下，符合TLS的应用程序必须实现以下TLS
   扩展：
 
   -  Supported Versions ("supported_versions"; Section 4.2.1)
 
   -  Cookie ("cookie"; Section 4.2.2)
 
   -  Signature Algorithms ("signature_algorithms"; Section 4.2.3)
 
   -  Signature Algorithms Certificate ("signature_algorithms_cert";
      Section 4.2.3)
 
   -  Negotiated Groups ("supported_groups"; Section 4.2.7)
 
   -  Key Share ("key_share"; Section 4.2.8)
 
   -  Server Name Indication ("server_name"; Section 3 of [RFC6066])
 
   在提供适用的功能时，所有实施都必须发送和使用这些扩展：
 
   -  所有ClientHello、ServerHello和HelloRetryRequest消息都
      需要 "supported_versions" 。
 
   -  证书认证需要“signature_algorithms”。
 
   -  使用DHE或ECDHE密钥交换的ClientHello消息需要“supported_groups”。
 
   -  DHE或ECDHE密钥交换需要“key_share”。
 
   -  PSK密钥协商需要“pre_shared_key”。
 
   -  PSK密钥协商需要“psk_key_exchange_modes”。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   如果ClientHello包含“supported_versions”扩展，且其内容中包含0x0304，则认为
   客户端试图使用此规范进行协商。此类ClientHello消息必须满足以下要求：
 
   -  如果不包含“pre_shared_key”扩展，则必须同时包含“signature_algorithms”
      扩展和“supported_groups”扩展。
 
   -  如果包含“supported_groups”扩展，则还必须包含“key_share”扩展，反之亦然。
      允许空的KeyShare.client_share向量。
 
   接收不符合这些要求的ClientHello的服务器必须中止握手并发出“missing_extension”
   警报。
 
   此外，所有实现都必须支持使用“server_name”扩展，使应用程序能够使用它。服务器可能
   要求客户端发送有效的“server_name”扩展。需要此扩展的服务器应通过使用
   “missing_extension”警报终止连接来响应缺少“server_name”扩展的ClientHello。
 







9.3.  协议不变量
 
   本节描述TLS端点和中间件必须遵循的不变量。它也适用于TLS的早期版本。
 
   TLS设计为安全且兼容可扩展。较新的客户端或服务器在与较新的对等体通信时，应协商
   最首选的公共参数。TLS握手提供降级保护：在不终止TLS的情况下在较新的客户端和较新的
   服务器之间传递流量的中间件应该不能影响握手(参见附录E.1)。同时，部署以不同的速率
   更新，因此较新的客户端或服务器可能会继续支持较旧的参数，这将允许其与较旧的端点
   进行互操作。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   为此，实现必须正确处理可扩展字段：
 
   -  发送ClientHello的客户端必须支持其中通告的所有参数。否则，服务器可能无法通过
      选择这些参数之一进行互操作。
 
   -  接收ClientHello的服务器必须正确忽略所有无法识别的密码套件、扩展名和其他参数。
      否则，它可能无法与较新的客户端进行互操作。在TLS 1.3中，接收
      CertificateRequest或NewSessionTicket的客户端还必须忽略所有无法识别的
      扩展。
 
   -  终止TLS连接的中间件必须表现为兼容的TLS服务器(对于原始客户端)，包括具有客户端
      愿意接受的证书，也必须作为兼容的TLS客户端(对原始服务器)，包括验证原始服务器的
      证书。特别是，它必须生成自己的ClientHello，其中只包含它理解的参数，并且它
      必须生成一个新的ServerHello随机值，而不是转发端点的值。
 
      请注意，TLS的协议要求和安全性分析仅分别适用于两个连接。安全地部署TLS终结器
      需要额外的安全注意事项，这超出了本文档的范围。
 
   -  转发其不理解的ClientHello参数的中间件不得处理超出该ClientHello的任何消息。
      它必须转发所有后续流量而不进行修改。否则，它可能无法与较新的客户端和服务器进行
      互操作。
 
      转发的ClientHello可能包含中间件不支持的功能的广告，因此响应可能包括中间件
      不识别的未来TLS添加。这些添加可能会任意更改ClientHello之外的任何消息。特别
      是，ServerHello中发送的值可能会更改，ServerHello格式可能会更改，
      TLSCiphertext格式可能会更改。
 
   TLS 1.3的设计受到了广泛部署的不兼容TLS中间件的限制(参见附录D.4)；然而，它并没有
   放松不变量。这些中间件仍然是不兼容的。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
10.  安全注意事项
 
   本备忘录将讨论安全问题，尤其是在附录 C、D 和 E 中。
 
11.  IANA 注意事项
 
   本文档使用几个最初在 [RFC4346] 中创建并在 [RFC8447] 中更新的注册表。 IANA 
   已更新这些文件以引用本文档。 注册及其分配政策如下：
 
   -  TLS密码套件注册表：第一个字节在0-254(十进制)范围内的值通过[RFC8126]分配。
      第一个字节255(十进制)的值保留供私人使用[RFC8126]。
 
      IANA 将附录 B.4 中列出的密码套件添加到注册表中。"Value"和"Description"列
      取自表。 对于每个新密码套件，"DTLS-OK"和"Recommended"列都标记为"Y"。
 
   -  TLS Content Type注册表：未来值通过标准操作[RFC8126]分配。
 
   -  TLS警报注册表：未来值通过标准操作[RFC8126]分配。IANA已使用附录B.2中的值
      填充此注册表。对于所有这些值，“DTLS-OK”列标记为“Y”。标记为“_RESERVED”的
      值具有描述其先前用法的注释。
 
   -  TLS HandshakeType注册表：未来值通过标准操作[RFC8126]分配。IANA已更新此
      注册表，将项目4从“NewSessionTicket”重命名为“new_session_ticket”，并
      使用附录B.3中的值填充此注册表。对于所有这些值，“DTLS-OK”列标记为“Y”。
      标记为“_Reserved”的值具有描述其先前或临时用法的注释。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   本文档还使用最初在[RFC4366]中创建的TLS ExtensionType值注册表。IANA已更新它
   以引用此文档。对注册表的更改如下：
 
   -  IANA已将注册政策更新如下：
 
      第一个字节在0-254(十进制)范围内的值通过“要求规范”[RFC8126]分配。第一个字节
      255(十进制)的值保留供私人使用[RFC8126]。
 
   -  IANA已更新此注册表，以包括“key_share”、“pre_shared_key”、
      “psk_key_exchange_modes”、“arly_data”、“cookie”、
      “supported_versions”、“certificate_authority”、“oid_filter”、
      “POST_HANDROWAKH_AUTH”和“Signature_Algorithms_cert”扩展，扩展为
      本文档中定义的值，“Recommended”值为“Y”。
 
   -  IANA已更新此注册表，以包含“TLS 1.3”列，列中列出了扩展可能出现的消息。此列
      最初是从4.2节的表中填充的，其中未列出的任何扩展都标记为“-”，以表明
      TLS 1.3未使用它。
 
   本文档更新了最初在[RFC6091]中创建并在[RFC8447]中更新的TLS证书类型注册表中的
   条目。IANA已更新值1的条目，使其具有名称“OpenPGP_RESERVED”、“Recommended”值
   “N”和注释“在1.3之前的TLS版本中使用”。
 
   本文档更新最初在[RFC6961]中创建的TLS证书状态类型注册表中的条目。IANA已更新值2
   的条目，使其具有名称“ocsp_multi_RESERVED”和注释
   “Used in TLS Versions Before 1.3”(在TLS 1.3之前的版本中使用)。
 
   本文档更新TLS Supported Groups 注册表中的两个条目(由[RFC4492]以不同的名称
   创建；现在由[RFC8422]维护)，并由[RFC7919]和[RFC8447]更新。值29和30
   (x25519和x448)的条目已经更新，也引用了本文档。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   此外，本文档还定义了两个由IANA维护的新注册表：
 
   -  TLS SignatureScheme 注册表：第一个字节在0-253(十进制)范围内的值通过
      Specification Required[RFC8126]分配。第一个字节254或255(十进制)的值
      保留供私人使用[RFC8126]。当前未分配的第一个字节在0-6范围内或第二个字节在
      0-3范围内的值保留用于向后兼容性。此注册表有一个“Recommended”列。注册表最初
      已填充4.2.3节中描述的值。下列值标记为“Recommended”： 
      ecdsa_secp256r1_sha256，ecdsa_secp384r1_sha384，
      rsa_pss_rsae_sha256，rsa_pss_rsae_sha384，
      rsa_pss_rsae_sha512，rsa_pss_sha256，rsa_pss_sha384，
      rsa_pss_sha512，和ed25519。除非明确要求，否则会为“Recommended”列指定值
      “N”，并且添加“Recommended”值为“Y”的值需要标准操作[RFC8126]。Y-&gt;N过渡
      需要IESG批准。
 
   -  TLS PskKeyExchangeMode 注册表：通过Specification Required[RFC8126]
      分配0-253(十进制)范围内的值。值254和255(十进制)保留供私人使用[RFC8126]。
      此注册表有一个“Recommended”列。注册表最初已用psk_ke(0)和psk_dhe_ke(1)
      填充。两者都标记为“Recommended”。除非明确要求，否则会为“Recommended”列指定
      值“N”，并且添加“Recommended”值为“Y”的值需要标准操作[RFC8126]。Y-&gt;N过渡
      需要IESG审批。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
12.  参考

12.1.  Normative References

   [DH76]     Diffie, W. and M. Hellman, "密码学的新方向", 
              IEEE Transactions on Information
              Theory, Vol. 22 No. 6, pp. 644-654,
              DOI 10.1109/TIT.1976.1055638, November 1976.

   [ECDSA]    American National Standards Institute, "金融服务业的公钥
              加密：椭圆曲线数字签名算法(ECDSA)",
              ANSI ANS X9.62-2005, November 2005.

   [GCM]      Dworkin, M., "分组密码操作模式的推荐：Galois/计数器模式(GCM)和
              GMAC",
              NIST Special Publication 800-38D,
              DOI 10.6028/NIST.SP.800-38D, November 2007.

   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, "HMAC：
              用于消息验证的密钥散列", RFC 2104,
              DOI 10.17487/RFC2104, February 1997,
              <https: www.rfc-editor.org="" info="" rfc2104="">.

   [RFC2119]  Bradner, S., "在RFC中用于指示需求级别的关键字", 
              BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https: www.rfc-editor.org="" info="" rfc2119="">.

   [RFC5116]  McGrew, D., "认证加密的接口和算法",
              RFC 5116, DOI 10.17487/RFC5116, January 2008,
              <https: www.rfc-editor.org="" info="" rfc5116="">.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509公钥基础设施证书
              和证书吊销列表(CRL)配置文件", 
              RFC 5280, DOI 10.17487/RFC5280, May 2008,
              <https: www.rfc-editor.org="" info="" rfc5280="">.

   [RFC5705]  Rescorla, E., "用于传输层安全(TLS)的密钥材料导出器",
              RFC 5705, DOI 10.17487/RFC5705,
              March 2010, <https: www.rfc-editor.org="" info="" rfc5705="">.

   [RFC5756]  Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk,
              "Updates for RSAES-OAEP and RSASSA-PSS Algorithm
              Parameters", RFC 5756, DOI 10.17487/RFC5756, January 2010,
              <https: www.rfc-editor.org="" info="" rfc5756="">.</https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [RFC5869]  Krawczyk, H. and P. Eronen, "基于HMAC的提取和扩展密钥导出
              函数(HKDF)", RFC 5869,
              DOI 10.17487/RFC5869, May 2010,
              <https: www.rfc-editor.org="" info="" rfc5869="">.

   [RFC6066]  Eastlake 3rd, D., "传输层安全(TLS)扩展：扩展定义", RFC 6066,
              DOI 10.17487/RFC6066, January 2011,
              <https: www.rfc-editor.org="" info="" rfc6066="">.

   [RFC6655]  McGrew, D. and D. Bailey, "AES-CCM传输层安全加密套件(TLS)",
              RFC 6655, DOI 10.17487/RFC6655, July 2012,
              <https: www.rfc-editor.org="" info="" rfc6655="">.

   [RFC6960]  Santesson, S., Myers, M., Ankney, R., Malpani, A.,
              Galperin, S., and C. Adams, "X.509互联网公钥基础设施在线证书
              状态协议-OCSP",
              RFC 6960, DOI 10.17487/RFC6960, June 2013,
              <https: www.rfc-editor.org="" info="" rfc6960="">.

   [RFC6961]  Pettersen, Y., "传输层安全(TLS)多证书状态请求扩展", RFC 6961,
              DOI 10.17487/RFC6961, June 2013,
              <https: www.rfc-editor.org="" info="" rfc6961="">.

   [RFC6962]  Laurie, B., Langley, A., and E. Kasper, "证书透明度",
              RFC 6962, DOI 10.17487/RFC6962, June 2013,
              <https: www.rfc-editor.org="" info="" rfc6962="">.

   [RFC6979]  Pornin, T., "数字签名算法(DSA)和椭圆曲线数字签名算法(ECDSA)的
              确定性使用", RFC 6979, DOI 10.17487/RFC6979,
              August 2013, <https: www.rfc-editor.org="" info="" rfc6979="">.

   [RFC7301]  Friedl, S., Popov, A., Langley, A., and E. Stephan,
              "传输层安全(TLS)应用层协议协商扩展", RFC 7301,
              DOI 10.17487/RFC7301,
              July 2014, <https: www.rfc-editor.org="" info="" rfc7301="">.

   [RFC7507]  Moeller, B. and A. Langley, "用于防止协议降级攻击的TLS回退
              信令密码组值(SCSV)", RFC 7507, DOI 10.17487/RFC7507,
              April 2015,
              <https: www.rfc-editor.org="" info="" rfc7507="">.

   [RFC7748]  Langley, A., Hamburg, M., and S. Turner, "Elliptic Curves
              for Security", RFC 7748, DOI 10.17487/RFC7748,
              January 2016, <https: www.rfc-editor.org="" info="" rfc7748="">.</https:></https:></https:></https:></https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [RFC7919]  Gillmor, D., "用于传输层安全(TLS)的协商有限域Diffie-Hellman
              临时参数", RFC 7919, DOI 10.17487/RFC7919, August 2016,
              <https: www.rfc-editor.org="" info="" rfc7919="">.

   [RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,
              "PKCS #1: RSA 加密规范版本 2.2",
              RFC 8017, DOI 10.17487/RFC8017, November 2016,
              <https: www.rfc-editor.org="" info="" rfc8017="">.

   [RFC8032]  Josefsson, S. and I. Liusvaara, "Edwards-Curve 数字签名算法
              (EdDSA)", RFC 8032,
              DOI 10.17487/RFC8032, January 2017,
              <https: www.rfc-editor.org="" info="" rfc8032="">.

   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "在RFC中编写
              IANA注意事项部分的指导原则", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https: www.rfc-editor.org="" info="" rfc8126="">.

   [RFC8174]  Leiba, B., "RFC 2119关键词大小写歧义", BCP 14, RFC 8174,
              DOI 10.17487/RFC8174, May 2017,
              <https: www.rfc-editor.org="" info="" rfc8174="">.

   [RFC8439]  Nir, Y. and A. Langley, "用于IETF协议的ChaCha20和Poly1305",
              RFC 8439, DOI 10.17487/RFC8439, June 2018,
              <https: www.rfc-editor.org="" info="" rfc8439="">.

   [SHS]      Dang, Q., "安全哈希标准(SHS)", National Institute
              of Standards and Technology report,
              DOI 10.6028/NIST.FIPS.180-4, August 2015.

   [X690]     ITU-T, "信息技术 -- ASN.1 编码规则：基本编码规则 （BER）、
              规范编码规则 （CER） 和可分辨编码规则 （DER） 规范", 
              ISO/IEC 8825-1:2015, November 2015.</https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
12.2.  信息参考

   [AEAD-LIMITS]
              Luykx, A. and K. Paterson, "Limits on Authenticated
              Encryption Use in TLS", August 2017,
              <http: www.isg.rhul.ac.uk="" ~kp="" tls-aebounds.pdf="">.

   [BBFGKZ16]
              Bhargavan, K., Brzuska, C., Fournet, C., Green, M.,
              Kohlweiss, M., and S. Zanella-Beguelin, "Downgrade
              Resilience in Key-Exchange Protocols", Proceedings of IEEE
              Symposium on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.37, May 2016.

   [BBK17]    Bhargavan, K., Blanchet, B., and N. Kobeissi, "Verified
              Models and Reference Implementations for the TLS 1.3
              Standard Candidate", Proceedings of IEEE Symposium on
              Security and Privacy (San Jose), DOI 10.1109/SP.2017.26,
              May 2017.

   [BDFKPPRSZZ16]
              Bhargavan, K., Delignat-Lavaud, A., Fournet, C.,
              Kohlweiss, M., Pan, J., Protzenko, J., Rastogi, A., Swamy,
              N., Zanella-Beguelin, S., and J. Zinzindohoue,
              "Implementing and Proving the TLS 1.3 Record Layer",
              Proceedings of IEEE Symposium on Security and Privacy (San
              Jose), May 2017, <https: eprint.iacr.org="" 2016="" 1178="">.

   [Ben17a]   Benjamin, D., "Presentation before the TLS WG at
              IETF 100", November 2017,
              <https: datatracker.ietf.org="" meeting="" 100="" materials="" slides-100-tls-sessa-tls13="">.

   [Ben17b]   Benjamin, D., "Additional TLS 1.3 results from Chrome",
              message to the TLS mailing list, 18 December 2017,
              <https: www.ietf.org="" mail-archive="" web="" tls="" current="" msg25168.html="">.

   [Blei98]   Bleichenbacher, D., "Chosen Ciphertext Attacks against
              Protocols Based on RSA Encryption Standard PKCS #1",
              Proceedings of CRYPTO '98, 1998.

   [BMMRT15]  Badertscher, C., Matt, C., Maurer, U., Rogaway, P., and B.
              Tackmann, "Augmented Secure Channels and the Goal of the
              TLS 1.3 Record Layer", ProvSec 2015, September 2015,
              <https: eprint.iacr.org="" 2015="" 394="">.</https:></https:></https:></https:></http:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [BT16]     Bellare, M. and B. Tackmann, "The Multi-User Security of
              Authenticated Encryption: AES-GCM in TLS 1.3", Proceedings
              of CRYPTO 2016, July 2016,
              <https: eprint.iacr.org="" 2016="" 564="">.

   [CCG16]    Cohn-Gordon, K., Cremers, C., and L. Garratt, "On
              Post-compromise Security", IEEE Computer Security
              Foundations Symposium, DOI 10.1109/CSF.2016.19, July 2015.

   [CHECKOWAY]
              Checkoway, S., Maskiewicz, J., Garman, C., Fried, J.,
              Cohney, S., Green, M., Heninger, N., Weinmann, R.,
              Rescorla, E., and H. Shacham, "A Systematic Analysis of
              the Juniper Dual EC Incident", Proceedings of the 2016 ACM
              SIGSAC Conference on Computer and Communications Security
              - CCS '16, DOI 10.1145/2976749.2978395, October 2016.

   [CHHSV17]  Cremers, C., Horvat, M., Hoyland, J., Scott, S., and T.
              van der Merwe, "Awkward Handshake: Possible mismatch of
              client/server view on client authentication in
              post-handshake mode in Revision 18", message to the TLS
              mailing list, 10 February 2017, <https: www.ietf.org="" mail-archive="" web="" tls="" current="" msg22382.html="">.

   [CHSV16]   Cremers, C., Horvat, M., Scott, S., and T. van der Merwe,
              "Automated Analysis and Verification of TLS 1.3: 0-RTT,
              Resumption and Delayed Authentication", Proceedings of
              IEEE Symposium on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.35, May 2016,
              <https: ieeexplore.ieee.org="" document="" 7546518="">.

   [CK01]     Canetti, R. and H. Krawczyk, "Analysis of Key-Exchange
              Protocols and Their Use for Building Secure Channels",
              Proceedings of Eurocrypt 2001,
              DOI 10.1007/3-540-44987-6_28, April 2001.

   [CLINIC]   Miller, B., Huang, L., Joseph, A., and J. Tygar, "I Know
              Why You Went to the Clinic: Risks and Realization of HTTPS
              Traffic Analysis", Privacy Enhancing Technologies, pp.
              143-163, DOI 10.1007/978-3-319-08506-7_8, 2014.

   [DFGS15]   Dowling, B., Fischlin, M., Guenther, F., and D. Stebila,
              "A Cryptographic Analysis of the TLS 1.3 Handshake
              Protocol Candidates", Proceedings of ACM CCS 2015,
              October 2015, <https: eprint.iacr.org="" 2015="" 914="">.</https:></https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [DFGS16]   Dowling, B., Fischlin, M., Guenther, F., and D. Stebila,
              "A Cryptographic Analysis of the TLS 1.3 Full and
              Pre-shared Key Handshake Protocol", TRON 2016,
              February 2016, <https: eprint.iacr.org="" 2016="" 081="">.

   [DOW92]    Diffie, W., van Oorschot, P., and M. Wiener,
              "Authentication and authenticated key exchanges", Designs,
              Codes and Cryptography, DOI 10.1007/BF00124891, June 1992.

   [DSS]      National Institute of Standards and Technology, U.S.
              Department of Commerce, "Digital Signature Standard
              (DSS)", NIST FIPS PUB 186-4, DOI 10.6028/NIST.FIPS.186-4,
              July 2013.

   [FG17]     Fischlin, M. and F. Guenther, "Replay Attacks on Zero
              Round-Trip Time: The Case of the TLS 1.3 Handshake
              Candidates", Proceedings of EuroS&amp;P 2017, April 2017,
              <https: eprint.iacr.org="" 2017="" 082="">.

   [FGSW16]   Fischlin, M., Guenther, F., Schmidt, B., and B. Warinschi,
              "Key Confirmation in Key Exchange: A Formal Treatment and
              Implications for TLS 1.3", Proceedings of IEEE Symposium
              on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.34, May 2016,
              <https: ieeexplore.ieee.org="" document="" 7546517="">.

   [FW15]     Weimer, F., "Factoring RSA Keys With TLS Perfect Forward
              Secrecy", September 2015.

   [HCJC16]   Husak, M., Cermak, M., Jirsik, T., and P. Celeda, "HTTPS
              traffic analysis and client identification using passive
              SSL/TLS fingerprinting", EURASIP Journal on Information
              Security, Vol. 2016, DOI 10.1186/s13635-016-0030-7,
              February 2016.

   [HGFS15]   Hlauschek, C., Gruber, M., Fankhauser, F., and C. Schanes,
              "Prying Open Pandora's Box: KCI Attacks against TLS",
              Proceedings of USENIX Workshop on Offensive Technologies,
              August 2015.

   [IEEE1363]
              IEEE, "IEEE Standard Specifications for Public Key
              Cryptography", IEEE Std. 1363-2000,
              DOI 10.1109/IEEESTD.2000.92292.</https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [JSS15]    Jager, T., Schwenk, J., and J. Somorovsky, "On the
              Security of TLS 1.3 and QUIC Against Weaknesses in PKCS#1
              v1.5 Encryption", Proceedings of ACM CCS 2015,
              DOI 10.1145/2810103.2813657, October 2015,
              <https: www.nds.rub.de="" media="" nds="" veroeffentlichungen="" 2015="" 08="" 21="" tls13quicattacks.pdf="">.

   [KEYAGREEMENT]
              Barker, E., Chen, L., Roginsky, A., Vassilev, A., and R.
              Davis, "Recommendation for Pair-Wise Key Establishment
              Schemes Using Discrete Logarithm Cryptography", National
              Institute of Standards and Technology,
              DOI 10.6028/NIST.SP.800-56Ar3, April 2018.

   [Kraw10]   Krawczyk, H., "Cryptographic Extraction and Key
              Derivation: The HKDF Scheme", Proceedings of CRYPTO 2010,
              August 2010, <https: eprint.iacr.org="" 2010="" 264="">.

   [Kraw16]   Krawczyk, H., "A Unilateral-to-Mutual Authentication
              Compiler for Key Exchange (with Applications to Client
              Authentication in TLS 1.3", Proceedings of ACM CCS 2016,
              October 2016, <https: eprint.iacr.org="" 2016="" 711="">.

   [KW16]     Krawczyk, H. and H. Wee, "The OPTLS Protocol and TLS 1.3",
              Proceedings of EuroS&amp;P 2016, March 2016,
              <https: eprint.iacr.org="" 2015="" 978="">.

   [LXZFH16]  Li, X., Xu, J., Zhang, Z., Feng, D., and H. Hu, "Multiple
              Handshakes Security of TLS 1.3 Candidates", Proceedings of
              IEEE Symposium on Security and Privacy (San Jose),
              DOI 10.1109/SP.2016.36, May 2016,
              <https: ieeexplore.ieee.org="" document="" 7546519="">.

   [Mac17]    MacCarthaigh, C., "Security Review of TLS1.3 0-RTT",
              March 2017, <https: github.com="" tlswg="" tls13-spec="" issues="" 1001="">.

   [PS18]     Patton, C. and T. Shrimpton, "Partially specified
              channels: The TLS 1.3 record layer without elision", 2018,
              <https: eprint.iacr.org="" 2018="" 634="">.

   [PSK-FINISHED]
              Scott, S., Cremers, C., Horvat, M., and T. van der Merwe,
              "Revision 10: possible attack if client authentication is
              allowed during PSK", message to the TLS mailing list,
              31 October 2015, <https: www.ietf.org="" mail-archive="" web="" tls="" current="" msg18215.html="">.</https:></https:></https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [REKEY]    Abdalla, M. and M. Bellare, "Increasing the Lifetime of a
              Key: A Comparative Analysis of the Security of Re-keying
              Techniques", ASIACRYPT 2000, DOI 10.1007/3-540-44448-3_42,
              October 2000.

   [Res17a]   Rescorla, E., "Preliminary data on Firefox TLS 1.3
              Middlebox experiment", message to the TLS mailing list,
              5 December 2017, <https: www.ietf.org="" mail-archive="" web="" tls="" current="" msg25091.html="">.

   [Res17b]   Rescorla, E., "More compatibility measurement results",
              message to the TLS mailing list, 22 December 2017,
              <https: www.ietf.org="" mail-archive="" web="" tls="" current="" msg25179.html="">.

   [RFC3552]  Rescorla, E. and B. Korver, "Guidelines for Writing RFC
              Text on Security Considerations", BCP 72, RFC 3552,
              DOI 10.17487/RFC3552, July 2003,
              <https: www.rfc-editor.org="" info="" rfc3552="">.

   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,
              "Randomness Requirements for Security", BCP 106, RFC 4086,
              DOI 10.17487/RFC4086, June 2005,
              <https: www.rfc-editor.org="" info="" rfc4086="">.

   [RFC4346]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.1", RFC 4346,
              DOI 10.17487/RFC4346, April 2006,
              <https: www.rfc-editor.org="" info="" rfc4346="">.

   [RFC4366]  Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J.,
              and T. Wright, "Transport Layer Security (TLS)
              Extensions", RFC 4366, DOI 10.17487/RFC4366, April 2006,
              <https: www.rfc-editor.org="" info="" rfc4366="">.

   [RFC4492]  Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B.
              Moeller, "Elliptic Curve Cryptography (ECC) Cipher Suites
              for Transport Layer Security (TLS)", RFC 4492,
              DOI 10.17487/RFC4492, May 2006,
              <https: www.rfc-editor.org="" info="" rfc4492="">.

   [RFC5077]  Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig,
              "Transport Layer Security (TLS) Session Resumption without
              Server-Side State", RFC 5077, DOI 10.17487/RFC5077,
              January 2008, <https: www.rfc-editor.org="" info="" rfc5077="">.</https:></https:></https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246,
              DOI 10.17487/RFC5246, August 2008,
              <https: www.rfc-editor.org="" info="" rfc5246="">.

   [RFC5764]  McGrew, D. and E. Rescorla, "Datagram Transport Layer
              Security (DTLS) Extension to Establish Keys for the Secure
              Real-time Transport Protocol (SRTP)", RFC 5764,
              DOI 10.17487/RFC5764, May 2010,
              <https: www.rfc-editor.org="" info="" rfc5764="">.

   [RFC5929]  Altman, J., Williams, N., and L. Zhu, "Channel Bindings
              for TLS", RFC 5929, DOI 10.17487/RFC5929, July 2010,
              <https: www.rfc-editor.org="" info="" rfc5929="">.

   [RFC6091]  Mavrogiannopoulos, N. and D. Gillmor, "Using OpenPGP Keys
              for Transport Layer Security (TLS) Authentication",
              RFC 6091, DOI 10.17487/RFC6091, February 2011,
              <https: www.rfc-editor.org="" info="" rfc6091="">.

   [RFC6101]  Freier, A., Karlton, P., and P. Kocher, "The Secure
              Sockets Layer (SSL) Protocol Version 3.0", RFC 6101,
              DOI 10.17487/RFC6101, August 2011,
              <https: www.rfc-editor.org="" info="" rfc6101="">.

   [RFC6176]  Turner, S. and T. Polk, "Prohibiting Secure Sockets Layer
              (SSL) Version 2.0", RFC 6176, DOI 10.17487/RFC6176,
              March 2011, <https: www.rfc-editor.org="" info="" rfc6176="">.

   [RFC6347]  Rescorla, E. and N. Modadugu, "Datagram Transport Layer
              Security Version 1.2", RFC 6347, DOI 10.17487/RFC6347,
              January 2012, <https: www.rfc-editor.org="" info="" rfc6347="">.

   [RFC6520]  Seggelmann, R., Tuexen, M., and M. Williams, "Transport
              Layer Security (TLS) and Datagram Transport Layer Security
              (DTLS) Heartbeat Extension", RFC 6520,
              DOI 10.17487/RFC6520, February 2012,
              <https: www.rfc-editor.org="" info="" rfc6520="">.

   [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing",
              RFC 7230, DOI 10.17487/RFC7230, June 2014,
              <https: www.rfc-editor.org="" info="" rfc7230="">.</https:></https:></https:></https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [RFC7250]  Wouters, P., Ed., Tschofenig, H., Ed., Gilmore, J.,
              Weiler, S., and T. Kivinen, "Using Raw Public Keys in
              Transport Layer Security (TLS) and Datagram Transport
              Layer Security (DTLS)", RFC 7250, DOI 10.17487/RFC7250,
              June 2014, <https: www.rfc-editor.org="" info="" rfc7250="">.

   [RFC7465]  Popov, A., "Prohibiting RC4 Cipher Suites", RFC 7465,
              DOI 10.17487/RFC7465, February 2015,
              <https: www.rfc-editor.org="" info="" rfc7465="">.

   [RFC7568]  Barnes, R., Thomson, M., Pironti, A., and A. Langley,
              "Deprecating Secure Sockets Layer Version 3.0", RFC 7568,
              DOI 10.17487/RFC7568, June 2015,
              <https: www.rfc-editor.org="" info="" rfc7568="">.

   [RFC7627]  Bhargavan, K., Ed., Delignat-Lavaud, A., Pironti, A.,
              Langley, A., and M. Ray, "Transport Layer Security (TLS)
              Session Hash and Extended Master Secret Extension",
              RFC 7627, DOI 10.17487/RFC7627, September 2015,
              <https: www.rfc-editor.org="" info="" rfc7627="">.

   [RFC7685]  Langley, A., "A Transport Layer Security (TLS) ClientHello
              Padding Extension", RFC 7685, DOI 10.17487/RFC7685,
              October 2015, <https: www.rfc-editor.org="" info="" rfc7685="">.

   [RFC7924]  Santesson, S. and H. Tschofenig, "Transport Layer Security
              (TLS) Cached Information Extension", RFC 7924,
              DOI 10.17487/RFC7924, July 2016,
              <https: www.rfc-editor.org="" info="" rfc7924="">.

   [RFC8305]  Schinazi, D. and T. Pauly, "Happy Eyeballs Version 2:
              Better Connectivity Using Concurrency", RFC 8305,
              DOI 10.17487/RFC8305, December 2017,
              <https: www.rfc-editor.org="" info="" rfc8305="">.

   [RFC8422]  Nir, Y., Josefsson, S., and M. Pegourie-Gonnard, "Elliptic
              Curve Cryptography (ECC) Cipher Suites for Transport Layer
              Security (TLS) Versions 1.2 and Earlier", RFC 8422,
              DOI 10.17487/RFC8422, August 2018,
              <https: www.rfc-editor.org="" info="" rfc8422="">.

   [RFC8447]  Salowey, J. and S. Turner, "IANA Registry Updates for TLS
              and DTLS", RFC 8447, DOI 10.17487/RFC8447, August 2018,
              <https: www.rfc-editor.org="" info="" rfc8447="">.

   [RFC8449]  Thomson, M., "Record Size Limit Extension for TLS",
              RFC 8449, DOI 10.17487/RFC8449, August 2018,
              <https: www.rfc-editor.org="" info="" rfc8449="">.</https:></https:></https:></https:></https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [RSA]      Rivest, R., Shamir, A., and L. Adleman, "A Method for
              Obtaining Digital Signatures and Public-Key
              Cryptosystems", Communications of the ACM, Vol. 21 No. 2,
              pp. 120-126, DOI 10.1145/359340.359342, February 1978.

   [SIGMA]    Krawczyk, H., "SIGMA: The 'SIGn-and-MAc' Approach to
              Authenticated Diffie-Hellman and its Use in the IKE
              Protocols", Proceedings of CRYPTO 2003,
              DOI 10.1007/978-3-540-45146-4_24, August 2003.

   [SLOTH]    Bhargavan, K. and G. Leurent, "Transcript Collision
              Attacks: Breaking Authentication in TLS, IKE, and SSH",
              Network and Distributed System Security
              Symposium (NDSS 2016), DOI 10.14722/ndss.2016.23418,
              February 2016.

   [SSL2]     Hickman, K., "The SSL Protocol", February 1995.

   [TIMING]   Boneh, D. and D. Brumley, "Remote Timing Attacks Are
              Practical", USENIX Security Symposium, August 2003.

   [TLS13-TRACES]
              Thomson, M., "Example Handshake Traces for TLS 1.3", Work
              in Progress, draft-ietf-tls-tls13-vectors-06, July 2018.

   [X501]     ITU-T, "Information Technology - Open Systems
              Interconnection - The Directory: Models", ITU-T X.501,
              October 2016, <https: www.itu.int="" rec="" t-rec-x.501="" en="">.</https:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
附录 A.  状态机
 
   本附录提供了客户端和服务器握手的合法状态转换的摘要。状态名称(所有大写，
   例如，start)没有正式意义，但为便于理解而提供。仅在某些情况下采取的行动在[]中
   指明。符号“K_{send，recv}=foo”表示“将发送/接收密钥设置为给定密钥”。
 
A.1.  Client
 
                              START &lt;----+
               Send ClientHello |        | Recv HelloRetryRequest
          [K_send = early data] |        |
                                v        |
           /                 WAIT_SH ----+
           |                    | Recv ServerHello
           |                    | K_recv = handshake
       Can |                    V
      send |                 WAIT_EE
     early |                    | Recv EncryptedExtensions
      data |           +--------+--------+
           |     Using |                 | Using certificate
           |       PSK |                 v
           |           |            WAIT_CERT_CR
           |           |        Recv |       | Recv CertificateRequest
           |           | Certificate |       v
           |           |             |    WAIT_CERT
           |           |             |       | Recv Certificate
           |           |             v       v
           |           |              WAIT_CV
           |           |                 | Recv CertificateVerify
           |           +&gt; WAIT_FINISHED &lt;+
           |                  | Recv Finished
           \                  | [Send EndOfEarlyData]
                              | K_send = handshake
                              | [Send Certificate [+ CertificateVerify]]
    Can send                  | Send Finished
    app data   --&gt;            | K_send = K_recv = application
    after here                v
                          CONNECTED
 
   请注意，通过如上所示的转换，客户端可以明文发送从post-ServerHello消息派生的
   警报，或使用早期数据密钥发送警报。如果客户端需要发送此类警报，则应在可能的情况下
   首先将密钥重新设置为握手密钥。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
A.2.  Server
 
                              START &lt;-----+
               Recv ClientHello |         | Send HelloRetryRequest
                                v         |
                             RECVD_CH ----+
                                | Select parameters
                                v
                             NEGOTIATED
                                | Send ServerHello
                                | K_send = handshake
                                | Send EncryptedExtensions
                                | [Send CertificateRequest]
 Can send                       | [Send Certificate + CertificateVerify]
 app data                       | Send Finished
 after   --&gt;                    | K_send = application
 here                  +--------+--------+
              No 0-RTT |                 | 0-RTT
                       |                 |
   K_recv = handshake  |                 | K_recv = early data
 [Skip decrypt errors] |    +------&gt; WAIT_EOED -+
                       |    |       Recv |      | Recv EndOfEarlyData
                       |    | early data |      | K_recv = handshake
                       |    +------------+      |
                       |                        |
                       +&gt; WAIT_FLIGHT2 &lt;--------+
                                |
                       +--------+--------+
               No auth |                 | Client auth
                       |                 |
                       |                 v
                       |             WAIT_CERT
                       |        Recv |       | Recv Certificate
                       |       empty |       v
                       | Certificate |    WAIT_CV
                       |             |       | Recv
                       |             v       | CertificateVerify
                       +-&gt; WAIT_FINISHED &lt;---+
                                | Recv Finished
                                | K_recv = application
                                v
                            CONNECTED</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
附录B.  协议数据结构和常量值
 
   本附录提供了规范的协议类型和常量的定义。列为“_Reserved”的值在以前版本的TLS中
   使用，此处列出是为了完整性。TLS 1.3实现不能发送它们，但可能会从较旧的TLS实现
   接收它们。
 
B.1.  记录层
 
      enum {
          invalid(0),
          change_cipher_spec(20),
          alert(21),
          handshake(22),
          application_data(23),
          heartbeat(24),  /* RFC 6520 */
          (255)
      } ContentType;
 
      struct {
          ContentType type;
          ProtocolVersion legacy_record_version;
          uint16 length;
          opaque fragment[TLSPlaintext.length];
      } TLSPlaintext;
 
      struct {
          opaque content[TLSPlaintext.length];
          ContentType type;
          uint8 zeros[length_of_padding];
      } TLSInnerPlaintext;
 
      struct {
          ContentType opaque_type = application_data; /* 23 */
          ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */
          uint16 length;
          opaque encrypted_record[TLSCiphertext.length];
      } TLSCiphertext;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.2.  警告消息
 
      enum { warning(1), fatal(2), (255) } AlertLevel;
 
      enum {
          close_notify(0),
          unexpected_message(10),
          bad_record_mac(20),
          decryption_failed_RESERVED(21),
          record_overflow(22),
          decompression_failure_RESERVED(30),
          handshake_failure(40),
          no_certificate_RESERVED(41),
          bad_certificate(42),
          unsupported_certificate(43),
          certificate_revoked(44),
          certificate_expired(45),
          certificate_unknown(46),
          illegal_parameter(47),
          unknown_ca(48),
          access_denied(49),
          decode_error(50),
          decrypt_error(51),
          export_restriction_RESERVED(60),
          protocol_version(70),
          insufficient_security(71),
          internal_error(80),
          inappropriate_fallback(86),
          user_canceled(90),
          no_renegotiation_RESERVED(100),
          missing_extension(109),
          unsupported_extension(110),
          certificate_unobtainable_RESERVED(111),
          unrecognized_name(112),
          bad_certificate_status_response(113),
          bad_certificate_hash_value_RESERVED(114),
          unknown_psk_identity(115),
          certificate_required(116),
          no_application_protocol(120),
          (255)
      } AlertDescription;
 
      struct {
          AlertLevel level;
          AlertDescription description;
      } Alert;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.  握手协议
 
      enum {
          hello_request_RESERVED(0),
          client_hello(1),
          server_hello(2),
          hello_verify_request_RESERVED(3),
          new_session_ticket(4),
          end_of_early_data(5),
          hello_retry_request_RESERVED(6),
          encrypted_extensions(8),
          certificate(11),
          server_key_exchange_RESERVED(12),
          certificate_request(13),
          server_hello_done_RESERVED(14),
          certificate_verify(15),
          client_key_exchange_RESERVED(16),
          finished(20),
          certificate_url_RESERVED(21),
          certificate_status_RESERVED(22),
          supplemental_data_RESERVED(23),
          key_update(24),
          message_hash(254),
          (255)
      } HandshakeType;
 
      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* bytes in message */
          select (Handshake.msg_type) {
              case client_hello:          ClientHello;
              case server_hello:          ServerHello;
              case end_of_early_data:     EndOfEarlyData;
              case encrypted_extensions:  EncryptedExtensions;
              case certificate_request:   CertificateRequest;
              case certificate:           Certificate;
              case certificate_verify:    CertificateVerify;
              case finished:              Finished;
              case new_session_ticket:    NewSessionTicket;
              case key_update:            KeyUpdate;
          };
      } Handshake;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.1.  密钥交换消息
 
    uint16 ProtocolVersion;
    opaque Random[32];
 
    uint8 CipherSuite[2];    /* Cryptographic suite selector */
 
    struct {
        ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
        Random random;
        opaque legacy_session_id&lt;0..32&gt;;
        CipherSuite cipher_suites&lt;2..2^16-2&gt;;
        opaque legacy_compression_methods&lt;1..2^8-1&gt;;
        Extension extensions&lt;8..2^16-1&gt;;
    } ClientHello;
 
    struct {
        ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */
        Random random;
        opaque legacy_session_id_echo&lt;0..32&gt;;
        CipherSuite cipher_suite;
        uint8 legacy_compression_method = 0;
        Extension extensions&lt;6..2^16-1&gt;;
    } ServerHello;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
    struct {
        ExtensionType extension_type;
        opaque extension_data&lt;0..2^16-1&gt;;
    } Extension;
 
    enum {
        server_name(0),                             /* RFC 6066 */
        max_fragment_length(1),                     /* RFC 6066 */
        status_request(5),                          /* RFC 6066 */
        supported_groups(10),                       /* RFC 8422, 7919 */
        signature_algorithms(13),                   /* RFC 8446 */
        use_srtp(14),                               /* RFC 5764 */
        heartbeat(15),                              /* RFC 6520 */
        application_layer_protocol_negotiation(16), /* RFC 7301 */
        signed_certificate_timestamp(18),           /* RFC 6962 */
        client_certificate_type(19),                /* RFC 7250 */
        server_certificate_type(20),                /* RFC 7250 */
        padding(21),                                /* RFC 7685 */
        RESERVED(40),                               /* Used but never
                                                       assigned */
        pre_shared_key(41),                         /* RFC 8446 */
        early_data(42),                             /* RFC 8446 */
        supported_versions(43),                     /* RFC 8446 */
        cookie(44),                                 /* RFC 8446 */
        psk_key_exchange_modes(45),                 /* RFC 8446 */
        RESERVED(46),                               /* Used but never
                                                       assigned */
        certificate_authorities(47),                /* RFC 8446 */
        oid_filters(48),                            /* RFC 8446 */
        post_handshake_auth(49),                    /* RFC 8446 */
        signature_algorithms_cert(50),              /* RFC 8446 */
        key_share(51),                              /* RFC 8446 */
        (65535)
    } ExtensionType;
 
    struct {
        NamedGroup group;
        opaque key_exchange&lt;1..2^16-1&gt;;
    } KeyShareEntry;
 
    struct {
        KeyShareEntry client_shares&lt;0..2^16-1&gt;;
    } KeyShareClientHello;
 
    struct {
        NamedGroup selected_group;
    } KeyShareHelloRetryRequest;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
    struct {
        KeyShareEntry server_share;
    } KeyShareServerHello;
 
    struct {
        uint8 legacy_form = 4;
        opaque X[coordinate_length];
        opaque Y[coordinate_length];
    } UncompressedPointRepresentation;
 
    enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;
 
    struct {
        PskKeyExchangeMode ke_modes&lt;1..255&gt;;
    } PskKeyExchangeModes;
 
    struct {} Empty;
 
    struct {
        select (Handshake.msg_type) {
            case new_session_ticket:   uint32 max_early_data_size;
            case client_hello:         Empty;
            case encrypted_extensions: Empty;
        };
    } EarlyDataIndication;
 
    struct {
        opaque identity&lt;1..2^16-1&gt;;
        uint32 obfuscated_ticket_age;
    } PskIdentity;
 
    opaque PskBinderEntry&lt;32..255&gt;;
 
    struct {
        PskIdentity identities&lt;7..2^16-1&gt;;
        PskBinderEntry binders&lt;33..2^16-1&gt;;
    } OfferedPsks;
 
    struct {
        select (Handshake.msg_type) {
            case client_hello: OfferedPsks;
            case server_hello: uint16 selected_identity;
        };
    } PreSharedKeyExtension;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.1.1.  Version Extension
 
      struct {
          select (Handshake.msg_type) {
              case client_hello:
                   ProtocolVersion versions&lt;2..254&gt;;
 
              case server_hello: /* and HelloRetryRequest */
                   ProtocolVersion selected_version;
          };
      } SupportedVersions;
 
B.3.1.2.  Cookie Extension
 
      struct {
          opaque cookie&lt;1..2^16-1&gt;;
      } Cookie;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.1.3.  Signature Algorithm Extension
 
      enum {
          /* RSASSA-PKCS1-v1_5 algorithms */
          rsa_pkcs1_sha256(0x0401),
          rsa_pkcs1_sha384(0x0501),
          rsa_pkcs1_sha512(0x0601),
 
          /* ECDSA algorithms */
          ecdsa_secp256r1_sha256(0x0403),
          ecdsa_secp384r1_sha384(0x0503),
          ecdsa_secp521r1_sha512(0x0603),
 
          /* RSASSA-PSS algorithms with public key OID rsaEncryption */
          rsa_pss_rsae_sha256(0x0804),
          rsa_pss_rsae_sha384(0x0805),
          rsa_pss_rsae_sha512(0x0806),
 
          /* EdDSA algorithms */
          ed25519(0x0807),
          ed448(0x0808),
 
          /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */
          rsa_pss_pss_sha256(0x0809),
          rsa_pss_pss_sha384(0x080a),
          rsa_pss_pss_sha512(0x080b),
 
          /* Legacy algorithms */
          rsa_pkcs1_sha1(0x0201),
          ecdsa_sha1(0x0203),
 
          /* Reserved Code Points */
          obsolete_RESERVED(0x0000..0x0200),
          dsa_sha1_RESERVED(0x0202),
          obsolete_RESERVED(0x0204..0x0400),
          dsa_sha256_RESERVED(0x0402),
          obsolete_RESERVED(0x0404..0x0500),
          dsa_sha384_RESERVED(0x0502),
          obsolete_RESERVED(0x0504..0x0600),
          dsa_sha512_RESERVED(0x0602),
          obsolete_RESERVED(0x0604..0x06FF),
          private_use(0xFE00..0xFFFF),
          (0xFFFF)
      } SignatureScheme;
 
      struct {
          SignatureScheme supported_signature_algorithms&lt;2..2^16-2&gt;;
      } SignatureSchemeList;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.1.4.  Supported Groups Extension
 
      enum {
          unallocated_RESERVED(0x0000),
 
          /* Elliptic Curve Groups (ECDHE) */
          obsolete_RESERVED(0x0001..0x0016),
          secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),
          obsolete_RESERVED(0x001A..0x001C),
          x25519(0x001D), x448(0x001E),
 
          /* Finite Field Groups (DHE) */
          ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),
          ffdhe6144(0x0103), ffdhe8192(0x0104),
 
          /* Reserved Code Points */
          ffdhe_private_use(0x01FC..0x01FF),
          ecdhe_private_use(0xFE00..0xFEFF),
          obsolete_RESERVED(0xFF01..0xFF02),
          (0xFFFF)
      } NamedGroup;
 
      struct {
          NamedGroup named_group_list&lt;2..2^16-1&gt;;
      } NamedGroupList;
 
   “obsolete_RESERVED”范围内的值在以前版本的TLS中使用，不能由TLS 1.3实现提供或
   协商。过时的曲线有各种已知/理论上的弱点，或者只有很少的用途，在某些情况下只是由于
   无意的服务器配置问题。它们不再被认为适合一般使用，应该被认为是潜在的不安全的。这里
   指定的曲线集足以与所有当前部署和正确配置的TLS实现进行互操作性。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.2.  Server Parameters Messages
 
      opaque DistinguishedName&lt;1..2^16-1&gt;;
 
      struct {
          DistinguishedName authorities&lt;3..2^16-1&gt;;
      } CertificateAuthoritiesExtension;
 
      struct {
          opaque certificate_extension_oid&lt;1..2^8-1&gt;;
          opaque certificate_extension_values&lt;0..2^16-1&gt;;
      } OIDFilter;
 
      struct {
          OIDFilter filters&lt;0..2^16-1&gt;;
      } OIDFilterExtension;
 
      struct {} PostHandshakeAuth;
 
      struct {
          Extension extensions&lt;0..2^16-1&gt;;
      } EncryptedExtensions;
 
      struct {
          opaque certificate_request_context&lt;0..2^8-1&gt;;
          Extension extensions&lt;2..2^16-1&gt;;
      } CertificateRequest;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.3.  Authentication Messages
 
      enum {
          X509(0),
          OpenPGP_RESERVED(1),
          RawPublicKey(2),
          (255)
      } CertificateType;
 
      struct {
          select (certificate_type) {
              case RawPublicKey:
                /* From RFC 7250 ASN.1_subjectPublicKeyInfo */
                opaque ASN1_subjectPublicKeyInfo&lt;1..2^24-1&gt;;
 
              case X509:
                opaque cert_data&lt;1..2^24-1&gt;;
          };
          Extension extensions&lt;0..2^16-1&gt;;
      } CertificateEntry;
 
      struct {
          opaque certificate_request_context&lt;0..2^8-1&gt;;
          CertificateEntry certificate_list&lt;0..2^24-1&gt;;
      } Certificate;
 
      struct {
          SignatureScheme algorithm;
          opaque signature&lt;0..2^16-1&gt;;
      } CertificateVerify;
 
      struct {
          opaque verify_data[Hash.length];
      } Finished;
 
B.3.4.  Ticket Establishment
 
      struct {
          uint32 ticket_lifetime;
          uint32 ticket_age_add;
          opaque ticket_nonce&lt;0..255&gt;;
          opaque ticket&lt;1..2^16-1&gt;;
          Extension extensions&lt;0..2^16-2&gt;;
      } NewSessionTicket;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
B.3.5.  Updating Keys
 
      struct {} EndOfEarlyData;
 
      enum {
          update_not_requested(0), update_requested(1), (255)
      } KeyUpdateRequest;
 
      struct {
          KeyUpdateRequest request_update;
      } KeyUpdate;
 
B.4.  Cipher Suites
 
   对称密码套件定义要与HKDF一起使用的AEAD算法和散列算法对。加密套件名称遵循命名
   约定：
 
      CipherSuite TLS_AEAD_HASH = VALUE;
 
      +-----------+------------------------------------------------+
      | Component | Contents                                       |
      +-----------+------------------------------------------------+
      | TLS       | The string "TLS"                               |
      |           |                                                |
      | AEAD      | The AEAD algorithm used for record protection  |
      |           |                                                |
      | HASH      | The hash algorithm used with HKDF              |
      |           |                                                |
      | VALUE     | The two-byte ID assigned for this cipher suite |
      +-----------+------------------------------------------------+
 
   本规范定义了以下与TLS 1.3一起使用的密码套件。
 
              +------------------------------+-------------+
              | Description                  | Value       |
              +------------------------------+-------------+
              | TLS_AES_128_GCM_SHA256       | {0x13,0x01} |
              |                              |             |
              | TLS_AES_256_GCM_SHA384       | {0x13,0x02} |
              |                              |             |
              | TLS_CHACHA20_POLY1305_SHA256 | {0x13,0x03} |
              |                              |             |
              | TLS_AES_128_CCM_SHA256       | {0x13,0x04} |
              |                              |             |
              | TLS_AES_128_CCM_8_SHA256     | {0x13,0x05} |
              +------------------------------+-------------+</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   相应的AEAD 算法AEAD_AES_128_GCM、AEAD_AES_256_GCM和AEAD_AES_128_CCM 
   在[RFC5116]中定义。AEAD_CHACHA20_POLY1305 在[RFC8439]中定义。
   AEAD_AES_128_CCM_8在[RFC6655]中定义。相应的散列算法在[SHS]中定义。
 
   尽管TLS 1.3使用与以前版本TLS相同的密码套件空间，但TLS 1.3密码套件的定义有所
   不同，仅指定对称密码，不能用于 TLS 1.2。同样，TLS 1.2及更低版本的加密套件不能
   与TLS 1.3一起使用。
 
   新的密码套值由IANA分配，如第11节所述。
 
Appendix C.  实现说明
 
   TLS协议不能防止许多常见的安全错误。本附录提供了几项建议，以帮助实施者。
   [TLS13-traces]提供TLS 1.3握手的测试向量。
 
C.1.  Random Number Generation and Seeding
 
   TLS需要加密安全的伪随机数生成器(CSPRNG)。在大多数情况下，操作系统提供了适当的
   工具，例如/dev/urandom，应该在没有其他(例如，性能)问题的情况下使用这些工具。
   建议使用现有的CSPRNG实现，而不是创建新的CSPRNG实现。许多足够的加密库已经在有利的
   许可条款下可用。如果这些不能满足需求，[RFC4086]提供了关于生成随机值的指导。
 
   TLS使用公共协议字段中的随机值(1)，例如ClientHello和ServerHello中的公共
   随机值，以及生成密钥材料(2)。使用正常运行的CSPRNG，这不会出现安全问题，因为从其
   输出确定CSPRNG状态是不可行的。但是，使用损坏的CSPRNG，攻击者可能会使用公共输出
   来确定CSPRNG内部状态，从而预测密钥材料，如[Checkoway]中所述。通过使用单独的
   CSPRNG生成公共和私有值，实现可以针对这种形式的攻击提供额外的安全性。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
C.2.  证书和身份验证
 
   实现负责验证证书的完整性，并且通常应该支持证书撤销消息。在应用程序配置文件中没有
   特定指示的情况下，应始终对证书进行验证，以确保受信任的证书颁发机构(CA)正确签名。
   信任锚的选择和添加应该非常小心。用户应该能够查看有关证书和信任锚的信息。应用程序
   还应强制执行最小和最大密钥大小。例如，包含弱于2048位RSA或224位ECDSA的密钥或签名
   的证书路径不适用于安全应用程序。
 
C.3.  实施陷阱
 
   实现经验表明，早期TLS规范的某些部分不容易理解，并且已经成为互操作性和安全问题的
   根源。这些领域中的许多已经在本文档中进行了澄清，但本附录包含了需要实施者特别注意
   的最重要事项的简短列表。
 
   TLS协议问题：
 
   -  您是否正确处理分成多个TLS记录的握手消息(参见5.1节)？您是否正确地处理了像
      ClientHello这样被拆分成几个小片段的边缘情况？您是否对超过最大片段大小的握手
      消息进行分段？特别是，Certificate和CertificateRequest握手消息可能足够大，
      需要分段。
 
   -  是否忽略所有未加密TLS记录中的TLS记录层版本号(参见附录D)？
 
   -  您是否确保从支持TLS 1.3或更高版本的所有可能配置中完全删除对SSL、RC4、导出
      密码和MD5(通过“Signature_Algorithms”扩展)的所有支持，并且尝试使用这些
      过时功能的尝试正确失败(参见附录D)？
 
   -  您是否正确处理ClientHellos中的TLS扩展，包括未知扩展？</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   -  当服务器请求客户证书但没有合适的证书可用时，您是否正确地发送了一个空的证书
      消息，而不是忽略整个消息(参见4.4.2节)？
 
   -  在处理aead-decrypt生成的明文片段并从末尾扫描contentType时，如果对等体
      发送了格式错误的全为零的明文，您是否避免扫描超过明文的开头？
 
   -  您是否在ClientHello正确忽略了无法识别的密码套件(4.1.2节)，
      hello扩展(4.2节)， 命名组(4.2.7节)，key shares(4.2.8节)，
      supported versions(4.2.1节)，和签名算法(4.2.3节)在ClientHello？
 
   -  作为服务器，您是否向支持Compatible(EC)DHE组但不在“Key_Share”扩展中
      预测它的客户端发送HelloRetryRequest？作为客户端，您是否正确处理来自服务器的
      HelloRetryRequest？
 
   加密详细信息：
 
   -  您使用什么对策来防止时序攻击 [TIMING]?
 
   -  使用Diffie-Hellman密钥交换时，是否正确保留协商密钥中的前导零字节
      (参见7.4.1节)？
 
   -  您的TLS客户端是否检查服务器发送的Diffie-Hellman参数是否可接受
      (参见第4.2.8.1节)？
 
   -  在生成Diffie-Hellman私有值、ECDSA“k”参数和其他安全关键值时，是否使用强大
      且最重要的种子随机数生成器(参见附录C.1)？建议实现[RFC6979]中规定的
      “deterministic ECDSA”。
 
   -  您是否将Diffie-Hellman公钥值和共享密钥填充为组大小
      (参见第4.2.8.1节和7.4.1节)？
 
   -  制作签名后是否验证签名，以防止RSA-CRT密钥泄漏[FW15]？</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
C.4.  客户端跟踪预防
 
   客户端不应将票证重用于多个连接。票的重用允许被动观察者关联不同的连接。发出票证的
   服务器应至少提供与客户端可能使用的连接数量相同的票证；例如，使用
   HTTP/1.1[RFC7230]的Web浏览器可能会打开六个到服务器的连接。服务器应该为每个
   连接颁发新的票证。这可确保客户端在创建新连接时始终能够使用新票证。
 
C.5.  未经身份验证的操作
 
   以前版本的TLS提供了基于匿名Diffie-Hellman的显式未经验证的密码套件。这些模式
   在TLS 1.3中已被弃用。但是，仍然可以通过几种方法协商不提供可验证的服务器身份验证
   的参数，包括：
 
   -  原始公钥 [RFC7250].
 
   -  使用证书中包含的公钥，但不验证证书链或其任何内容。
 
   单独使用的任何一种技术都容易受到中间人攻击，因此一般使用不安全。然而，也可以通过
   服务器公钥的带外验证、首次使用时信任或通道绑定等机制将此类连接绑定到外部验证机制
   (尽管[RFC5929]中描述的通道绑定没有为TLS 1.3定义)。如果没有使用这样的机制，则
   连接没有针对主动中间人攻击的保护；应用程序不能在没有显式配置或特定应用程序配置文件
   的情况下以这种方式使用TLS。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
Appendix D.  向后兼容性
 
   TLS协议为可能支持不同版本的TLS的端点之间的版本协商提供了内置机制。
 
   TLS 1.x和SSL 3.0使用兼容的ClientHello消息。服务器还可以处理试图使用未来版本
   的TLS的客户端，只要ClientHello格式保持兼容，并且客户端和服务器都至少支持一个
   协议版本。
 
   TLS的早期版本使用记录层版本号(TLSPlaintext.Legacy_Record_Version和
   TLSCiphertext.Legacy_Record_Version)用于各种目的。从TLS 1.3开始，此字段
   已弃用。所有实现都必须忽略TLSPlaintext.Legacy_Record_Version的值。
   TLSCiphertext.Legacy_Record_Version的值被包括在用于去保护的附加数据中，
   但是可以被忽略，或者可以被验证以匹配固定常量值。仅使用握手版本
   (ClientHello.Legacy_Version和ServerHello.Legacy_version，以及
   ClientHello、HelloRetryRequest和ServerHello“Supported_Versions”扩展)
   执行版本协商。为了最大限度地提高与较旧端点的互操作性，协商使用TLS 1.0-1.2的实现
   应将记录层版本号设置为ServerHello和此后的所有记录的协商版本。
 
   为了最大限度地兼容以前的非标准行为和配置错误的部署，所有实施都应支持基于本文档中
   的预期验证认证路径，即使在处理以前的TLS版本的握手时也是如此(参见第4.4.2.2节)。
 
   TLS 1.2和更早版本支持“Extended Master Secret”[RFC7627]扩展，该扩展将握手
   记录的大部分消化为主秘密。由于TLS 1.3始终在文本中进行散列，直到服务器Finished，
   因此无论何时使用TLS 1.3，同时支持TLS 1.3和更早版本的实现应指示在其API中使用
   扩展的Master Secret扩展。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
D.1.  与旧服务器协商
 
   希望与不支持TLS 1.3的服务器进行协商的TLS 1.3客户端将在
   ClientHello.Legacy_Version中发送包含0x0303(TLS 1.2)的正常
   TLS 1.3 ClientHello，但在“Supported_Versions”扩展中包含正确的版本。如果
   服务器不支持 TLS 1.3，它将使用包含旧版本号的ServerHello进行响应。如果客户同意
   使用此版本，则协商将根据协商的协议进行。使用票证进行恢复的客户端应使用先前协商的
   版本启动连接。
 
   请注意，0-RTT数据与较旧的服务器不兼容，在不知道服务器支持TLS 1.3的情况下，
   不应发送0-RTT数据。见附录D.3。
 
   如果客户端不支持服务器选择的版本(或不可接受)，则客户端必须中止握手并发出
   “protocol_version”警报。
 
   已知一些传统服务器实现不能正确实现TLS规范，并且可能在遇到它们不知道的TLS扩展或
   版本时中止连接。与有漏洞的服务器的互操作性是一个复杂的主题，超出了本文档的范围。
   可能需要多次连接尝试才能协商向后兼容的连接；但是，这种做法容易受到降级攻击，
   不建议使用。
 
D.2.  与旧客户端协商
 
   TLS服务器还可以接收ClientHello，该ClientHello指示小于其最高支持版本的版本号。
   如果存在“supported_versions”扩展，则服务器必须使用该扩展进行协商，如第4.2.1节
   所述。如果不存在“supported_versions”扩展，则服务器必须协商
   ClientHello.legacy_version和TLS 1.2的最小值。例如，如果服务器支持TLS 1.0、
   1.1和1.2，并且legacy_version 为TLS 1.0，则服务器将继续使用
   TLS 1.0 ServerHello。如果不存在“supported_versions”扩展，并且服务器仅支持
   高于ClientHello.legacy_version的版本，则服务器必须中止握手并发出
   “protocol_version”警报。
 
   请注意，TLS的早期版本没有在所有情况下都明确指定记录层版本号值
   (TLSPlaintext.legacy_record_version)。服务器将在此字段中接收各种
   TLS 1.x版本，但必须始终忽略其值。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
D.3.  0-RTT向后兼容性
 
   0-RTT数据与较旧的服务器不兼容。较旧的服务器将使用较旧的ServerHello响应
   ClientHello，但它不会正确地跳过0-RTT数据，并且将无法完成握手。当客户端尝试使用
   0-RTT时，这可能会导致问题，特别是针对多服务器部署。例如，部署可以逐渐部署
   TLS 1.3，其中一些服务器实现TLS 1.3，一些服务器实现TLS 1.2，或者TLS 1.3部署
   可以降级到TLS 1.2。
 
   尝试发送0-RTT数据的客户端如果收到带有TLS 1.2或更早版本的ServerHello，则连接
   必须失败。然后它可以在0-RTT禁用的情况下重试连接。为了避免降级攻击，客户端不应禁用
   TLS 1.3，只应禁用0-RTT。
 
   为了避免这种错误情况，在启用0-RTT之前，多服务器部署应确保在没有0-RTT的情况下
   统一且稳定地部署TLS 1.3。
 
D.4.  中间件兼容模式
 
   实际测试[Ben17a][Ben17b][Res17a][Res17b]发现，当TLS客户端/服务器对协商
   TLS 1.3时，大量中间件行为不当。通过使TLS 1.3握手看起来更像TLS 1.2握手，实现
   可以增加通过这些中间件建立连接的机会：
 
   -  客户端总是在ClientHello中提供非空的会话ID，如4.1.2节的
      legacy_session_id 部分所述。
 
   -  如果不提供早期数据，则客户端在其第二次发送之前立即发送一个虚拟
      change_cipher_spec 记录(参见第5节第三段)。这可能是在它的第二个
      ClientHello之前，或者在它的加密握手发送之前。如果提供早期数据，则记录紧跟在
      第一个ClientHello之后。
 
   -  服务器在第一次握手消息后立即发送虚拟CHANGE_CIPHER_SPEC记录。这可能发生在
      ServerHello或HelloRetryRequest之后。
 
   当将这些更改放在一起时，这些更改使TLS 1.3握手类似于TLS 1.2会话恢复，从而提高了
   通过中间件成功连接的机会。这种“兼容模式”是部分协商的：客户端可以选择提供会话ID或
   不提供，服务器必须回显它。在握手过程中，任何一方都可以随时发送
   change_cipher_spec，因为对等方必须忽略它们，但如果客户端发送非空的会话ID，
   则服务器必须发送change_cipher_spec，如本附录所述。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 




 
D.5.  与向后兼容性相关的安全限制
 
   协商使用旧版本的TLS的实现应该首选forward secret和AEAD 密码套件(如果可用)。
 
   由于[RFC7465]中引用的原因，RC4密码套件的安全性被认为是不够的。实现不得出于
   任何原因为任何版本的TLS提供或协商RC4加密套件。
 
   TLS的旧版本允许使用非常低强度的密码。出于任何原因，不得为TLS的任何版本提供或
   协商强度小于112位的密码。
 
   由于[RFC7568]中列举的原因，SSL 3.0[RFC6101]的安全性被认为是不够的，任何原因
   都不能进行协商。
 
   由于[RFC6176]中列举的原因，SSL 2.0[SSL2]的安全性被认为是不够的，任何原因都
   不能进行协商。
 
   实现不得发送SSL 2.0版兼容的CLIENT-HELLO。实现不得使用SSL 2.0版兼容的
   CLIENT-HELLO 协商TLS 1.3或更高版本。建议不要为了协商TLS的旧版本而接受
   SSL 2.0版兼容的Client-Hello的实现。
 
   实现不得发送设置为0x0300或更小的ClientHello.Legacy_Version或
   ServerHello.Legacy_Version。任何接收ClientHello.Legacy_Version或
   ServerHello.Legacy_Version设置为0x0300的Hello消息的端点必须中止握手并发出
   “protocol_version”警报。
 
   实现不得发送版本低于0x0300的任何记录。实现不应接受版本低于0x0300的任何记录
   (但如果完全忽略记录版本号，则可能会不经意地接受)。
 
   实现不得使用[RFC6066]的 ；7节中定义的截断HMAC扩展，因为它不适用于aead算法，
   并且已被证明在某些情况下是不安全的。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
附录E.安全属性概述
 
   TLS 的完整安全分析不在本文档的讨论范围之内。 在本附录中，我们提供了所需属性的
   非正式描述，并参考了研究文献中更详细的工作，其中提供了更正式的定义。
 
   我们将握手的属性与记录层的属性分开讨论。
 
E.1.  握手
 
   TLS握手是一种身份验证密钥交换(AKE)协议，旨在提供单向身份验证(仅服务器)和双向
   身份验证(客户端和服务器)功能。在握手完成时，每一方输出其以下值的视图：
 
   -  一组“会话密钥”(从主秘密导出的各种秘密)，可以从中导出一组工作密钥。
 
   -  一组加密参数(算法等)。
 
   -  通信双方的身份。
 
   我们假设攻击者是一个活跃的网络攻击者，这意味着它可以完全控制用于双方之间通信的
   网络[RFC3552]。即使在这些条件下，握手也应该提供下面列出的属性。请注意，这些属性
   不一定是独立的，但反映了协议消费者的需求。
 
   建立相同的会话密钥：握手需要在握手的两侧输出相同的会话密钥集，前提是它在每个端点
      上成功完成(参见[CK01]，定义1，第1部分)。
 
   会话密钥的保密性：共享会话密钥应该只对通信方是已知的，而攻击者不知道(参见[CK01]，
      定义1，第2部分)。请注意，在单向身份验证的连接中，攻击者可以与服务器建立自己
      的会话密钥，但这些会话密钥与客户端建立的会话密钥不同。
 
   对等身份验证：客户端的对等身份视图应该反映服务器的身份。如果客户端经过身份验证，
      则服务器的对等身份视图应与客户端的身份匹配。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   会话密钥的唯一性：任何两个不同的握手都应该产生不同的、不相关的会话密钥。通过握手
      产生的各个会话密钥也应该是不同的和独立的。
 
   降级保护：两端的加密参数应该相同，并且应该与对等端在没有攻击的情况下进行通信
      一样(参见[BBFGKZ16]，定义8和9)。
 
   关于长期密钥的前向保密：如果在握手完成之后长期密钥材料(在这种情况下是基于证书的
      认证模式中的签名密钥或具有(EC)DHE模式的PSK中的外部/恢复PSK)被泄露，这不会
      损害会话密钥的安全性(参见[DOW92])，只要会话密钥本身已被擦除即可。当PSK在
      “psk_ke”PskKeyExchangeMode中使用时，前向保密属性不满足。
 
   密钥泄露模拟(KCI)抵抗：在具有证书的相互认证的连接中，泄露一个参与者的长期秘密
      不应破坏该参与者在给定连接中对其对等体的身份验证(参见[HGFS15])。例如，如果
      客户端的签名密钥被泄露，则不可能在随后的握手中向该客户端模拟任意服务器。
 
   端点身份的保护：应该保护服务器的身份(证书)免受被动攻击者的攻击。应该保护客户端的
      身份免受被动和主动攻击者的攻击。
 
   非正式地，TLS 1.3的基于签名的模式提供了由(EC)DHE密钥交换建立的唯一的、秘密的、
   共享的密钥的建立，并且通过握手transcript上的服务器的签名进行认证，以及通过MAC
   绑定到服务器的身份。如果客户端通过证书进行身份验证，它还会对握手记录进行签名，并
   提供绑定到两个身份的MAC。[Sigma]描述了这种类型的密钥交换协议的设计和分析。如果
   每个连接都使用Fresh(EC)DHE密钥，则输出密钥是向前保密的。
 
   外部PSK和恢复PSK从长期共享秘密引导到每个连接的唯一短期会话密钥集。这个秘密可能是
   在之前的握手中建立的。如果使用具有(EC)DHE密钥建立的PSK，则这些会话密钥也将是前向
   保密的。恢复PSK被设计成使得由连接N计算并形成连接N+1所需的恢复主秘密与连接N所使用
   的业务密钥分开，从而在连接之间提供前向保密。此外，如果在同一连接上建立了多个票证，
   则它们与不同的密钥相关联，因此与一个票证相关联的PSK的泄露不会导致与其他票证相关联
   的PSK建立的连接的泄露。如果票证存储在数据库中(因此可以删除)，而不是自加密，则
   此属性最有趣。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 





 
   PSK绑定器值形成PSK和当前握手之间的绑定，以及建立PSK的会话和当前会话之间的绑定。
   此绑定可传递地包括原始握手transcript，因为该transcript被消化为产生恢复主秘密的
   值。这要求用于产生恢复主秘密的KDF和用于计算绑定器的MAC都是抗冲突的。有关这方面的
   更多信息，请参见附录E.1.1。注意：绑定器不包括来自其他PSK的绑定器值，尽管它们包含
   在 Finished 的MAC中。
 
   TLS当前不允许服务器在非基于证书的握手(例如PSK)中发送certificate_request 
   消息(服务器只能在基于证书的握手中发送certificate_request )。如果将来放宽
   这一限制，客户端的签名将不会直接覆盖服务器的证书。但是，如果PSK
   是通过NewSessionTicket建立的，则客户端的签名将通过PSK绑定器过渡覆盖服务器的
   证书。[PSK-Finish]描述了对未绑定服务器证书的构造的具体攻击
   (另请参阅[Kraw16])。当客户端可能与两个不同的端点共享相同的PSK/key-id对时，使用
   基于证书的客户端身份验证是不安全的。实现不得将外部PSK与客户端或服务器的基于证书的
   身份验证相结合，除非通过某些扩展进行协商。
 
   如果使用导出器，那么它会产生唯一的和保密的值(因为它们是从唯一的会话密钥生成的)。
   使用不同的标签和上下文计算的导出器在计算上是独立的，因此从另一个计算一个或从导出的
   值计算会话机密是不可行的。注意：导出器可以产生任意长度值；如果导出器用作通道绑定，
   则导出值必须足够大，以提供抗冲突能力。TLS 1.3中提供的导出器分别来自与早期业务密钥
   和应用业务密钥相同的握手上下文，因此具有类似的安全属性。请注意，它们不包括客户的
   证书；将来希望绑定到客户的证书的应用程序可能需要定义一个新的导出器，该导出器包含
   完整的握手记录。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   对于所有握手模式，Finished 的MAC(以及签名，如果存在)可以防止降级攻击。此外，
   如第4.1.3节所述，在随机数中使用某些字节允许检测降级到以前的TLS版本。有关
   TLS 1.3和降级的更多详细信息，请参见[BBFGKZ16]。
 
   一旦客户端和服务器交换了足够的信息以建立共享密钥，握手的其余部分就会被加密，从而
   提供针对被动攻击者的保护，即使计算出的共享密钥没有经过身份验证也是如此。因为服务器
   在客户端之前进行身份验证，所以客户端可以确保如果它向服务器进行身份验证，它只向经过
   身份验证的服务器显示其身份。请注意，实现必须在握手期间使用提供的记录填充机制，以
   避免由于长度而泄漏有关身份的信息。客户端建议的PSK身份没有加密，服务器选择的PSK
   身份也没有加密。
 
E.1.1.  密钥推导和HKDF
 
   TLS 1.3中的密钥派生使用[RFC5869]中定义的HKDF及其两个组件，HKDF-Extract和
   HKDF-Expand。HKDF构建的完整理由可以在[Kraw10]中找到，并且在[KW16]中TLS 1.3
   中使用它的方式的理由也可以在[Kww10]中找到。在整个文档中，HKDF-Extract的每个
   应用程序后面都有一个或多个HKDF-Expand的调用。应始终遵循此顺序(包括在本文档的
   未来修订版中)；特别是，在没有HKDF-Expand的情况下，不应将HKDF-Extract的输出
   用作另一个HKDF-Extract应用程序的输入。允许HKDF-Expand的多个应用到一些相同的
   输入，只要这些输入是通过密钥和/或标签来区分的。
 
   请注意，HKDF-Expand实现了具有可变长度的输入和输出的伪随机函数(PRF)。在本文档
   HKDF的一些用法中(例如，用于生成导出器和恢复主秘密)，HKDF-Expand的应用必须是
   抗冲突的；即，找到输出相同值的HKDF-Expand的两个不同输入应该是不可行的。这要求
   基础散列函数是抗冲突的，并且来自HKDF-Expand的输出长度的大小至少为256位
   (或者与散列函数所需的长度一样多，以防止发现冲突)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
E.1.2.  客户端身份验证
 
   已经在握手期间或握手后认证中向服务器发送认证数据的客户端不能确定服务器之后是否
   认为该客户端被认证。如果客户端需要确定服务器认为连接是单方面的还是相互验证的，
   这必须由应用层提供。详见[CHHSV17]。此外，[Kraw16]对握手后身份验证的分析表明，
   在握手后阶段发送的证书所标识的客户端拥有流量密钥。因此，这一方是参与原始握手的
   客户端，或者是原始客户端将业务密钥委托给的客户端(假设业务密钥没有被泄露)。
 
E.1.3.  0-RTT
 
   0-RTT操作模式通常提供类似于1-RTT数据的安全属性，除了0-RTT加密密钥不提供前向
   保密性和服务器不能保证握手的唯一性(不可重放性)而不保持潜在的不适当的状态量。有关
   限制重放暴露的机制，请参见第8节。
 
E.1.4.  导出器独立性
 
   导出的exporter_master_secret 和exporter_master_secret 独立于流量密钥，
   因此不会对使用这些密钥加密的流量的安全性构成威胁。但是，由于这些机密可用于计算任何
   导出器值，因此应尽快擦除它们。如果导出器标签的总集合是已知的，那么实现应该为所有
   这些标签预先计算导出器计算的内部派生秘密阶段，然后擦除
   [Early_]exporter_master_secret，然后在知道不再需要时立即擦除
   [Early_]exporter_master_secret。
 
E.1.5.  Post-Compromise Security
 
   TLS不为在对等体的长期密码(签名密钥或外部PSK)被泄露后发生的握手提供安全性。因此，
   它不提供后妥协安全[CCG16]，有时也被称为后向保密或未来保密。这与KCI抵抗形成了
   对比，KCI抵抗描述了一方在其自己的长期秘密被泄露后所具有的安全保证。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
E.1.6.  外部参考
 
   读者应参考以下参考资料来分析TLS握手: [DFGS15], [CHSV16], [DFGS16], [KW16],
   [Kraw16],   [FGSW16], [LXZFH16], [FG17], and [BBK17].
 
E.2.  记录层
 
   记录层依赖于产生强通信密码的握手，该通信密码可用于导出双向加密密钥和随机数。假设
   这是真的，并且关键字用于的数据不超过第5.5节所示，则记录层应提供以下保证：
 
   保密性:  攻击者不应该能够确定给定记录的明文内容。
 
   完整性:  攻击者不应该能够手工制作不同于接收方将接受的现有记录的新记录。
 
   顺序保护/不可重放性:  攻击者不应该能够使接收者接受它已经接受的记录，或者在没有
      首先处理记录N的情况下使接收者接受记录N+1。
 
   长度隐藏:  给定具有给定外部长度的记录，攻击者应该无法确定内容与填充的记录量。
 
   密钥更改后的前向保密:  如果使用了4.6.3节中描述的流量密钥更新机制，并且删除了
      上一代密钥，则危害端点的攻击者应该无法解密使用旧密钥加密的流量。
 
   非正式地，TLS 1.3通过使用强密钥保护明文来提供这些属性。AEAD加密[RFC5116]为
   数据提供机密性和完整性。通过对每个记录使用单独的随机数来提供不可重放性，其中随机数
   来自记录序列号(第5.3节)，序列号在两侧独立维护；因此，无序递送的记录导致AEAD失去
   保护。为了防止当相同的明文被不同的用户在相同的密钥下重复加密时的大量密码分析
   (对于HTTP来说通常是这样的情况)，通过将序列号与业务密钥一起导出的每个连接的秘密
   初始化向量混合来形成随机数。有关此结构的分析，请参见[BT16]。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 

 
   TLS 1.3中的密钥更新技术(参见第7.2节)遵循[ReKey]中讨论的串行生成器的构造，这表明
   与不使用密钥更新相比，密钥更新可以允许密钥用于更多的加密。这依赖于
    HKDF-Expand-Label 函数作为伪随机函数(PRF)的安全性。此外，只要这个函数是真正
   单向的，就不可能从密钥改变之前计算流量密钥(前向保密)。
 
   TLS不为在连接的通信秘密被泄露后在该连接上通信的数据提供安全性。也就是说，TLS
   不提供关于交通秘密的后置安全/未来保密/后向保密。实际上，获知流量密码的攻击者可以
   计算该连接上的所有未来流量密码。需要这种保证的系统需要进行新的握手，并与(EC)DHE
   交换建立新的连接。
 
E.2.1.  外部参考
 
   读者在分析TLS记录层时应参考以下参考资料： [BMMRT15], [BT16], BDFKPPRSZZ16],
   [BBK17], and   [PS18].
 
E.3.  流量分析
 
   TLS容易受到基于观察加密数据包的长度和定时的各种流量分析攻击[Clinic][HCJC16]。
   这在存在要区分的可能消息的小集合时特别容易，例如对于托管固定内容语料库的视频
   服务器，但即使在更复杂的情况下仍然提供可用信息。
 
   TLS不提供针对这种形式的攻击的任何特定防御，但包括供应用程序使用的填充机制：
   由AEAD功能保护的明文由内容加上可变长度填充组成，这允许应用程序产生任意长度的加密
   记录以及仅填充覆盖业务，以隐藏传输时段和静默时段之间的差异。因为填充是与实际内容
   一起加密的，所以攻击者不能直接确定填充的长度，但可以通过使用记录处理期间暴露的
   定时通道间接测量它(即，查看处理记录需要多长时间，或者在记录中滴入以查看哪些记录
   引发了服务器的响应)。一般而言，不知道如何移除所有这些频道，因为即使是固定时间的
   填充移除函数也可能将内容馈送到依赖于数据的函数中。至少，完全恒定时间的服务器或
   客户端需要与应用层协议实现密切合作，包括在更高级别的协议中恒定时间。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 

 
  注意：强大的流量分析防御可能会由于传输数据包的延迟和增加的流量而导致性能下降。
 
E.4.  旁路攻击
 
   通常，TLS没有针对旁路攻击的特定防御(即，那些通过辅助信道(例如定时)攻击通信的
   攻击)，而留给相关加密原语的实现。但是，TLS的某些功能旨在使编写旁路攻击防御代码
   变得更容易：
 
   -  与使用复合MAC-THEN-ENCRYPT结构的先前版本的TLS不同，TLS 1.3仅使用AEAD 
      算法，允许实现使用这些原语的自含式恒定时间实现。
 
   -  TLS对所有解密错误使用统一的“bad_record_mac”警报，旨在防止攻击者获得对消息
      部分的分段洞察。通过在这种错误时终止连接来提供额外的阻力；新的连接将具有不同的
      加密材料，从而防止对需要多次试验的加密原语的攻击。
 
   通过旁路攻击信息泄漏可能发生在TLS之上的层，在应用协议和使用它们的应用中。对
   旁路攻击的抵抗力取决于应用程序和应用程序协议，分别确保机密信息不会无意中泄露。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
E.5.  对0-RTT的重放攻击
 
   可重放的0-RTT数据给使用TLS的应用程序带来了许多安全威胁，除非这些应用程序被专门
   设计为在重放下是安全的(这至少意味着幂等，但在许多情况下可能还需要其他更强的条件，
   例如恒定时间响应)。潜在的攻击包括：
 
   -  重复造成副作用（例如，购买物品或转移资金）的操作，从而损害网站或用户的利益。
 
   -  攻击者可以存储和重放0-RTT消息，以便相对于其他消息对它们进行重新排序
      (例如，将删除移动到创建后)。
 
   -  利用高速缓存定时行为，通过向不同的高速缓存节点重放0-RTT消息，然后使用单独的
      连接来测量请求延迟，以查看两个请求是否寻址相同的资源，来发现0-RTT消息的内容。
 
   如果数据可以多次重放，则可能会发生额外的攻击，例如重复测量加密操作的速度。此外，
   他们可能会使速率限制系统过载。有关这些攻击的进一步说明，请参阅[Mac17]。
 
   最终，服务器有责任保护自己免受使用0-RTT数据复制的攻击。第8节中描述的机制旨在防止
   在TLS层重放，但不提供针对接收客户端数据的多个副本的完整保护。当服务器没有关于
   客户端的任何信息时，TLS 1.3退回到1-RTT握手，例如，因为它在不共享状态的不同集群
   中，或者票证已被删除，如8.1节所述。如果应用层协议在此设置中重新传输数据，则攻击者
   可能会通过将ClientHello发送到原始群集(立即处理数据)和另一个群集(将回退到1-RTT
   并在应用层重放时处理数据)来诱导消息复制。此攻击的规模受到客户端重试事务的限制，
   因此仅允许有限数量的复制，每个副本在服务器上显示为新连接。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   如果正确实施8.1和8.2节中描述的机制,可以防止重放ClientHello及其关联的0-RTT数据
   被任何具有一致状态的集群多次接受；对于将0-RTT的使用限制在单个票证的一个集群中的
   服务器，则给定的ClientHello及其关联的0-RTT数据将只接受一次。但是，如果状态
   不完全一致，则攻击者可能能够在复制窗口期间接受数据的多个副本。因为客户端不知道
   服务器行为的确切细节，所以他们不能在早期数据中发送消息，这些数据对于重放是不安全
   的，并且它们不愿意跨多个1-RTT连接重试。
 
   如果没有定义0-RTT数据使用的配置文件，则应用程序协议不得使用0-RTT数据。该配置文件
   需要确定哪些消息或交互可以安全地与0-RTT一起使用，以及当服务器拒绝0-RTT并退回到
   1-RTT时如何处理这种情况。
 
   此外，为了避免意外误用，除非应用程序特别请求，否则TLS实现不得启用0-RTT
   (发送或接受)，并且除非应用程序指示，否则如果0-RTT数据被服务器拒绝，则不得自动重新
   发送0-RTT数据。服务器侧应用可能希望为某些类型的应用业务实现对0-RTT数据的特殊处理
   (例如，中止连接，请求在应用层重新发送数据，或者延迟处理直到握手完成)。为了允许
   应用程序实现这种处理，TLS实现必须为应用程序提供一种方法来确定握手是否已完成。
 
E.5.1.  重播和导出器
 
   ClientHello的重播会产生相同的早期导出器，因此需要使用这些导出器的应用程序进行
   额外的处理。特别地，如果这些导出器被用作验证通道绑定(例如，通过对导出器的输出
   进行签名)，则危害PSK的攻击者可以在不损害验证密钥的情况下在连接之间移植验证器。
 
   此外，早期导出器不应用于生成服务器到客户端的加密密钥，因为这将需要重用这些密钥。
   这与早期应用程序流量密钥仅在客户端到服务器方向上的使用类似。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
E.6.  PSK身份泄露
 
   因为实现通过中止握手来响应无效的PSK绑定器，所以攻击者可能会验证给定的PSK身份
   是否有效。具体地说，如果服务器既接受外部PSK握手又接受基于证书的握手，有效的PSK
   身份将导致握手失败，而无效的身份将被跳过并导致成功的证书握手。仅支持PSK握手的
   服务器可能能够通过相同地对待不存在有效PSK身份和存在身份但其具有无效绑定器的情况
   来抵抗这种形式的攻击。
 
E.7.  共享PSK
 
   TLS 1.3通过将PSK绑定到特定的KDF来对PSK采取保护的方法。相比之下，TLS 1.2允许
   PSK与任何散列函数和TLS 1.2 PRF一起使用。因此，与TLS 1.2和TLS 1.3一起使用的
   任何PSK必须仅与TLS 1.3中的一个散列一起使用，如果用户想要提供单个PSK，则这不是
   最优的。TLS 1.2和TLS 1.3中的结构是不同的，尽管它们都基于HMAC。虽然没有已知的
   方式相同的PSK可能在两个版本中产生相关的输出，但仅进行了有限的分析。通过不在
   TLS 1.3和TLS 1.2之间重用PSK，实现可以确保跨协议相关输出的安全性。
 
E.8.  对静态RSA的攻击
 
   尽管TLS 1.3不使用RSA密钥传输，因此不会直接受到Bleichenbacher类型的攻击
   [Blei98]，但如果TLS 1.3服务器在以前版本的TLS环境中也支持静态RSA，则可能会模拟
   服务器进行TLS 1.3连接[JSS15]。TLS 1.3实现可以通过禁用对所有TLS版本的静态RSA
   的支持来防止这种攻击。原则上，实现也可以将具有不同密钥的证书分开用于静态RSA解密
   和RSA签名，但此技术依赖于客户端拒绝使用未设置digitalSignature位的
   证书中的密钥接受签名，并且许多客户端不强制实施此限制。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
Contributors
 
   Martin Abadi
   University of California, Santa Cruz
   abadi@cs.ucsc.edu
 
   Christopher Allen
   (co-editor of TLS 1.0)
   Alacrity Ventures
   ChristopherA@AlacrityManagement.com
 
   Richard Barnes
   Cisco
   rlb@ipv.sx
 
   Steven M. Bellovin
   Columbia University
   smb@cs.columbia.edu
 
   David Benjamin
   Google
   davidben@google.com
 
   Benjamin Beurdouche
   INRIA &amp; Microsoft Research
   benjamin.beurdouche@ens.fr
 
   Karthikeyan Bhargavan
   (editor of [RFC7627])
   INRIA
   karthikeyan.bhargavan@inria.fr
 
   Simon Blake-Wilson
   (co-author of [RFC4492])
   BCI
   sblakewilson@bcisse.com
 
   Nelson Bolyard
   (co-author of [RFC4492])
   Sun Microsystems, Inc.
   nelson@bolyard.com
 
   Ran Canetti
   IBM
   canetti@watson.ibm.com</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Matt Caswell
   OpenSSL
   matt@openssl.org
 
   Stephen Checkoway
   University of Illinois at Chicago
   sfc@uic.edu
 
   Pete Chown
   Skygate Technology Ltd
   pc@skygate.co.uk
 
   Katriel Cohn-Gordon
   University of Oxford
   me@katriel.co.uk
 
   Cas Cremers
   University of Oxford
   cas.cremers@cs.ox.ac.uk
 
   Antoine Delignat-Lavaud
   (co-author of [RFC7627])
   INRIA
   antdl@microsoft.com
 
   Tim Dierks
   (co-author of TLS 1.0, co-editor of TLS 1.1 and 1.2)
   Independent
   tim@dierks.org
 
   Roelof DuToit
   Symantec Corporation
   roelof_dutoit@symantec.com
 
   Taher Elgamal
   Securify
   taher@securify.com
 
   Pasi Eronen
   Nokia
   pasi.eronen@nokia.com
 
   Cedric Fournet
   Microsoft
   fournet@microsoft.com</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Anil Gangolli
   anil@busybuddha.org
 
   David M. Garrett
   dave@nulldereference.com
 
   Illya Gerasymchuk
   Independent
   illya@iluxonchik.me
 
   Alessandro Ghedini
   Cloudflare Inc.
   alessandro@cloudflare.com
 
   Daniel Kahn Gillmor
   ACLU
   dkg@fifthhorseman.net
 
   Matthew Green
   Johns Hopkins University
   mgreen@cs.jhu.edu
 
   Jens Guballa
   ETAS
   jens.guballa@etas.com
 
   Felix Guenther
   TU Darmstadt
   mail@felixguenther.info
 
   Vipul Gupta
   (co-author of [RFC4492])
   Sun Microsystems Laboratories
   vipul.gupta@sun.com
 
   Chris Hawk
   (co-author of [RFC4492])
   Corriente Networks LLC
   chris@corriente.net
 
   Kipp Hickman
 
   Alfred Hoenes
 
   David Hopwood
   Independent Consultant
   david.hopwood@blueyonder.co.uk</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Marko Horvat
   MPI-SWS
   mhorvat@mpi-sws.org
 
   Jonathan Hoyland
   Royal Holloway, University of London
   jonathan.hoyland@gmail.com
 
   Subodh Iyengar
   Facebook
   subodh@fb.com
 
   Benjamin Kaduk
   Akamai Technologies
   kaduk@mit.edu
 
   Hubert Kario
   Red Hat Inc.
   hkario@redhat.com
 
   Phil Karlton
   (co-author of SSL 3.0)
 
   Leon Klingele
   Independent
   mail@leonklingele.de
 
   Paul Kocher
   (co-author of SSL 3.0)
   Cryptography Research
   paul@cryptography.com
 
   Hugo Krawczyk
   IBM
   hugokraw@us.ibm.com
 
   Adam Langley
   (co-author of [RFC7627])
   Google
   agl@google.com
 
   Olivier Levillain
   ANSSI
   olivier.levillain@ssi.gouv.fr</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Xiaoyin Liu
   University of North Carolina at Chapel Hill
   xiaoyin.l@outlook.com
 
   Ilari Liusvaara
   Independent
   ilariliusvaara@welho.com
 
   Atul Luykx
   K.U. Leuven
   atul.luykx@kuleuven.be
 
   Colm MacCarthaigh
   Amazon Web Services
   colm@allcosts.net
 
   Carl Mehner
   USAA
   carl.mehner@usaa.com
 
   Jan Mikkelsen
   Transactionware
   janm@transactionware.com
 
   Bodo Moeller
   (co-author of [RFC4492])
   Google
   bodo@acm.org
 
   Kyle Nekritz
   Facebook
   knekritz@fb.com
 
   Erik Nygren
   Akamai Technologies
   erik+ietf@nygren.org
 
   Magnus Nystrom
   Microsoft
   mnystrom@microsoft.com
 
   Kazuho Oku
   DeNA Co., Ltd.
   kazuhooku@gmail.com</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Kenny Paterson
   Royal Holloway, University of London
   kenny.paterson@rhul.ac.uk
 
   Christopher Patton
   University of Florida
   cjpatton@ufl.edu
 
   Alfredo Pironti
   (co-author of [RFC7627])
   INRIA
   alfredo.pironti@inria.fr
 
   Andrei Popov
   Microsoft
   andrei.popov@microsoft.com
 
   Marsh Ray
   (co-author of [RFC7627])
   Microsoft
   maray@microsoft.com
 
   Robert Relyea
   Netscape Communications
   relyea@netscape.com
 
   Kyle Rose
   Akamai Technologies
   krose@krose.org
 
   Jim Roskind
   Amazon
   jroskind@amazon.com
 
   Michael Sabin
 
   Joe Salowey
   Tableau Software
   joe@salowey.net
 
   Rich Salz
   Akamai
   rsalz@akamai.com
 
   David Schinazi
   Apple Inc.
   dschinazi@apple.com</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Sam Scott
   Royal Holloway, University of London
   me@samjs.co.uk
 
   Thomas Shrimpton
   University of Florida
   teshrim@ufl.edu
 
   Dan Simon
   Microsoft, Inc.
   dansimon@microsoft.com
 
   Brian Smith
   Independent
   brian@briansmith.org
 
   Brian Sniffen
   Akamai Technologies
   ietf@bts.evenmere.org
 
   Nick Sullivan
   Cloudflare Inc.
   nick@cloudflare.com
 
   Bjoern Tackmann
   University of California, San Diego
   btackmann@eng.ucsd.edu
 
   Tim Taubert
   Mozilla
   ttaubert@mozilla.com
 
   Martin Thomson
   Mozilla
   mt@mozilla.com
 
   Hannes Tschofenig
   Arm Limited
   Hannes.Tschofenig@arm.com
 
   Sean Turner
   sn3rd
   sean@sn3rd.com
 
   Steven Valdez
   Google
   svaldez@google.com</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   Filippo Valsorda
   Cloudflare Inc.
   filippo@cloudflare.com
 
   Thyla van der Merwe
   Royal Holloway, University of London
   tjvdmerwe@gmail.com
 
   Victor Vasiliev
   Google
   vasilvv@google.com
 
   Hoeteck Wee
   Ecole Normale Superieure, Paris
   hoeteck@alum.mit.edu
 
   Tom Weinstein
 
   David Wong
   NCC Group
   david.wong@nccgroup.trust
 
   Christopher A. Wood
   Apple Inc.
   cawood@apple.com
 
   Tim Wright
   Vodafone
   timothy.wright@vodafone.com
 
   Peter Wu
   Independent
   peter@lekensteyn.nl
 
   Kazu Yamamoto
   Internet Initiative Japan Inc.
   kazu@iij.ad.jp
 
Author's Address
 
   Eric Rescorla
   Mozilla
 
   Email: ekr@rtfm.com
 

 

 

 
</pre><br>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.129c, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>
