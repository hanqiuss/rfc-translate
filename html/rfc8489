<div class="content" style="float: left; margin: 0px 30%; width: 579px; font-size: 14px;">
<span class="pre noprint docinfo">[<a href="https://www.rfc-editor.org" title="RFC Editor">RFC Home</a>] [<a href="/rfc/rfc8489.txt">TEXT</a>|<a href="/rfc/pdfrfc/rfc8489.txt.pdf">PDF</a>|<a href="/rfc/rfc8489.html">HTML</a>] [<a href="https://datatracker.ietf.org/doc/rfc8489" title="IETF Datatracker information for this document">Tracker</a>] [<a href="https://datatracker.ietf.org/ipr/search/?rfc=8489&amp;submit=rfc" title="IPR disclosures related to this document">IPR</a>] [<a class="boldtext" href="/errata/rfc8489" target="_blank">Errata</a>] [<a href="https://www.rfc-editor.org/info/rfc8489" title="Info page">Info page</a>]         </span><br><span class="pre noprint docinfo">                                                                        </span><br><span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br><span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><pre style="height: 780px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;">Internet Engineering Task Force (IETF)                 M. Petit-Huguenin
Request for Comments: 8489                            Impedance Mismatch
Obsoletes: 5389                                             G. Salgueiro
Category: Standards Track                                          Cisco
ISSN: 2070-1721                                             J. Rosenberg
                                                                   Five9
                                                                 D. Wing
                                                                  Citrix
                                                                 R. Mahy
                                                            Unaffiliated
                                                             P. Matthews
                                                                   Nokia
                                                           February 2020
 

                        NAT的会话穿透工具(STUN)
 

摘要
 
   NAT会话穿透工具(STUN)是一种在处理NAT穿透时用作其他协议的工具的协议。端点可以使用它来确定NAT分配给它的IP地址和端口。它还可用于检查两个端点之间的连通性，并用作维护NAT绑定的保活协议。STUN可以与许多现有NAT一起工作，不需要它们有任何特殊行为。

  STUN本身并不是一种NAT穿越解决方案。相反，它是在NAT穿越解决方案的环境中使用的工具。

  本文档将取代RFC 5389。

 
Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in Section 2 of RFC 7841.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   https://www.rfc-editor.org/info/rfc8489.</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 


Copyright Notice

   Copyright (c) 2020 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (https://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.
 
目录
 
   1. 介绍         ....................................................4
   2. 操作概述              ...........................................5
   3. 术语        .....................................................7
   4. 定义        .....................................................7
   5. STUN报文结构           ..........................................9
   6. 基本协议程序             .......................................11
      6.1. 生成请求或指示                     ........................11
      6.2. 发送请求或指示                    .........................12
           6.2.1. 通过 UDP 或 DTLS-over-UDP 发送    ..................13
           6.2.2. 通过 TCP 或 TLS-Over-Tcp 发送    ...................14
           6.2.3. 通过 TLS-over-TCP 或 DTLS-over-UDP 发送    .........15
      6.3. 接收 STUN 消息           ..................................16
           6.3.1. 处理请求             ...............................17
                  6.3.1.1. 生成成功或错误响应                  .......17
                  6.3.1.2. 发送成功或错误响应                    .....18
           6.3.2. 处理指示                 ...........................18
           6.3.3. 处理成功响应                  ......................19
           6.3.4. 处理错误响应                 .......................19
   7. 指纹机制              ..........................................20
   8. 服务器的DNS发现           ......................................20
      8.1. STUN URI 方案语义         .................................21
   9. 身份验证和消息完整性机制                        ................22
      9.1. 短期凭证机制                    ...........................23
           9.1.1. HMAC Key ...........................................23
           9.1.2. 生成请求或指示                  ....................23
           9.1.3. 接收请求或指示                    ..................23
           9.1.4. 接收响应             ...............................25
           9.1.5. 发送后续请求                ........................25
      9.2. 长期凭证机制                   ............................26
           9.2.1. Bid-Down Attack 预防       .........................27
           9.2.2. HMAC Key ...........................................27</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

           9.2.3. 生成请求          ..................................28
                  9.2.3.1. 第一次要求    .............................28
                  9.2.3.2. 后续请求            .......................29
           9.2.4. 接收请求            ................................29
           9.2.5. 接收响应             ...............................31
   10. ALTERNATE-SERVER 机制      ....................................33
   11. 向后兼容 RFC 3489                     .........................34
   12. 基本服务器行为        .........................................34
   13. STUN 用法   ...................................................35
   14. STUN 属性       ...............................................36
      14.1. MAPPED-ADDRESS ...........................................37
      14.2. XOR-MAPPED-ADDRESS .......................................38
      14.3. USERNAME .................................................39
      14.4. USERHASH .................................................40
      14.5. MESSAGE-INTEGRITY ........................................40
      14.6. MESSAGE-INTEGRITY-SHA256 .................................41
      14.7. FINGERPRINT ..............................................41
      14.8. ERROR-CODE ...............................................42
      14.9. REALM ....................................................44
      14.10. NONCE ...................................................44
      14.11. PASSWORD-ALGORITHMS .....................................44
      14.12. PASSWORD-ALGORITHM ......................................45
      14.13. UNKNOWN-ATTRIBUTES ......................................45
      14.14. SOFTWARE ................................................46
      14.15. ALTERNATE-SERVER ........................................46
      14.16. ALTERNATE-DOMAIN ........................................46
   15. 操作注意事项               ....................................47
   16. 安全注意事项            .......................................47
      16.1. 对协议的攻击                 .............................47
           16.1.1. 外部攻击        ...................................47
           16.1.2. 内部攻击       ....................................48
           16.1.3. Bid-Down 攻击    ..................................48
      16.2. 影响使用的攻击              ..............................50
           16.2.1. Attack I: 针对目标的 DDoS .........................51
           16.2.2. Attack II: 让客户端保持沉默   .....................51
           16.2.3. Attack III: 假冒客户端身份                    .....52
           16.2.4. Attack IV: 窃听          ..........................52
      16.3. 哈希敏捷性计划    ........................................52
   17. IAB 注意事项       ............................................53
   18. IANA 注意事项       ...........................................53
      18.1. STUN 安全功能注册表             ..........................53
      18.2. STUN 方法注册表       ....................................54
      18.3. STUN 属性注册表          .................................54
           18.3.1. 已更新属性         ................................55
           18.3.2. 新属性         ....................................55
      18.4. STUN 错误码注册表         ................................56
      18.5. STUN 密码算法注册表               ........................56</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

           18.5.1. 密码算法            ...............................57
                  18.5.1.1. MD5 ......................................57
                  18.5.1.2. SHA-256 ..................................57
      18.6. STUN UDP 和 TCP 端口号        ............................57
   19. RFC 5389 以来的变化    ........................................57
   20. 参考       ....................................................58
      20.1. 参考标准             .....................................58
      20.2. 参考信息               ...................................61
   附录 A.  用于确定STUN消息类型的C代码段                 ............64
   附录 B.  测试数据         .........................................64
     B.1.  使用 MESSAGE-INTEGRITY-SHA256 和 USERHASH 进行长期身份验证
           的示例请求                            .....................65
   Acknowledgements ..................................................66
   Contributors ......................................................66
   Authors' Addresses ................................................67
 
1.  介绍
 
   本规范中定义的NAT会话穿透工具(STUN)协议提供了用于处理网络地址转换器(NAT)的工具。它为端点提供了一种确定NAT分配的IP地址和端口的方法，该NAT对应于其私有IP地址和端口。它还为终端提供了一种使NAT绑定保持活动的方法。通过某些扩展，该协议可用于在两个终端之间进行连通性检查[RFC8445]或在两个终端之间中继分组[RFC5766]。





  与其工具性质一致，本规范定义了一种可扩展的数据包格式，定义了几种传输协议上的操作，并提供了两种形式的身份验证。


  STUN旨在用于一个或多个NAT穿越解决方案的环境中。这些解决方案被称为“STUN用法”。每种用法都描述了如何利用 STUN 来实现 NAT 穿透解决方案。通常，用法指示何时发送 STUN 消息、要包括哪些可选属性、使用什么服务器以及要使用什么身份验证机制。交互式连接建立(ICE)[RFC8445]是STUN的一种用法。 SIP Outbound [RFC5626] 是STUN的另一种用法。在某些情况下，使用需要扩展到STUN。STUN扩展可以是新方法、属性或错误响应代码的形式。有关 STUN 用法的更多信息可在第13节中找到。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

2.  Overview of Operation
 
   This section is descriptive only.
 
                           /-----\
                         // STUN  \\
                        |   服务器  |
                         \\       //
                           \-----/




                      +--------------+             公共网络
      ................|     NAT 2    |.......................
                      +--------------+



                      +--------------+             私有网络 2
      ................|     NAT 1    |.......................
                      +--------------+




                           /-----\
                         // STUN  \\
                        |   客户端  |
                         \\       //               私有网络 1
                           \-----/

                      图1：一种可能的STUN配置
 
   图1显示了一种可能的STUN配置。在此配置中，有两个实现STUN协议的实体(称为STUN代理)。图中下面的代理是客户端，连接到内网1，该网络通过NAT 1连接到内网2，内网2通过NAT 2连接到公网，图中上面的代理是服务器，驻留在公网上。
 
   
  STUN是一种客户端-服务器协议。它支持两种类型的事务。一种是请求/响应事务，其中客户端向服务器发送请求，服务器返回响应。第二个是指示事务，在该事务中，代理--客户端或服务器--发送不生成响应的指示。这两种类型的交易都包括事务ID，它是随机选择的96位数字。对于请求/响应事务，此事务ID允许客户端将响应与生成它的请求相关联；对于指示，事务ID用作调试辅助。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

   




 
   所有STUN消息都以一个固定的标头开始，该标头包括一个方法、一个类和事务ID。该方法指示这是各种请求或指示中的哪一个；本规范只定义了一个方法，即绑定，但其他方法预计将在其他文档中定义。该类指示这是请求、成功响应、错误响应还是指示。在固定报头之后是零个或多个属性，这些属性是为特定消息传递附加信息的 类型-长度-值 扩展。
 





   本文档定义了一个名为“Binding”的方法。绑定方法既可用于请求/响应事务，也可用于指示事务。当在请求/响应事务中使用时，绑定方法可用于确定NAT已分配给STUN客户端的特定绑定。在请求/响应或指示事务中使用绑定方法时，也可以使用绑定方法来保持这些绑定有效。
 
   在绑定请求/响应事务中，从STUN客户端向STUN服务器发送绑定请求。当绑定请求到达STUN服务器时，它可能已经通过了STUN客户端和STUN服务器之间的一个或多个NAT(在图1中，有两个这样的NAT)。当绑定请求报文通过NAT时，NAT会修改报文的源传输地址(即源IP地址和源端口)。因此，服务器接收到的请求的源传输地址将是NAT创建的离服务器最近的公共IP地址和端口。这称为“自反式传输地址”。STUN服务器将源传输地址复制到STUN绑定响应中XOR-MAPPED-ADDRESS 属性中，并将绑定响应发送回STUN客户端。当此数据包通过NAT传回时，NAT将修改IP报头中的目的传输地址，但STUN响应正文中的XOR-MAPPED-ADDRESS属性中的传输地址将保持不变。通过这种方式，客户端可以获知由最外层的NAT相对于STUN服务器分配的其自反传输地址。
 
   在某些用法中，STUN必须与其他协议(例如，[RFC8445]和[RFC5626])多路传输。在这些用法中，必须有一种方法来检查数据包并确定它是否是STUN数据包。STUN在STUN报头中提供了三个字段，其中包含可用于此目的的固定值。如果这还不够，则STUN分组还可以包含FINGERPRINT值，该指纹值可以进一步用于区分分组。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 






 
   
  STUN定义了一组可供使用者决定使用的可选过程，称为“机制”。这些机制包括DNS发现、到备用服务器的重定向技术、用于多路分解的指纹属性以及两个身份验证和消息完整性交换。身份验证机制围绕用户名、密码和消息完整性值的使用展开。在本说明书中定义了两种认证机制，即长期凭证机制和短期凭证机制。每个用法都指定了该用法所允许的机制。




  在长期凭证机制中，客户端和服务器共享预先提供的用户名和密码，并执行摘要质询/响应交换，该交换受为HTTP[RFC7616]定义的摘要质询/响应交换的启发，但在细节上有所不同。在短期凭证机制中，客户端和服务器在STUN交换之前通过某种带外方法交换用户名和密码。例如，在ICE使用[RFC8445]中，两个端点使用带外信令来交换用户名和密码。它们用于完整性保护和验证请求和响应。没有挑战，也没有使用临时名词。
 



3.  术语
 
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and   "OPTIONAL" in this document are to be interpreted as described in   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all   capitals, as shown here.
 
4.  定义
 
   
  STUN代理：STUN代理是实现STUN协议的实体。该实体可以是STUN客户端或STUN服务器。

  STUN客户端：STUN客户端是发送STUN请求并接收STUN响应和STUN指示的实体。STUN客户端也可以发送指示。在本说明书中，术语“STUN CLIENT”和“CLIENT”同义。

  STUN服务器：STUN服务器是接收STUN请求和STUN指示并发送STUN响应的实体。STUN服务器也可以发送指示。在本说明书中，术语“STUN服务器”和“服务器”是同义词。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

   传输地址：IP地址和端口号(如UDP或TCP端口号)的组合。
 
   
  自反传输地址：客户端获取的传输地址，用于标识IP网络上的另一台主机(通常是STUN服务器)所看到的该客户端。当客户端和其他主机之间存在中间NAT时，自反传输地址表示分配给NAT公共端上的客户端的映射地址。自反传输地址是从STUN响应中的映射地址属性((
 MAPPED-ADDRESS 或 XOR-MAPPED-ADDRESS)获取的。
 




  映射地址：与反身地址含义相同。仅由于历史原因以及由于MAPPED-ADDRESS和
XOR-MAPPED-ADDRESS属性的命名，才保留此术语。
 


  长期凭据：代表客户端和服务器之间共享机密的用户名和关联密码。长期凭证通常在订户注册服务时授予客户端，并持续到订户离开服务或显式更改凭证为止。
 


  长期密码：来自长期凭据的密码。
 
   
  短期凭据：代表客户端和服务器之间共享机密的临时用户名和关联密码。在STUN交换之前，通过客户端和服务器之间的某种协议机制获得短期凭证。短期凭证具有明确的时间范围，它可以基于特定的时间量(例如5分钟)或基于事件(例如终止会话发起协议(SIP)[RFC3261]对话)。短期凭据的具体范围由应用程序使用情况定义。
 



   短期密码：短期凭证的密码组件。
 
   STUN指示：未收到响应的STUN消息。
 
   属性：可以添加到STUN消息中的Type-Length-Value(TLV)对象的STUN术语。属性分为两种类型：理解-必需和理解-可选。STUN代理可以安全地忽略理解--他们不理解的可选属性，但如果消息包含不理解的必需属性，则无法成功处理。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

   
  RTO：重新传输超时，定义从传输请求到第一次重新传输该请求之间的初始时间段。
 

5.  STUN 消息结构
 
   STUN消息使用网络字节顺序(最高有效字节或八位字节优先，通常也称为大端)。传输顺序在[RFC0791]的附录&amp;B中有详细说明。除非另有说明，数值常量以十进制(以10为基数)表示。
 
   所有STUN消息都包括一个20字节的报头，后跟零个或多个属性。STUN标头包含STUN消息类型、消息长度、魔力Cookie和事务ID。
 
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |0 0|     STUN 消息类型         |         消息长度              |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                         Magic Cookie                          |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     |                         事务ID (96 bits)                      |
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                        Figure 2: STUN 报头结构
 



   每个STUN消息的最高有效2位必须为零。当STUN与同一端口上的其他协议多路复用时，这可用于将STUN分组与其他协议区分开来。


  消息类型定义STUN消息的消息类别(请求、成功响应、错误响应或指示)和消息方法(主要功能)。尽管有四种消息类别，但STUN中只有两种类型的事务：请求/响应事务(由请求消息和响应消息组成)和指示事务(由单个指示消息组成)。响应类别分为错误响应和成功响应，以帮助快速处理STUN消息。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

   
   STUN消息类型字段进一步分解为以下结构：
 
                       0                 1
                       2  3  4 5 6 7 8 9 0 1 2 3 4 5
                      +--+--+-+-+-+-+-+-+-+-+-+-+-+-+
                      |M |M |M|M|M|C|M|M|M|C|M|M|M|M|
                      |11|10|9|8|7|1|6|5|4|0|3|2|1|0|
                      +--+--+-+-+-+-+-+-+-+-+-+-+-+-+
 
                      图 3: STUN消息类型字段格式
 
   
  这里，STUN消息类型字段中的比特被显示为最高有效(M11)到最低有效(M0)。M11到M0表示该方法的12位编码。C1和C0表示类的2位编码。0b00类是请求，0b01类是指示，0b10类是成功响应，0b11类是错误响应。该规范定义了单个方法，即Binding。方法和类是正交的，因此对于每个方法，该方法的请求、成功响应、错误响应和指示都是可能的。定义新方法的扩展必须指示该方法允许哪些类。
 
   
  例如，绑定请求具有CLASS=0b00(请求)和METHOD=0b000000000001(绑定)，并被编码到前16位作为0x0001。Binding响应具有CLASS=0b10(成功响应)和METHOD=0b000000000001，并编码为0x0101的前16位。





  注意：这种错误的编码是由于[RFC3489]中的赋值没有考虑使用位字段对指示消息、成功响应和错误响应进行编码。
 


  魔力Cookie字段必须包含网络字节顺序的固定值0x2112A442。在[RFC3489]中，组成魔力Cookie字段的32位是事务ID的一部分；将魔力Cookie放在此位置允许服务器检测客户端是否会理解[RFC5389]添加到STUN的某些属性。此外，当STUN在同一端口上与其他协议多路复用时，它有助于将STUN分组与其他协议的分组区分开来。
 
</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 


  事务ID是一个96位的标识符，用于唯一标识STUN事务。对于请求/响应事务，事务ID由STUN客户端为请求选择，并由服务器在响应中回显。对于指示，它由发送指示的代理选择。它主要用于将请求与响应相关联，尽管它在帮助防止某些类型的攻击方面也起到了很小的作用。服务器还使用事务ID作为关键字，以便在所有客户端中唯一地标识每个事务。因此，事务ID必须从区间0 - 2**96-1 中均匀且随机地选择，并且必须是加密级的随机。相同请求的重新发送重复使用相同的事务ID，但客户端必须为新事务选择新的事务ID，除非新请求与前一个请求逐位相同，并且从相同的传输地址发送到相同的IP地址。成功和错误响应必须携带与其相应请求相同的事务ID。当代理在同一端口上充当STUN服务器和STUN客户端时，代理发送的请求中的事务ID与代理收到的请求中的事务ID没有关系。
 

  消息长度必须包含消息的大小(以字节为单位)，不包括20字节的STUN标头。由于所有STUN属性都填充为4字节的倍数，因此该字段的最后2位始终为零。这提供了将STUN分组与其他协议的分组区分开来的另一种方式。

  在 STUN 的固定头部部分之后是零个或多个属性。每个属性都是 TLV(Type-Length-Value)编码。第14节给出了编码和属性本身的详细信息。
 





6.  基本协议程序
 
  本节定义了 STUN 协议的基本程序。它描述了如何生成消息、如何发送消息，以及如何在接收到消息时对其进行处理。它还定义了绑定方法的详细处理。本文档中的其他部分描述了使用者在某些情况下可能选择使用的可选程序。其他文档可以通过添加新方法、新属性或新错误响应代码来定义 STUN 的其他扩展。
 



6.1.  生成请求或指示
 
    在生成请求或指示消息时，代理在创建标头时必须遵守第5节中的规则。此外，消息类必须是“请求”或“指示”(视情况而定)，方法必须是 Binding 或在其他文档中定义的某个方法。
 
    然后，代理添加由该方法或用法指定的任何属性。例如，某些用法可能指定代理使用身份验证方法(第9节)或 FINGERPRINT 属性(第7节)。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 



    如果代理正在发送请求，它应该向该请求添加 SOFTWARE 属性。根据方法的不同，代理可能会在指示中包含 SOFTWARE 属性。STUN的扩展应该讨论 SOFTWARE 在新的适应症中是否有用。请注意，包含 SOFTWARE 属性可能会带来安全隐患；有关详细信息，请参见第16.1.2节。
 
    对于无身份验证的 Binding 方法，除非用法另行指定，否则不需要任何属性。
 
    所有通过 UDP 或 DTLS-over-UDP[RFC6347] 发送的 STUN 消息应小于路径 MTU (如果已知)。
 
    如果 UDP 的路径 MTU 未知，则消息应为576字节和第一跳 MTU(对于IPv4[RFC1122])和1280字节(对于IPv6[RFC8200])中的较小者。该值对应于 IP 包的总大小。因此，对于IPv4，实际的 STUN 消息需要少于548字节(576减去20字节的IP报头，减去8字节的UDP报头，假设没有使用IP选项)。



 
    如果 DTLS-over-UDP 的路径 MTU 未知，则需要调整上一段中描述的规则，以考虑(13字节)DTLS记录头的大小、消息验证码(MAC)大小和填充大小。
 


    当请求小于 MTU 但响应大于 MTU 时，STUN 无法处理这种情况。这一限制不会成为STUN的问题。对于使用 STUN 本身来探测 MTU 特征的情况，MTU 限制是应该的，而不是必须的[RFC5780]。另请参阅[STUN-PMTUD]，了解使用 STUN 向缺乏此类机制的协议添加路径 MTU 发现的框架。在此应用或类似应用之外，必须遵循 MTU 约束。
 


6.2.  发送请求或指示
 
    然后，代理发送请求或指示。本文档详细说明了如何通过 UDP、TCP、TLS-over-TCP 或DTLS-over-UDP 发送 STUN 消息；未来可能会添加其他传输协议。STUN 用法必须指定使用哪个传输协议，以及代理如何确定收件人的IP地址和端口。第8节描述了一种基于 DNS 的方法，用于确定用户可以选择使用的服务器的IP地址和端口。
 
    在任何时候，客户端都可能具有具有相同 STUN 服务器的多个未完成的 STUN 请求(即，具有不同事务ID的多个正在进行的事务)。如果没有对新事务速率的其他限制(例如，ICE 为连通性检查指定的限制，或者当 STUN 在 TCP 上运行时)，客户端应该限制自己对同一服务器不超过10个未完成事务。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

   
 



6.2.1.  通过 UDP or DTLS-over-UDP 发送
 
    通过 UDP 或 DTLS-Over-UDP[RFC7350] 运行 STUN 时，网络可能会丢弃 STUN 消息。STUN 请求/响应事务的可靠性是通过客户端应用程序本身重传请求消息来实现的。STUN 指示不会重新传输；因此，通过 UDP 或 DTLS-over-UDP 的指示事务是不可靠的。




    客户端应该以 RTO(重传超时)的间隔开始重传 STUN 请求消息，在每次重传之后加倍。RTO 是对往返时间(RTT)的估计，按照[RFC6298]中所述进行计算，但有两个例外。首先，RTO的初始值应大于或等于500ms。当使用其他机制来派生拥塞阈值(例如，ICE 中为固定速率流定义的那些机制)时，或者在具有已知网络容量的非互联网环境中使用 STUN 时，就是这种情况的例外情况。在固网接入链路中，建议取值为500 ms。其次，RTO 的值不应向上舍入到最接近的秒。相反，应该保持1毫秒的精度。与 TCP 一样，推荐使用 Karn算法[KARN87]。当应用于 STUN 时，这意味着 RTT 估计不应从导致重新传输请求的 STUN 事务中计算。
 





   RTO 的值应在事务完成后由客户端缓存，并用作下一事务到同一服务器的 RTO 的起始值(基于相等的IP地址)。如果同一服务器在过去10分钟内未发生任何事务，则应认为该值已过时并被丢弃。





   重传将继续，直到接收到响应或发送了总共的 RC 次请求。RC 应该是可配置的，并且应该具有默认值7。如果在最后一个请求之后，持续时间等于 Rm 倍的 RTO 已经过去而没有响应(如果只有这个最终请求实际成功，则提供充足的时间来获得响应)，则客户端应该认为该事务已经失败。Rm 应该是可配置的，并且应该具有默认值16。如果存在硬 ICMP 错误[RFC1122]，则通过 UDP 或 DTLS-over-UDP 的 STUN 事务也被视为失败。例如，假设 RTO 为 50 0ms，则将在0 ms、500 ms、1500 ms、3500 ms、7500 ms、15500 ms 和 31500 ms的时间发送请求。如果客户端在 39500 ms 后仍未收到响应，则客户端将认为事务已超时。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 


6.2.2.  通过 TCP 或 TLS-over-TCP 发送
 
   对于 TCP and TLS-over-TCP [RFC8446], 客户端打开到服务器的TCP连接.
 

    在STUN的某些用法中，STUN 是通过 TCP 连接的唯一协议。在这种情况下，无需任何额外的成帧或解复用即可发送。在其他用法或其他扩展中，它可以通过 TCP 连接与其他数据进行多路传输。在这种情况下，STUN 必须在某种成帧协议之上运行，该协议由用法或扩展指定，允许代理提取完整的 STUN 消息和完整的应用层消息。在通过第8节中的 DNS 程序发现的一个或多个知名端口上运行的 STUN 服务仅用于 STUN ，而不用于 STUN 与其他数据的多路复用。因此，在连接到这些服务器时不使用任何成帧协议。当使用额外的成帧时，用法将指定客户端如何知道如何应用它以及要连接到哪个端口。例如，在 ICE 连接检查的情况下，此信息通过客户端和服务器之间的带外协商获取。
 







    TCP 和 TLS-over-TCP 上的 STUN 的可靠性由 TCP 本身处理，并且在 STUN 协议层上不存在重传。然而，对于请求/响应事务，如果客户端在其发送请求消息之后的 Ti 秒内仍未收到响应，则认为该事务已超时。Ti 应该是可配置的，并且应该具有 39.5 s 的默认值。选择此值是为了使默认初始 RTO 的 TCP 和 UDP 超时相等。
 


    此外，如果客户端无法建立TCP连接，或者在接收到响应之前重置或失败了TCP连接，则认为正在进行的任何请求/响应事务都已失败。
 


    客户端可以通过单个 TCP(或TLS-over-TCP) 连接发送多个事务，并且它可以在接收到对先前请求的响应之前发送另一个请求。客户端应保持连接打开，直到：
 
   o  没有进一步的 STUN 请求或指示来通过该连接发送，
 
   o  没有计划使用通过该连接发送的 STUN 请求获取的任何资源(例如映射地址( MAPPED-ADDRESS or XOR-MAPPED-ADDRESS )或中继地址[RFC5766])，</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 



   o  如果在该端口上多路复用其他应用协议，并且已经完成使用这些其他协议，
 
   o  如果与远程对等方使用该学习端口，则已建立与该远程对等方的通信，这是某些 TCP NAT穿透技术(例如，[RFC6544])所要求的。
 

    最终的 keep-alive 机制的细节将由每一个 STUN 用法去定义。在任何情况下，如果事务因为空闲的 TCP 连接不再工作而失败，客户端应该发送 RST 并尝试打开新的 TCP 连接。
 
    在服务器端，服务器应保持连接打开，并让客户端关闭连接，除非服务器已确定连接已超时(例如，由于客户端与网络断开连接)。只有当连接保持打开时，客户端获知的绑定才会在介入NAT中保持有效。只有客户端知道它需要绑定多长时间。如果连接存在未发送响应的请求，则服务器不应关闭该连接。服务器绝不能为了发送响应而打开回客户端的连接。在超载的情况下，服务器应遵循有关连接管理的最佳实践。
 






6.2.3.  通过 TLS-over-TCP 或 DTLS-over-UDP 发送
 
    当 STUN 通过 TLS-over-TCP 或 DTLS-over-UDP 单独运行时，必须实现TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 和 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 加密套件(为了与此协议的旧版本兼容)，除非特定 STUN 用法的规则已弃用。可以实现其他密码组。请注意，实施 TLS 1.3版[RFC8446]或更高版本的 STUN 客户端和服务器也需要实施这些规范中的强制密码套件，并应在检测到支持这些规范时禁用不推荐使用的密码套件。完全前向保密(PFS)密码组必须优先于非PFS密码组。不能使用具有已知弱点的密码套件，例如基于(单一)DES和RC4的密码套件。实现必须禁用TLS级别的压缩。
 





    这些建议只是 [BCP195] 中建议的一部分，即使用 TLS 或 DTLS 实施和部署 STUN 用法必须遵循。

   当收到 TLS 证书消息时，客户端必须验证证书并检查证书所标识的站点。如果证书无效或被吊销，或者如果证书没有标识适当的一方，则客户端不得发送 STUN 消息或以其他方式继续 STUN 事务。客户端必须验证服务器的身份。为此，它遵循[RFC6125]中定义的标识程序，使用包含类型为 DNS-ID 或 CN-ID 的标识符的证书，可选择使用通配符作为最左侧的标签，但不包含类型 SRV-ID 或 URI-ID。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 









 
   当 STUN 在 TLS-over-TCP 连接或 DTLS-over-UDP 关联上与其他协议多路传输时，强制密码组和 TLS 处理过程按照这些协议定义的方式运行。
 
6.3.  接收 STUN 消息
 
    本部分指定 STUN 消息的处理。此处指定的处理是针对本规范中定义的 STUN 消息；向后兼容性的附加规则在第11节中定义。这些附加过程是可选的，用户可以选择使用它们。首先，应用一组独立于类的处理操作。这之后是特定于类的处理，将在下面的小节中进行描述。
 




    当 STUN 代理收到 STUN 消息时，它首先检查该消息是否符合第5节的规则。它检查前两位是否为0，Magic Cookie 字段是否具有正确的值，消息长度是否合理，以及方法值是否为受支持的方法。它检查特定方法是否允许该消息类。如果消息类别为“Success Response”或“Error Response”，则代理检查事务ID是否与仍在进行中的事务匹配。如果正在使用 FINGERPRINT 扩展，代理将检查 FINGERPRINT 属性是否存在并包含正确的值。如果检测到任何错误，消息将以静默方式丢弃。在 STUN 与其他协议多路传输的情况下，错误可能指示这不是真正的 STUN 消息；在这种情况下，代理应尝试将该消息解析为不同的协议。
 





   然后，STUN代理执行用法指定的身份验证机制所需的任何检查(参见第9节)。
 



    身份验证检查完成后，STUN代理将检查消息中的未知属性和已知但意外的属性。未知理解-代理必须忽略可选属性。代理应忽略已知但意外的属性。未知的理解-必需的属性依赖于消息类的处理，如下所述。此时，进一步的处理取决于请求的消息类。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 




 
6.3.1.  处理请求
 
    如果请求包含一个或多个未知的理解必需属性，服务器将使用错误代码420(未知属性)回复错误响应，并在响应中的 UNKNOWN-ATTRIBUTES 属性中列出无法理解的理解必须属性。
 
    否则，服务器将执行该方法或特定用法所需的任何附加检查。如果所有检查都成功，服务器将生成如下所述的成功响应。
 




    当在 UDP 或 DTLS-over-UDP 上运行时，服务器收到的请求可能是事务的第一个请求，也可能是重新传输。服务器必须对重传作出响应，以便保留以下属性：如果客户端接收到对重传的响应，而没有接收到发送给原始请求的响应，则客户端和服务器上的总体状态与仅接收到对原始重传的响应或同时接收到两个响应的情况相同(在这种情况下，客户端将使用第一个响应)。满足这一要求的最简单方法是让服务器记住通过 UDP 或 DTLS-over-UDP 接收的所有事务ID及其在最后40秒内的相应响应。但是，这要求服务器保持状态，并且不适合任何未经身份验证的请求。另一种方法是重新处理请求并重新计算响应。后一种技术只能应用于幂等的请求(当相同的请求可以安全地重复而不影响系统的整体状态时，该请求被认为是幂等的)，并且对相同的请求产生相同的成功响应。Binding 方法被认为是幂等的。请注意，某些罕见的网络事件可能会导致自反传输地址值发生变化，从而在不同的成功响应中产生不同的映射地址。STUN 的扩展必须讨论在不存储事务状态的服务器上重新传输请求的含义。
 











6.3.1.1.  生成成功或失败响应
 
    在形成响应(成功或错误)时，服务器遵循第6节的规则。响应的方法与请求的方法相同，消息类为成功响应或错误响应。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 



    对于错误响应，服务器必须添加包含上述处理中指定的错误代码的 ERROR-CODE 属性。原因短语不是固定的，但应该是适合错误代码的内容。对于某些错误，会向消息中添加其他属性。这些属性在指定错误代码的描述中进行了详细说明。例如，对于错误代码420(未知属性)，服务器必须包含未知属性。某些身份验证错误还会导致添加属性(参见第9节)。扩展可以定义在错误情况下要添加的其他错误和/或附加属性。
 




    如果服务器使用身份验证机制对请求进行身份验证，则服务器应该将适当的身份验证属性添加到响应中(参见第9节)。
 
    服务器还添加特定方法或用法所需的任何属性。此外，服务器还应向消息中添加 SOFTWARE 属性。
 
    对于 Binding 方法，除非用法另有说明，否则不需要额外的检查。在形成成功响应时，服务器向响应添加 XOR-MAPPED-ADDRESS 属性；该属性包含请求消息的源传输地址。对于 UDP 或 DTLS-over-UDP，这是请求消息的源IP地址和源 UDP 端口。对于 TCP 和 TLS-over-TCP，这是服务器看到的 TCP 连接的源IP地址和源tcp端口。
 




6.3.1.2.  发送成功或错误响应
 
    响应(成功或错误)通过与接收请求相同的传输发送。如果通过 UDP 或 DTLS-over-UDP 接收请求，则响应的目的IP地址和端口为接收到的请求报文的源IP地址和端口，并且响应的源IP地址和端口等于接收到的请求报文的目的IP地址和端口。如果请求是通过 TCP 或 
TLS-over-TCP 接收的，则响应将在接收请求的同一个TCP连接上发回。
 



    允许服务器以与其接收请求不同的顺序发送响应。
 
6.3.2.  处理指示
 
    如果该指示包含未知的理解必须属性，则该指示被丢弃并且处理停止。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

    否则，代理将执行该方法或特定用法所需的任何附加检查。如果所有检查都成功，则代理将处理该指示。不会为指示生成响应。
 


    对于 Binding 方法，除非用法另有说明，否则不需要额外的检查或处理。代理仅收到消息就刷新了中间 NAT 中的绑定。
 


    由于指示不在 UDP 或 DTLS-over-UDP 上发起重新传输(与请求不同)，因此不需要在发送代理处处理指示的重新传输。
 

6.3.3.  处理成功响应
 
    如果成功响应包含未知的理解必须属性，则会丢弃该响应，并认为事务已失败。
 


    否则，客户端将执行该方法或特定用法所需的任何附加检查。如果所有检查都成功，则客户端随后处理成功响应。
 
    对于 Binding 方法，客户端检查响应中是否存在 XOR-MAPPED-ADDRESS 属性。客户端检查指定的地址族。如果它是不受支持的地址族，则应忽略该属性。如果它是意外但受支持的地址系列(例如，绑定事务通过 IPv4 发送，但指定的地址系列是 IPv6 )，则客户端可以接受并使用该值。
 



6.3.4.  处理错误响应
 
    如果错误响应包含未知的理解必须属性，或者如果错误响应不包含 ERROR-CODE 属性，则事务被简单地视为已失败。
 
    否则，客户端将执行身份验证机制指定的任何处理(请参见第9节)。这可能会导致新的事务尝试。
 

    此时的处理取决于错误代码、方法和用法；以下是默认规则：
 

   o  如果错误代码是300到399，客户端应该认为事务失败，除非正在使用备用服务器扩展(第10节)。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 



   o  如果错误代码是400到499，则客户端声明事务失败；在420(未知属性)的情况下，响应应该包含一个提供附加信息的 UNKNOWN-ATTRIBUTES 属性。
 

   o  如果错误代码是500到599，客户端可以重新发送请求；这样做的客户端必须限制他们这样做的次数。除非特定错误代码指定了不同的值，否则重新传输的次数应限制为4次。
 
   任何其他错误代码都会导致客户端认为事务失败。
 
7.  FINGERPRINT 机制
 
    本节介绍一种用于 STUN 的可选机制，当STUN消息和其他协议的分组在同一传输地址上多路复用时，该机制有助于将 STUN 消息与它们区分开来。此机制是可选的，STUN 用法必须描述是否以及何时使用它。指纹机制不向后兼容RFC 3489，不能在需要这种兼容性的环境中使用。
 



    在某些用法中，STUN消息与实时传输协议(RTP)等其他协议在相同的传输地址上进行多路传输。为了应用第6节中描述的处理，必须首先将 STUN 消息与应用程序数据分组分开。
 


   第5节描述了 STUN 报头中可用于此目的的三个固定字段。但是，在某些情况下，这三个固定字段可能还不够。
 
    当使用指纹扩展时，代理在其发送给另一个代理的消息中包括 FINGERPRINT 属性。第14.7节描述了该属性的位置和值。
 
    当代理收到它认为是 STUN 消息的消息时，除了其他基本检查外，代理还会检查该消息是否包含 FINGERPRINT 属性以及该属性是否包含正确的值。第6.3节描述了在 STUN 消息的整体处理中何时执行指纹检查。此附加检查有助于代理检测其他协议的消息，否则这些消息可能看起来是STUN消息。
 
8.  服务器的DNS发现
 
    本节介绍 STUN 的一个可选过程，该过程允许客户端使用DNS来确定服务器的IP地址和端口。STUN 用法必须描述是否以及何时使用此扩展。要使用此过程，客户端必须知道 STUN URI[RFC7064]；用法还必须描述客户端如何获取此 URI。不建议将 STUN URI 硬编码到软件中，以防域名丢失或因法律或其他原因需要更改。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

  




 
   当客户端希望在公共互联网上定位接受绑定请求/响应事务的 STUN 服务器时，STUN URI 方案是“stun”。当它希望定位通过 TLS 或 DTLS 会话接受绑定请求/响应事务的 STUN 服务器时，URI方案是“stuns”。
 
   “stun”和“stuns”URI的语法在[RFC7064]的3.1节中定义。STUN用法可以定义附加的URI方案。
 

8.1.  STUN URI 方案语义
 
    如果“stun”URI的 <host> 部分包含IP地址，则该IP地址将直接用于联系服务器。必须拒绝包含IP地址的“stuns”URI。未来的 STUN 扩展或使用可能会放宽这一要求，前提是它演示了如何对STUN服务器进行身份验证并防止中间人攻击。
 


    如果 URI 不包含IP地址，则使用[RFC2782]中指定的 SRV 过程将 <host> 部分中包含的域名解析为传输地址。DNS SRV 服务名称是 <schema> 部分的内容。SRV 查找中的协议是客户端将在其上运行 STUN 的传输协议：“udp”用于 UDP，“tcp”用于 TCP。
 


    遵循 RFC 2782 的程序来确定要联系的服务器。RFC 2782 详细说明了如何对一组 SRV 记录进行排序和尝试。然而，RFC 2782 只声明客户端应该“尝试连接到(协议、地址、服务)”，而没有给出在故障情况下会发生什么的任何细节。在执行这些过程时，如果 STUN 事务超时而未收到响应，则客户端应按 RFC 2782 定义的顺序重试对下一台服务器的请求。由于指示事务不产生响应或超时，因此这种重试仅对于请求/响应传输是可能的。
 




    此外，不是查询域名的A或AAAA资源记录，而是双栈IPv4/IPv6客户端必须同时查询这两个资源记录，并尝试接收到所有IP地址的请求，如[RFC8305]中所指定的。
 
   对于 TCP 和 UDP，STUN 请求的默认端口都是 3478。TLS 上的 STUN 和 DTLS 请求上的STUN 的默认端口是 5349。如果服务器软件支持检测初始消息是 DTLS 消息还是STUN消息，则服务器可以在与 STUN Over UDP 相同的端口上通过 DTLS 运行 STUN。如果服务器软件支持检测初始消息是 TLS 消息还是 STUN 消息，则服务器可以在 TLS 上运行 STUN ，就像STUN 在 TCP 上运行 STUN 一样。</schema></host></host></pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

  



  
    STUN 服务器的管理员应在其用于 UDP 和 TC P的 SRV 记录中使用这些端口。在所有情况下，DNS 中的端口都必须反映服务器正在侦听的端口。
 
   如果未找到 SRV 记录，客户端将执行域名的 A 和 AAAA 记录查找，如[RFC8305]中所述。结果将是一个IP地址列表，每个IP地址都可以在默认端口上使用 UDP 或 TCP 同时联系，而与 STUN 的使用无关。对于需要 TLS 的用法，客户端使用 STUN over TLS 默认端口 STUN 连接到 IP 地址。对于需要 DTLS 的使用，客户端使用 STUN over DTLS 默认端口连接到IP地址。
 




9.  身份验证和消息完整性机制
 
    本节定义了两种 STUN 机制，客户端和服务器可以使用它们来提供身份验证和消息完整性；这两种机制称为短期凭据机制和长期凭据机制。这两种机制是可选的，每种用法都必须指定是否以及何时使用这些机制。因此，客户端和服务器都将根据对使用情况的了解知道要遵循哪种机制(如果有的话)。例如，支持 ICE 的公共互联网上的 STUN 服务器将没有身份验证，而支持连接检查的代理中的 STUN 服务器功能将使用短期凭据。第2节概述了这两种机制。





 
    每种机制都指定了使用该机制所需的附加处理，扩展了第6节中指定的处理。附加处理发生在三个不同的地方：生成消息时、在收到消息并执行基本检查后以及执行错误响应的详细处理时。
 
    请注意，代理必须忽略 MESSAGE-INTEGRITY 之后的所有属性，但 
MESSAGE-INTEGRITY-SHA256 和 FINGERPRINT 属性除外。同样，如果 MESSAGE-INTEGRITY 属性不存在，则代理必须忽略 MESSAGE-INTEGRITY-SHA256 属性后面的所有属性， FINGERPRINT 属性除外。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

9.1.  短期凭证机制
 
    短期凭证机制假定，在 STUN 事务之前，客户端和服务器已经使用某种其他协议来交换用户名和密码形式的凭证。此凭据有时间限制。时间限制是由使用情况决定的。例如，在ICE用法[RFC8445]中，两个端点使用带外信令来协商用户名和密码，并且此用户名和密码适用于媒体会话的持续时间。
 
    此凭据用于在每个请求和许多响应中形成消息完整性检查。与长期机制不同，没有挑战和回应；因此，由于凭证的时间限制，重放受到限制。





 
9.1.1.  HMAC Key
 
    对于短期凭据，基于哈希的消息验证码(HMAC)密钥定义如下：
 
                       key = OpaqueString(password)
 
   其中 OpaqueString 配置文件在[RFC8265]中定义。使用的编码为UTF-8[RFC3629]。
 
9.1.2.  生成请求或指示
 
    对于请求或指示消息，代理必须在消息中包括 USERNAME 、MESSAGE-INTEGRITY-SHA256和 MESSAGE-INTEGRITY 属性，除非代理从外部机制知道这两个代理都支持哪种消息完整性算法。在这种情况下，除了 USERNAME 之外，还必须包括 MESSAGE-INTEGRITY 或
 MESSAGE-INTEGRITY-SHA256 。 MESSAGE-INTEGRITY 属性的 HMAC 按第14.5节所述计算， MESSAGE-INTEGRITY-SHA256 属性的 HMAC 按第14.6节所述计算。请注意，密码从未包含在请求或指示中。
 
9.1.3.  接收请求或指示
 
    代理完成消息的基本处理后，将按指定的顺序执行以下列出的检查：
 
   o  如果消息不包含1) MESSAGE-INTEGRITY 或MESSAGE-INTEGRITY-SHA256 属性和 2)USERNAME 属性：</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

      *  如果消息是请求，则服务器必须以错误响应拒绝该请求。此响应必须使用错误代码400(错误请求)。
 
      *  如果该消息是指示，则代理必须静默丢弃该指示。
 
   o  如果 USERNAME 不包含服务器中当前有效的用户名：
 
      *  如果消息是请求，则服务器必须以错误响应拒绝该请求。此响应必须使用错误代码401(未经身份验证)。
 
      *  如果该消息是指示，则代理必须静默丢弃该指示。
 






   o  如果 MESSAGE-INTEGRITY-SHA256 属性存在，请使用与用户名相关联的密码，按照第14.6节中的说明计算消息完整性的值。如果 MESSAGE-INTEGRITY-SHA256 属性不存在，则使用相同的密码来计算消息完整性的值，如第14.5节所述。如果结果值与相应属性( 
MESSAGE-INTEGRITY-SHA256 或 MESSAGE-INTEGRITY )的内容不匹配：
 
      *  如果消息是请求，则服务器必须以错误响应拒绝该请求。此响应必须使用错误代码401(未经身份验证)。
 
      *  如果该消息是指示，则代理必须静默丢弃该指示。
 






    如果这些检查通过，代理将继续处理请求或指示。服务器对包含 MESSAGE-INTEGRITY-SHA256 属性的请求生成的任何响应都必须包括 MESSAGE-INTEGRITY-SHA256 属性，该属性使用用于对请求进行身份验证的密码进行计算。服务器对仅包含 MESSAGE-INTEGRITY 的请求生成的任何响应都必须包括 MESSAGE-INTEGRITY 属性，该属性使用用于验证请求的密码进行计算。这意味着这些属性中只有一个可以出现在响应中。响应不得包含用户名属性。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

    如果任何检查失败，则服务器不得在错误响应中包括 MESSAGE-INTEGRITY-SHA256 、MESSAGE-INTEGRITY 或 USERNAME 属性。这是因为，在这些故障情况下，服务器无法确定计算 MESSAGE-INTEGRITY-SHA256  或MESSAGE-INTEGRITY 属性所需的共享机密。
 



9.1.4.  接收响应
 
    客户端在响应中查找 MESSAGE-INTEGRITY 或 MESSAGE-INTEGRITY-SHA256 属性。如果存在，并且客户端仅发送请求中的 MESSAGE-INTEGRITY 或 MESSAGE-INTEGRITY-SHA256 属性之一(因为9.1.2节中的外部指示，或者因为这是9.1.5节中定义的后续请求)，则响应中的算法必须匹配；否则，必须丢弃该响应。
 


    然后，客户端使用它用于请求的相同密码，根据第14.5节的 MESSAGE-INTEGRITY 或 第14.6节的 MESSAGE-INTEGRITY-SHA256 属性定义，在响应上计算消息完整性。如果结果值分别与 MESSAGE-INTEGRITY 或 MESSAGE-INTEGRITY-SHA256 属性的内容匹配，则认为响应已通过身份验证。如果该值不匹配，或者如果 MESSAGE-INTEGRITY 和 MESSAGE-INTEGRITY-SHA256 都不存在，则处理取决于请求是通过可靠传输还是不可靠传输发送的。
 





    如果请求是通过不可靠的传输发送的，则必须丢弃响应，就像从未收到过一样。这意味着，如果适用，重新传输将继续。如果所有收到的响应都被丢弃，则该层必须发出完整性保护被违反的信号，而不是在结束事务后发出超时信号。
 
    如果请求是通过可靠传输发送的，则必须丢弃响应，并且该层必须立即结束事务并发出完整性保护被违反的信号。
 
9.1.5.  发送后续请求
 
   向同一服务器发送后续请求的客户端必须只发送与初始请求的响应中收到的属性匹配的 MESSAGE-INTEGRITY-SHA256 或 MESSAGE-INTEGRITY 属性。在这里，“相同的服务器”意味着相同的IP地址和端口号，而不仅仅是相同的URI或SRV查找结果。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

9.2. 长期凭证机制
 
    长期凭据机制依赖于长期凭据，其形式为在客户端和服务器之间共享的用户名和密码。凭据被认为是长期的，因为它假定它是为用户提供的，并且一直有效，直到该用户不再是系统的订户或直到它被更改。这基本上是提供给用户的传统的“登录”用户名和密码。
 





   由于这些用户名和密码预计在较长时间内有效，因此以摘要质询的形式提供重播预防。在此机制中，客户端最初发送请求，而不提供任何凭据或任何完整性检查。服务器拒绝该请求，为用户提供一个域(用于指导用户或代理选择用户名和密码)和一个随机数。随机数提供了有限的重播保护。它是一个Cookie，由服务器选择，并以某种方式进行编码，以指示其有效的持续时间或客户端身份。只有服务器需要知道Cookie的内部结构。客户端重试请求，这一次包括其用户名和域，并回显服务器提供的随机数。客户端还包括本文档中定义的消息完整性属性之一，该属性在整个请求(包括随机数)上提供HMAC。服务器验证该随机数并检查消息的完整性。如果它们匹配，则对请求进行身份验证。如果该随机数不再有效，则它被认为是“过时的”，并且服务器拒绝该请求，提供一个新的随机数。
 






    在对同一服务器的后续请求中，客户端将重复使用之前使用的随机数、用户名、领域和密码。这样，随后的请求不会被拒绝，直到服务器使随机数变得无效，在这种情况下，在拒绝的响应中向客户端提供新的随机数。
 
    请注意，长期凭证机制不能用于保护指示，因为指示不能被 challenged。利用指示的用法必须使用短期凭据，或者省略对它们的身份验证和消息完整性。
 
    要表明它支持此规范，服务器必须在 NONCE 属性值前面加上“obMatJos2”字符串，外加第18.1节中定义的24位STUN安全功能的(4字符)Base64[RFC4648]编码。24位安全功能集编码为3个字节，其中位0为第一个字节的最高有效位，位23为第三个字节的最低有效位。如果未使用任何安全功能，则必须改为对所有24位都设置为零的字节数组进行编码。在本文档的其余部分，术语“nonce cookie”指的是位于 NONCE 属性值前面的完整的13个字符的字符串。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

  



 
    由于长期凭据机制容易受到脱机字典攻击，因此部署应使用难以猜测的密码。如果凭证不是由用户输入的，而是在设备供应期间放置在客户端设备上的，则密码应具有至少128位的随机性。如果凭据是由用户输入的，则应遵循当前有关密码结构的最佳做法。
 



9.2.1.  Bid-Down 攻击预防
 
   本文档介绍了两个新的安全功能，它们提供了选择用于密码保护的算法以及使用匿名用户名的能力。为了保持与STUN协议的先前版本的向后兼容，这两个能力都是可选的。
 



   这些新功能会受到降价攻击，消息路径中的攻击者可以删除这些功能并强制更弱的安全属性。为了防止此类攻击未被检测到，nonce 被增强为附加信息。
 
   “nonce cookie”的值将根据所选的特定 STUN 安全功能位而有所不同。当本文档在讨论特定 STUN 安全特征的部分中引用“nonce cookie”时，可以理解，“nonce cookie”中相应的 STUN 安全特征位被设置为1。
 
    例如，当使用密码算法安全特性(在第9.2.4节中定义)时，在“nonce cookie”中，相应的“Password algorithms”位(在第18.1节中定义)被设置为1。
 
9.2.2.  HMAC Key
 
   对于不使用密码算法属性指定的不同算法的长期凭据，密钥为16个字节:
 
                key = MD5(username ":" OpaqueString(realm)
                  ":" OpaqueString(password))
 
   其中，MD5在[RFC1321]和[RFC6151]中定义，OpaqueString配置文件在[RFC8265]中定义。使用的编码为UTF-8[RFC3629]。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

   
    16字节的密钥由以下五个字段串联的结果的MD5散列组成：(1)用户名，去掉所有引号和尾随空值，从 USERNAME 属性中取出(在这种情况下，OpaqueString已经被应用)；(2)单个冒号；(3)域，去掉所有引号和尾部空值，在使用OpaqueString处理之后；(4)单个冒号；以及(5)密码，去掉尾随空值，并使用OpaqueString处理。例如，如果用户名为‘user’，领域为‘realm’，密码为‘pass’，则16字节的HMAC密钥将是对字符串‘user:realm:pass’执行MD5散列的结果，结果散列为 0x8493fbc53ba582fb4c044c456bdc40eb.
 






    当与长期凭据一起使用时，密钥的结构有助于在同样使用SIP[RFC3261]的系统中进行部署。通常，使用SIP摘要身份验证机制的SIP系统实际上不会将密码存储在数据库中。相反，它们存储一个称为“H(A1)”的值，该值等于上面定义的 key 。例如，此机制可以与[RFC5090]中定义的身份验证扩展一起使用。
 
    当使用密码算法时，要使用的密钥长度和算法在第18.5.1节中介绍。
 
9.2.3.  生成请求
 
    从客户端到服务器的第一个请求(如果使用第8节的DNS程序，则由主机名标识，如果不使用，则由IP地址标识)根据9.2.3.1节中的规则进行处理。当客户端在前一个请求/响应事务成功完成后发起后续请求时，它遵循第9.2.3.2节中的规则。作为401(未经验证)或438(过时随机数)错误响应的结果形成请求的内容在第9.2.5节中介绍，因此不被视为“后续请求”，因此不使用第9.2.3.2节中描述的规则。每种类型的请求都有不同的强制属性。
 








9.2.3.1.  首次请求
 
    如果客户端尚未成功完成与服务器的请求/响应事务，则必须省略 USERNAME 、USERHASH 、MESSAGE-INTEGRITY 、MESSAGE-INTEGRITY-SHA256 、REALM 、NONCE 、
PASSWORD-ALGORITHMS 和 PASSWORD-ALGORITHM 属性。换句话说，发送第一个请求时，就像没有应用身份验证或消息完整性一样。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

9.2.3.2.  后续请求
 
    一旦请求/响应事务完成，服务器将向客户端呈现一个域和随机数，并选择用于对其进行身份验证的用户名和密码。客户端应该缓存用户名、密码、域和随机数，以便与服务器进行后续通信。当客户端发送后续请求时，它必须在这些缓存值中包括 USERNAME 或 USERHASH、REALM、NONCE和 PASSWORD-ALGORITHM 属性。它必须包括 MESSAGE-INTEGRITY 属性或MESSAGE-INTEGRITY--SHA256 属性，按照第14.5节和第14.6节中的描述使用缓存的密码进行计算。这两个属性之间的选择取决于在对第一个请求的响应中接收到的属性。
 





9.2.4.  接收请求
 
    在服务器完成请求的基本处理后，它将按指定的顺序执行下面列出的检查。请注意，建议 REALM 值为STUN服务器提供商的域名：
 



   o  如果消息不包含 MESSAGE-INTEGRITY 或 MESSAGE-INTEGRITY--SHA256 属性，则服务器必须生成错误响应，错误代码为401(未经过身份验证)。此响应必须包括 REALM 值。响应必须包括由服务器选择的 NONCE。服务器不得为两个请求选择相同的 NONCE，除非它们具有相同的源IP地址和端口。服务器可以支持备用密码算法，在这种情况下，它可以在 PASSWORD-ALGORITHMS 属性中以优先顺序列出它们。如果服务器添加了PASSWORD-ALGORITHMS属性，它必须将 STUN 安全功能“Password algorithms”位设置为1。服务器可能支持匿名用户名，在这种情况下，它必须将 STUN 安全功能“Username anonymity”位设置为1。响应不应包含 USERNAME、USERHASH、MESSAGE-INTEGRITY 或 MESSAGE-INTEGRITY--SHA256 属性。
 
      注意：在[RFC5389]中没有明确禁止对不同的源IP地址或端口重复使用现时值。
 





   o  如果消息包含消息 MESSAGE-INTEGRITY 或 MESSAGE-INTEGRITY--SHA256 属性，但缺少 USERNAME 或 USERHASH、REALM 或 NONCE 属性，则服务器必须生成错误响应，错误代码为400(请求错误)。此响应不应包括 USERNAME、USERHASH、NONCE 或 REALM 属性。响应不能包含 MESSAGE-INTEGRITY 或 MESSAGE-INTEGRITY--SHA256 属性，因为缺少生成它们所需的属性。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 




     
 
   o  如果NONCE属性以STUN安全功能“Password algorithms”位设置为1的“nonce cookie”开头，服务器将按指定的顺序执行这些检查：
 
      *  如果请求既不包含 PASSWORD-ALGORITHMS ，也不包含 PASSWORD-ALGORITHM，则会将该请求视为密码算法为MD5。
 
      *  否则，除非(1)PASSWORD-ALGORITHM 和 PASSWORD-ALGORITHMS都存在，(2)PASSWORD-ALGORITHMS 与响应中发送的 NONCE 值匹配，以及(3)PASSWORD-ALGORITHM 与PASSWORD-ALGORITHMS 中的一个条目匹配，否则服务器必须生成错误代码为400(Bad Request)的错误响应。
 



   o  如果 USERNAME 或 USERHASH 属性的值无效，服务器必须生成错误响应，错误代码为401(未经过身份验证)。此响应必须包括 REALM 值。响应必须包括由服务器选择的 NONCE 。响应必须包括 PASSWORD-ALGORITHMS 属性。响应不应包含 USERNAME 或 USERHASH 属性。该响应可以包括 MESSAGE-INTEGRITY 或 MESSAGE-INTEGRITY--SHA256 属性，使用先前的密钥来计算它。
 


   o  如果 MESSAGE-INTEGRITY-SHA256 属性存在，则使用与用户名相关联的密码，按照第14.6节中的说明计算消息完整性的值。否则，使用相同的密码计算 MESSAGE-INTEGRITY 属性的值，如第14.5节所述。如果结果值与 MESSAGE-INTEGRITY 属性或 MESSAGE-INTEGRITY-SHA256 属性的内容不匹配，则服务器必须使用错误响应来拒绝请求。此响应必须使用错误代码401(未经身份验证)。它必须包括 REALM 和 NONCE 属性，而不应包括 USERNAME、USERHASH、MESSAGE-INTEGRITY 或 MESSAGE-INTEGRITY-SHA256 属性。
 
   o  如果 NONCE 不再有效，服务器必须生成错误响应，错误代码为438(过时的随机数)。此响应必须包括 NONCE、REALM 和 PASSWORD-ALGORITHMS 属性，而不应包括 USERNAME 和USERHASH 属性。NONCE 属性值必须有效。该响应可以包括 MESSAGE-INTEGRITY 或 MESSAGE-INTEGRITY-SHA256 属性，使用先前的 NONCE 来计算它。服务器可以撤销随机数，以提供更高的安全性。有关指南，请参阅[RFC7616]的第5.4节。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

      



 
    如果这些检查通过，服务器将继续处理请求。服务器生成的任何响应都必须包括MESSAGE-INTEGRITY-SHA256 属性，该属性使用用于对请求进行身份验证的用户名和密码进行计算，除非将请求当作密码算法MD5来处理(因为请求既不包含 PASSWORD-ALGORITHMS ，也不包含PASSWORD-ALGORITHM )。在这种情况下，必须使用 MESSAGE-INTEGRITY 属性，而不是MESSAGE-INTEGRITY-SHA256 属性，并且不应包括 REALM、NONCE、USERNAME 和 USERHASH 属性。
 


9.2.5.  接收响应
 
   如果响应是错误代码为401(未经过身份验证)或438(过时随机数)的错误响应，则客户端必须测试 NONCE 属性值是否以“nonce cookie”开头。如果是这样，并且“nonce cookie”将STUN安全功能“Password algorithms”位设置为1，但不存在 PASSWORD-ALGORITHMS 属性，则客户端不能使用新事务重试请求。
 

   如果响应是错误代码为401(未经过身份验证)的错误响应，则客户端应使用新事务重试请求。此请求必须包含 USERNAME 或 USERHASH，由客户端根据错误响应确定为 REALM 的适当用户名。如果存在“nonce cookie”，并且 STUN 安全特性“Username anonymity”位设置为1，则必须使用 USERHASH 属性；否则，必须使用 USERNAME 属性。请求必须包含从错误响应复制的 REALM。请求必须包含从错误响应复制的 NONCE。如果响应包含 PASSWORD-ALGORITHMS 属性，则请求必须包含具有相同内容的 PASSWORD-ALGORITHMS 属性。如果响应包含 PASSWORD-ALGORITHMS 属性，并且该属性至少包含客户端支持的一种算法，则请求必须包含 PASSWORD-ALGORITHM 属性，并且列表中第一个支持的算法。如果响应包含 PASSWORD-ALGORITHMS 属性，并且该属性不包含客户端支持的任何算法，则客户端不能使用新事务重试请求。如果客户端不更改上次尝试的 USERNAME、USERHASH、REALM 或与其关联的密码，则不得执行此重试。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 



   如果响应是错误代码为438(陈旧随机数)的错误响应，则客户端必须使用438(陈旧随机数)响应中提供的新 NONCE 属性重试请求。此重试还必须包括 USERNAME 或 USERHASH、REALM 以及 MESSAGE-INTEGRITY 或 MESSAGE-INTEGRITY-SHA256 属性。
 

   对于所有其他响应，如果NONCE属性以STUN安全功能“Password algorithms”位设置为1的“nonce cookie”开头，但 PASSWORD-ALGORITHMS 不存在，则必须忽略该响应。
 


   如果响应是错误代码为400(错误请求)的错误响应，并且既不包含 MESSAGE-INTEGRITY 属性也不包含 MESSAGE-INTEGRITY-SHA256 属性，则必须丢弃该响应，就像从未收到过它一样。这意味着，如果适用，重新传输将继续。
 
      注意：在这种情况下，400响应永远不会到达应用程序，从而导致超时。
 


   客户端在响应中查找 MESSAGE-INTEGRITY 或 MESSAGE-INTEGRITY-SHA256 属性(成功或失败)。如果存在，客户端将使用与请求相同的密码在响应上计算消息完整性，如第14.5或14.6节中所定义。如果结果值与 MESSAGE-INTEGRITY 或 MESSAGE-INTEGRITY-SHA256 属性的内容匹配，则认为响应已通过身份验证。如果该值不匹配，或者如果 MESSAGE-INTEGRITY 和 MESSAGE-INTEGRITY-SHA256 都不存在，则处理取决于通过可靠或不可靠传输发送的请求。
 





   如果请求是通过不可靠的传输发送的，则必须丢弃响应，就像从未收到过一样。这意味着，如果适用，重新传输将继续。如果所有收到的响应都被丢弃，则该层必须发出完整性保护被违反的信号，而不是在结束事务后发出超时信号。
 
   如果请求是通过可靠传输发送的，则必须丢弃响应，并且该层必须立即结束事务并发出完整性保护被违反的信号。
 
   如果响应包含 PASSWORD-ALGORITHMS 属性，则所有后续请求必须仅使用 MESSAGE-INTEGRITY-SHA256 进行身份验证。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 



10.  ALTERNATE-SERVER 机制
 
   本节介绍STUN中的一种机制，该机制允许服务器将客户端重定向到另一台服务器。此扩展是可选的，用法必须定义是否以及何时使用此扩展。ALTERNATE-SERVER 属性携带IP地址。
 

   使用此扩展的服务器通过使用错误代码为300(Try Alternate)的错误响应消息回复请求消息，将客户端重定向到另一台服务器。服务器必须在错误响应中至少包括一个 ALTERNATE-SERVER 属性，该属性必须包含与请求消息的源IP地址属于同一地址系列的IP地址。在强制属性之后，服务器应该包括一个附加的 ALTERNATE-SERVER 属性，该属性包含除请求消息的源IP地址之外的地址族的IP地址。可以对错误响应消息进行身份验证；然而，在替代服务器的使用情况下，响应的身份验证是不可能的或不可行的。如果事务使用 TLS 或 DTLS，如果事务通过 MESSAGE-INTEGRITY-SHA256 属性进行身份验证，并且服务器想要重定向到使用不同证书的服务器，则它必须包括一个 ALTERNATE-DOMAIN 属性，该属性在该证书的subjectAltName 中包含名称。MESSAGE-INTEGRITY-SHA256 属性上的这一系列条件表明事务已通过身份验证，并且客户端实现了此规范，因此可以处理 ALTERNATE-DOMAIN 属性。
 









   使用此扩展的客户端按如下方式处理300(Try Alternate)错误代码。客户端在错误响应中查找 ALTERNATE-SERVER 属性。如果找到，则客户端将当前事务视为失败，并使用与前一个请求相同的传输协议，使用属性中指定的服务器重新尝试请求。如果该请求经过身份验证，则必须使用客户端在向执行重定向的服务器发出的请求中使用的相同凭据。如果传输协议使用 TLS 或 DTLS，则客户端将查找 ALTERNATE-DOMAIN 属性。如果找到该属性，则必须使用该域按照[RFC6125]中的建议验证证书。证书必须包含类型为 DNS-ID 或 CN-ID (最终使用通配符)的标识符，但不能为类型 SRV-ID 或 URI-ID。如果未找到该属性，则必须使用用于原始请求的同一个域来验证证书。如果客户端已被重定向到它在过去五分钟内已向其发送此请求的服务器，则它必须忽略重定向并认为事务已失败。这可以在发生重定向循环的情况下防止服务器之间的无限乒乓。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 


11.  向后兼容 RFC 3489
 
    除了已经在[RFC5389]的第12节中描述的向后兼容性之外，DTLS 不得与[RFC3489](称为“经典STUN”)一起使用。任何在 DTLS 上没有魔力Cookie(参见[RFC5389]第6节)的 STUN 请求或指示都必须被视为无效：所有请求都必须生成500(服务器错误)错误响应，并且指示必须被忽略。
 

12.  基本服务器行为
 
   本部分定义基本的独立STUN服务器的行为。
 
   从历史上看，“经典 STUN”[RFC3489]仅定义了通过接收和回复 STUN Binding 请求来为客户端提供服务器自反传输地址的服务器的行为。[RFC5389]将协议重新定义为可扩展框架，服务器功能成为该文档中定义的唯一 STUN 用法。这种 STUN 用法也称为“基本 STUN 服务器”。



 
   STUN服务器必须支持Binding 方法。它不应该利用短期或长期的证书机制。这是因为对请求进行身份验证所涉及的工作不仅仅是简单地处理它。出于同样的原因，它不应该使用ALTERNATE-SERVER 机制。它必须支持 UDP 和 TCP。它可能支持基于 TCP/TLS 的 STUN 或基于 UDP/DTLS 的 STUN；然而，DTLS 和 TLS 在这种基本操作模式中提供的安全益处微乎其微。它不需要保活机制，因为在绑定事务结束后会关闭 TCP 或 TLS-over-TCP 连接。它可以使用 FINGERPRINT 机制，但不能要求它。由于独立服务器只运行 STUN，指纹没有任何好处。要求它会破坏与 RFC 3489 的兼容性，而这种兼容性在独立服务器中是可取的。独立 STUN 服务器应支持与使用 [RFC3489] 的客户端向后兼容，如第11节所述。
 






   建议 STUN 服务器的管理员提供这些服务器的 DNS 条目，如第8节所述。如果同时返回A和AAAA资源记录，则客户端可以同时向IPv4和IPv6地址(如[RFC8305]中指定的)发送 STUN 绑定请求，因为绑定请求是幂等的。请注意，返回的 MAPPED-ADDRESS 或 XOR-MAPPED-ADDRESS属性不一定与所使用的服务器地址的地址族匹配。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 



   基本的 STUN 服务器本身不是NAT穿越的解决方案。然而，它可以作为解决方案的一部分，通过STUN用法。这一点将在第13节中进一步讨论。
 
13.  STUN 用法
 
   STUN 本身不是 NAT 穿越问题的解决方案。相反，STUN 定义了一种可以在更大的解决方案中使用的工具。术语“STUN Usage”用于任何使用 STUN 作为组件的解决方案。
 


   STUN 用法定义了 STUN 的实际使用方式--何时发送请求、如何处理响应以及使用此处(或STUN 的扩展中)定义的哪些可选过程。用法还定义：
 
   o  使用了哪些 STUN 方法。
 
   o  使用什么传输方式。如果使用DTLS-over-UDP，则必须实施[RFC6347]的第 4.2.1节中描述的拒绝服务对策。
 
   o  使用了哪些身份验证和消息完整性机制。
 
   o  关于完整性机制的手动和自动密钥派生的考虑因素，如[RFC4107]中所讨论的。
 
   o  使用什么机制将STUN消息与其他消息区分开来。当STUN在TCP或TLS-over-TCP上运行时，可能需要成帧机制。
 
   o  STUN客户端如何确定STUN服务器的IP地址和端口。
 
   o  当为STUN服务器找到两个地址系列时，同时使用IPv4和IPv6地址(Happy Eyeballs[RFC8305])如何与非幂等事务一起工作。
 
   o  是否需要向后兼容RFC 3489。
 
   o  需要在此处或在其他扩展中定义哪些可选属性(如指纹和备用服务器)。
 
   o  是否允许 MESSAGE-INTEGRITY-SHA256 截断，以及允许截断的限制。
 
   o  如果STUN在TCP或TLS-OVER-TCP上运行，则为保活机制。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 



   o  服务器在1)使用TCP或TLS-over-TCP或2)使用身份验证情况下，任播地址是否可用。
 
   此外，任何STUN用法都必须考虑在该用法中使用STUN的安全影响。已知许多针对STUN的攻击(请参阅本文档中的安全注意事项部分)，任何使用都必须考虑如何挫败或缓解这些攻击。
 
   最后，用法必须考虑其对STUN的使用是否是NAT穿越的单方面自我地址固定方法的示例，如果是，则解决RFC 3424[RFC3424]中提出的问题。
 




14.  STUN 属性
 
   STUN报头之后是零个或多个属性。每个属性必须是TLV编码的，具有16位类型、16位长度和值。每个STUN属性必须以32位边界结束。如上所述，首先传输属性中的所有字段的最高有效位。
 
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |         Type                  |            Length             |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                         Value (variable)                ....
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  
                            图4：STUN属性的格式
 
   长度字段中的值必须包含填充前属性的值部分的长度，以字节为单位。由于STUN在32位边界上对齐属性，因此其内容不是4字节的倍数的属性用1、2或3字节的填充填充，以使其值包含4字节的倍数。发送时，填充比特必须设置为零，并且必须被接收方忽略。
 





   任何属性类型都可以在STUN消息中多次出现。除非另有说明，否则出现的顺序很重要：接收方只需要处理第一个出现属性，而接收方可能会忽略任何重复的属性。
 
   为了允许此规范的未来修订版在需要时添加新属性，将属性空间划分为两个范围。类型值在 0x0000 和 0x7FFF 之间的属性是理解必需的属性，这意味着 STUN 代理无法成功处理消息，除非它理解该属性。类型值在 0x8000 和 0xFFFF 之间的属性是理解可选属性，这意味着如果STUN代理不理解这些属性，它可以忽略它们。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 





 
   STUN属性类型集由 IANA 维护。本规范定义的初始集合可在第18.3节中找到。
 
   本节的其余部分描述了本规范中定义的各种属性的格式。
 




14.1.  MAPPED-ADDRESS
 
   MAP-ADDRESS 属性指示客户端的自反传输地址。它由一个8位地址族和一个16位端口组成，后跟一个代表IP地址的固定长度的值。如果地址系列为IPv4，则地址必须为32位。如果地址系列为IPv6，则地址必须为128位。所有字段必须按网络字节顺序排列。
 
   MAP-ADDRESS属性的格式为：
 
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |0 0 0 0 0 0 0 0|    Family     |           Port                |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     |                 Address (32 bits or 128 bits)                 |
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 
               Figure 5: Format of MAPPED-ADDRESS Attribute
 
   地址系列可以采用下列值：
 
   0x01:IPv4
   0x02:IPv6
 
   映射地址的前8位必须设置为0，并且必须被接收器忽略。这些位用于在自然32位边界上对齐参数。
 
   此属性仅由服务器用于实现与[RFC3489]客户端的向后兼容。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

14.2.  XOR-MAPPED-ADDRESS
  
   XOR-MAPPED-ADDRESS 属性与 MAPPED-ADDRESS 属性相同，不同之处在于通过 XOR 函数混淆了自反传输地址。
 
   XOR映射地址的格式为：
 
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |0 0 0 0 0 0 0 0|    Family     |         X-Port                |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                X-Address (Variable)                           |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 
                     图6：XOR-MAPPED-ADDRESS 属性的格式
 
   Family字段代表IP地址系列，其编码方式与MAP-Address中的Family字段相同。
 
   X-Port 是通过将映射的端口与魔术Cookie的最高有效16位进行XOR运算来计算的。如果IP地址族是IPv4，则通过将映射的IP地址与魔术Cookie进行异或运算来计算 X-Address。如果IP地址系列是IPv6，则通过将映射的IP地址与魔术Cookie和96位事务ID的串联进行 XOR 运算来计算 X-Address。在所有情况下，XOR 运算都以网络字节顺序(即它们将在消息中编码的顺序)对其输入进行操作。
 
   编码和处理属性值的前8位的规则、处理属性多次出现的规则以及处理地址族的规则与映射地址相同。
 
   注意：XOR映射地址和映射地址的不同之处仅在于它们对传输地址的编码。前者通过将传输地址与魔力Cookie进行异或运算来对其进行编码。后者直接以二进制对其进行编码。RFC 3489最初仅指定了映射地址。然而，部署经验发现，一些NAT重写包含NAT的公共IP地址的32位二进制有效负载，例如STUN的映射地址属性，这是为了提供通用应用层网关(ALG)功能的善意但被误导的尝试。这种行为会干扰STUN的操作，还会导致STUN的消息完整性检查失败。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

14.3.  USERNAME
 
   UserName属性用于消息完整性。它标识在消息完整性检查中使用的用户名和密码组合。
 
   TUSERNAME 的值是包含身份验证用户名的长度可变的值。它必须包含少于509字节的UTF-8编码的[RFC3629]序列，并且必须已使用OpaqueString配置文件[RFC8265]进行处理。兼容的实现必须能够解析UTF-8编码的763个或更少的八位字节序列，才能与[RFC5389]兼容。
 





      注：[RFC5389]错误地引用了[RFC2279]中UTF-8的定义。[RFC2279]假设每个编码的字符最多6个八位字节。[RFC2279]被[RFC3629]取代，后者每个编码的字符只允许4个八位字节，与Unicode2.0和ISO/IEC 10646中所做的更改一致。
 
      注意：本规范使用 OpaqueString 配置文件而不是 UsernameCasePReserve 配置文件来处理用户名字符串，以提高与已部署的密码存储的兼容性。许多用于 HTTP 和 SIP 摘要身份验证的密码数据库存储UserName：Realm：Password的MD5散列，而不是存储纯文本密码。在[RFC3489]中，STUN身份验证被设计为尽可能与这些现有数据库兼容，与SIP和HTTP一样，除了禁止非空格ASCII控制字符外，STUN身份验证不对用户名和密码执行任何预处理。STUN规范的下一个修订版[RFC5389]使用SASLprep[RFC4013]Stringprep[RFC3454]配置文件来预处理用户名和密码。SASLprep使用Unicode标准化形式KC(兼容性分解，然后是规范组合)[UAX15]，并禁止各种控制、空格和非文本、弃用或不适当的代码点。PRECIS框架[RFC8264]取代了字符串准备。PRECIS对用户名和密码的处理[RFC8265]使用Unicode标准化形式C(规范分解，然后是规范组合)。虽然在某些特定情况下，可以将HTTP Digest下的不同用户名字符串映射到使用OpaqueString处理的单个STUN用户名，但这些情况极不可能发生，而且很容易检测和纠正。使用UsernameCasePReserve配置文件，HTTP Digest下的有效用户名更有可能与其处理后的表单(特别是包含双向文本和兼容表单的用户名)不匹配。运营商可以自由地进一步限制用户名中允许的代码点，以避免出现问题字符。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

14.4.  USERHASH
 
   当支持用户名匿名时，USERHASH属性用作用户名属性的替代。
 
   USERHASH的值具有32字节的固定长度。用户名必须已使用OpaqueString配置文件[RFC8265]处理，并且领域在散列之前必须已使用OpaqueString配置文件[RFC8265]处理。
 
   以下是客户端将执行的对用户名进行哈希处理的操作：
 
   userhash = SHA-256(OpaqueString(username) ":" OpaqueString(realm))
 






14.5.  MESSAGE-INTEGRITY
 
   MESSAGE-INTEGRITY 属性包含 STUN 消息的HMAC-SHA1[RFC2104]。MESSAGE-INTEGRITY 属性可以出现在任何 STUN 消息类型中。由于它使用SHA-1散列，因此HMAC将为20字节。
 
   HMAC的密钥取决于正在使用的凭据机制。第9.1.1节定义了短期凭证机制的密钥，第9.2.2节定义了长期凭证机制的密钥。其他凭证机制必须定义用于HMAC的密钥。
 
   用作 HMAC 输入的文本是 STUN 消息，直到并包括消息完整性属性之前的属性。STUN消息头的长度字段被调整为指向消息完整性属性的末尾。消息完整性属性的值被设置为伪值。
 
   一旦执行了计算，就填充了 MESSAGE-INTEGRITY 属性的值，并将STUN报头中的长度值设置为其正确值--整个消息的长度。类似地，当验证 MESSAGE-INTEGRITY 时，在计算STUN消息上的HMAC之前，必须调整STUN报头中的长度字段以指向 MESSAGE-INTEGRITY 属性的末尾，直到并包括 MESSAGE-INTEGRITY 属性之前的属性。当 FINGERPRINT 和 MESSAGE-INTEGRITY-SHA256 等属性出现在消息完整性之后时，这种调整是必要的。另请参阅[RFC5769]以了解此类计算的示例。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 


14.6.  MESSAGE-INTEGRITY-SHA256
 
   MESSAGE-INTEGRITY-SHA256 属性包含STUN消息的HMAC-SHA256[RFC2104]。MESSAGE-INTEGRITY-SHA256 属性可以出现在任何STUN消息类型中。MESSAGE-INTEGRITY-SHA256 属性包含STUN消息的HMAC-SHA-256[RFC2104]的初始部分。该值最多为32个字节，但必须至少为16个字节，并且必须是4个字节的倍数。除非STUN用法明确指定允许截断，否则该值必须是完整的32个字节。STUN用法可以指定长于16字节的最小长度。
 
   HMAC的密钥取决于正在使用的凭据机制。第9.1.1节定义了短期凭证机制的密钥，第9.2.2节定义了长期凭证机制的密钥。其他凭证机制必须定义用于HMAC的密钥。
 
   用作HMAC输入的文本是STUN消息，直到并包括 MESSAGE-INTEGRITY-SHA256 属性之前的属性。STUN消息头的长度字段被调整为指向 MESSAGE-INTEGRITY-SHA256 属性的末尾。 MESSAGE-INTEGRITY-SHA256 属性的值被设置为伪值。
 
   执行计算后，将填充 MESSAGE-INTEGRITY-SHA256 属性的值，并将STUN报头中的长度值设置为其正确值--整个消息的长度。同样，当验证 MESSAGE-INTEGRITY-SHA256 时，在计算STUN消息上的HMAC之前，必须将STUN报头中的长度字段调整为指向 MESSAGE-INTEGRITY-SHA256 属性的结尾，直到并包括 MESSAGE-INTEGRITY-SHA256 属性之前的属性。当诸如 FINGERPRINT 之类的属性出现在 MESSAGE-INTEGRITY-SHA256 之后时，这种调整是必要的。有关这类计算的例子，另请参阅附录B.1。
 











14.7.  FINGERPRINT
 
   FINGERPRINT 属性可以出现在所有STUN消息中。
 
   属性的值被计算为STUN消息的 CRC-32，直到(但不包括) FINGERPRINT 属性本身，与32位值 0x5354554e 进行异或。(XOR操作确保指纹测试不会对包含由应用协议生成的CRC-32的分组报告假阳性。)。32位CRC是ITU V.42[ITU.V42.2002]中定义的CRC，其生成多项式为x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1。请参阅[RFC1952]第 ；8节中CRC-32的示例代码。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

  
 
   如果存在，FINGERPRINT 属性必须是消息中的最后一个属性，因此将出现在 MESSAGE-INTEGRITY 和 MESSAGE-INTEGRITY-SHA256 之后。
 
   FINGERPRINT 属性可以帮助区分 STUN 分组和其他协议的分组。请参见第7节。
 
   与 MESSAGE-INTEGRITY 和 MESSAGE-INTEGRITY-SHA256 一样，FINGERPRINT 属性中使用的CRC覆盖STUN消息头中的长度字段。因此，在计算CRC之前，该值必须正确，并将CRC属性作为消息长度的一部分。当在消息中使用 FINGERPRINT 属性时，首先将该属性放入具有虚值的消息中；然后，计算CRC，并更新该属性的值。如果还存在 MESSAGE-INTEGRITY 或 MESSAGE-INTEGRITY-SHA256 属性，则在计算CRC之前，它必须具有正确的消息完整性值，因为CRC也是在消息完整性和消息完整性-SHA256属性的值上执行的。
 











14.8.  ERROR-CODE
 
    ERROR-CODE 属性在错误响应消息中使用。它包含一个范围在300到699之间的数字错误代码值，以及一个以UTF-8[RFC3629]编码的文本原因短语；它在代码分配和语义上也与SIP[RFC3261]和HTTP[RFC7231]一致。原因短语用于诊断目的，可以是适用于错误代码的任何内容。已定义错误代码的建议原因短语包含在IANA的错误代码注册表中。原因短语必须是少于128个字符的UTF-8编码[RFC3629]序列(编码时最长可达509个字节，解码时最长可达763个字节)。
 
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |           Reserved, should be 0         |Class|     Number    |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      Reason Phrase (variable)                                ..
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 
                 Figure 7: Format of ERROR-CODE Attribute</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 


   为了便于处理，错误代码的类别(百位数字)与代码的其余部分分开编码，如图7所示。
 


   Reserved 应为0，用于在32位边界上对齐。接收器必须忽略这些位。Class 表示错误代码的数百位数字，值必须介于3和6之间。Number 表示以100为模的错误码的二进制编码，其值必须介于0和99之间。
 

   定义了以下错误代码及其建议的原因短语：
 
   300  Try Alternate: 客户端应针对此请求联系备用服务器。只有当请求包含 
        USERNAME 或 USERHASH 属性以及有效的 MESSAGE-INTEGRITY 或
        MESSAGE-INTEGRITY-SHA256 属性时，才必须发送此错误响应；否则，不能
        发送该错误响应，并建议错误代码400(错误请求)。此错误响应必须使用
        MESSAGE-INTEGRITY 或 MESSAGE-INTEGRITY-SHA256 属性进行保护，接收方
        必须验证此响应的 MESSAGE-INTEGRITY 或 MESSAGE-INTEGRITY-SHA256 ，
        然后才能将自身重定向到备用服务器。
 
        注意：未能生成和验证300响应的消息完整性，使得路径上的攻击者能够
        伪造300响应，从而导致后续STUN消息被发送给受害者。
 






   400  Bad Request: 请求的格式不正确。客户端不应在未修改前一次尝试的情况下
        重试该请求。服务器可能无法为此错误生成有效的 MESSAGE-INTEGRITY 或
        MESSAGE-INTEGRITY-SHA256 ，因此客户端不能期望此响应具有有效的
        MESSAGE-INTEGRITY 或 MESSAGE-INTEGRITY-SHA256 属性。
 
   401  Unauthenticated: 请求不包含继续操作所需的正确凭据。客户端应使用
        正确的凭据重试该请求。
 
   420  Unknown Attribute: 服务器收到包含它不理解的理解必须属性的 STUN 分组。
        服务器必须将此未知属性放入其错误响应的未知属性中。
 
   438  Stale Nonce: 客户端使用的 NONCE 不再有效。客户端应使用响应中提供
        的 NONCE 重试。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 



   500  Server Error: 服务器出现暂时性错误。客户端应该再试一次。
 
14.9.  REALM
 
   REALM 属性可以出现在请求和响应中。它包含的文本符合[RFC3261]中所述的“域-值”的语法，但没有双引号及其周围的空格。也就是说，它是一个未加引号领域值(因此是一系列qdtext 或带引号的对)。它必须是少于128个字符的UTF-8编码的[RFC3629]序列(编码时最长可达509个字节，解码时最长可达763个字节)，并且必须已使用OpaqueString配置文件[RFC8265]进行处理。
 
   请求中出现 REALM 属性表示正在使用长期凭据进行身份验证。某些错误响应中的存在表示服务器希望客户端使用该域中的长期凭据进行身份验证。
 





14.10.  NONCE
 
   NONCE 属性可以出现在请求和响应中。它包含一系列QdText或引号对，在[RFC3261]中定义。请注意，这意味着 NONCE 属性将不包含实际的引号字符。NONCE 属性必须少于128个字符(编码时可长达509个字节，解码时可长达763个字节)。有关在服务器中选择随机数值的指导，请参阅[RFC7616]的第 ；5.4节。
 



14.11.  PASSWORD-ALGORITHMS
 
   PASSWORD-ALGORITHMS 属性可以出现在请求和响应中。它包含服务器可用于派生长期密码的算法列表。
 
   这组已知算法由IANA维护。本规范定义的初始集合可在第18.5节中找到。
 
   该属性包含算法编号和可变长度参数的列表。算法编号为第18.5节中定义的16位值。参数以16位值形式的参数长度(填充前)开始，后跟特定于每个算法的参数。参数以与属性相同的方式填充到32位边界。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |         Algorithm 1           | Algorithm 1 Parameters Length |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                    Algorithm 1 Parameters (variable)
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |         Algorithm 2           | Algorithm 2 Parameters Length |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                    Algorithm 2 Parameters (variable)
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                             ...
 
             Figure 8: Format of PASSWORD-ALGORITHMS Attribute
 
14.12.  PASSWORD-ALGORITHM
 
   PASSWORD-ALGORITHM 属性仅存在于请求中。它包含服务器从长期密码派生密钥时必须使用的算法。
 
   这组已知算法由IANA维护。本规范定义的初始集合可在第18.5节中找到。
 
   该属性包含算法编号和可变长度参数。算法编号为第18.5节中定义的16位值。参数以16位值形式的参数长度(填充前)开始，后跟特定于算法的参数。参数以与属性相同的方式填充到32位边界。同样，在发送时，填充比特必须设置为零，并且必须被接收方忽略。
 
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Algorithm           |  Algorithm Parameters Length   |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                    Algorithm Parameters (variable)
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 
             Figure 9: Format of PASSWORD-ALGORITHM Attribute
 





14.13.  UNKNOWN-ATTRIBUTES
 
   只有当错误代码属性中的响应代码为420(未知属性)时，才会在错误响应中出现
   UNKNOWN-ATTRIBUTES属性。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 



   该属性包含一个16位值的列表，每个值代表服务器无法理解的属性类型。
 
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      Attribute 1 Type         |       Attribute 2 Type        |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      Attribute 3 Type         |       Attribute 4 Type    ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 
             Figure 10: Format of UNKNOWN-ATTRIBUTES Attribute
 
      备注：在[RFC3489]中，通过复制最后一个属性将该字段填充为32。在此版本的规范中，改为使用属性的正常填充规则。
 

14.14.  SOFTWARE
 
   The SOFTWARE attribute contains a textual description of the software   being used by the agent sending the message.  It is used by clients   and servers.  Its value SHOULD include manufacturer and version   number.  The attribute has no impact on operation of the protocol and   serves only as a tool for diagnostic and debugging purposes.  The   value of SOFTWARE is variable length.  It MUST be a UTF-8-encoded   [RFC3629] sequence of fewer than 128 characters (which can be as long   as 509 when encoding them and as long as 763 bytes when decoding   them).
 
14.15.  ALTERNATE-SERVER
 
   备用服务器表示标识STUN客户端应该尝试的不同STUN服务器的备用传输地址。
 
   它的编码方式与 MAPPED-ADDRESS 相同，因此通过IP地址引用单个服务器。
 
14.16.  ALTERNATE-DOMAIN
 
   备用域表示当传输协议使用 TLS 或 DTLS 时，用于验证 ALTERNATE-SERVER 属性中IP地址的域名。
 
   ALTERNATE-DOMAIN 值为可变长度。它必须是包含255个或更少ASCII字符的有效DNS名称[RFC1123](包括A标签[RFC5890])。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 


15.  Operational Considerations
 
   STUN 可以与任播地址一起使用，但只能与UDP和不使用身份验证的STUN使用一起使用。
 
16.  Security Considerations
 
   使用TLS或DTLS的STUN使用的实施和部署必须遵循[BCP195]中的建议。
 
   使用长期凭证机制(第9.2节)实施和部署STUN使用必须遵循[RFC7616]第5节中的建议。
 



16.1.  对协议的攻击
 
16.1.1.  外部攻击
 
   攻击者可以尝试修改传输中的STUN消息，从而导致STUN操作失败。通过使用短期或长期凭据的消息完整性机制，可以针对请求和响应检测到这些攻击。当然，一旦检测到，被操纵的分组将被丢弃，从而导致STUN事务实际上失败。只有路径上的攻击者才有可能进行此攻击。




 
   可以观察但不能修改传输中的STUN消息的攻击者(例如，出现在共享访问介质(如Wi-Fi)上的攻击者)可以看到STUN请求，然后立即发送STUN响应(通常是错误响应)，以中断STUN处理。对于利用消息完整性的消息，也可以防止这种攻击。但是，某些错误响应，特别是与身份验证相关的错误响应，不能受到消息完整性的保护。当STUN本身在安全传输协议(例如，TLS)上运行时，这些攻击被完全缓解。
 
   根据STUN的使用情况，这些攻击的后果可能最小，因此不需要消息完整性来缓解。例如，当STUN用于基本STUN服务器以发现用于ICE的服务器自反候选时，不需要身份验证和消息完整性，因为这些攻击是在连接检查阶段检测到的。然而，连接性检查本身需要为ICE的整体正常运行提供保护。如第13节所述，STUN用法描述了何时需要身份验证和消息完整性。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 



   由于STUN使用共享密钥的HMAC进行身份验证和完整性保护，因此它容易受到脱机字典攻击。当使用身份验证时，它应该使用不容易受到脱机字典攻击的强密码。使用TLS或DTLS保护通道本身可以缓解这些攻击。
 
   STUN同时支持 MESSAGE-INTEGRITY 和 MESSAGE-INTEGRITY-SHA256，这使得STUN容易受到路径上攻击者的降价攻击。攻击者可以剥离 MESSAGE-INTEGRITY-SHA256 属性，只留下 MESSAGE-INTEGRITY 属性，从而利用潜在的漏洞。使用TLS或DTLS保护通道本身可以缓解这些攻击。在未来版本的STUN中及时删除对 MESSAGE-INTEGRITY 的支持是必要的。
 
   注意：使用SHA-256进行密码散列不符合现代标准，这些标准旨在通过提供相对较慢的最短时间来计算散列来减缓穷举密码搜索的速度。虽然有更好的算法，如Argon2[Argon2]，但选择SHA-256是为了与[RFC7616]保持一致。
 






16.1.2.  内部攻击
 
   恶意客户端可能试图通过向服务器发送大量STUN请求来对其发起DoS攻击。幸运的是，服务器可以无状态地处理STUN请求，这使得此类攻击很难有效发起。
 
   恶意客户端可能使用STUN服务器作为反射器，向其发送带有伪造的源IP地址和端口的请求。在这种情况下，响应将被传递到该源IP和端口。这种攻击不会放大数据包数(STUN服务器为客户端发送的每个数据包发送一个数据包)，尽管数据量略有增加，因为STUN响应通常大于请求。此攻击可通过入口源地址过滤来缓解。
 
   通过 SOFTWARE 属性揭示代理的特定软件版本可能会使他们更容易受到针对已知包含安全漏洞的软件的攻击。实施者应该使 SOFTWARE 属性的使用成为可配置的选项。
 


16.1.3.  Bid-Down Attacks
 
   本文档增加了在使用长期凭证机制时选择不同的算法来保护存储在服务器端的密码的机密性的可能性，同时仍确保与MD5的兼容性，MD5是[RFC5389]中使用的算法。此选择的工作方式是让服务器向客户端发送 PASSWORD-ALGORITHMS 属性中支持的算法列表，并让客户端发回包含所选算法的 PASSWORD-ALGORITHM 属性。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

  




 
   由于 PASSWORD-ALGORITHMS 属性必须在未经身份验证的响应中发送，因此想要利用MD5中的最终漏洞的路径攻击者只需从未受保护的响应中剥离 PASSWORD-ALGORITHMS 属性，从而使服务器随后的行为就像客户端正在实施[RFC5389]中定义的此协议版本一样。
 




   为了防止这种攻击和其他类似的降价攻击，nonce 值被丰富了一组安全位，指示正在使用哪些安全功能。在选择密码算法的情况下，在服务器在包含 PASSWORD-ALGORITHMS 属性的相同响应中返回的随机数中设置匹配位。由于服务器会验证后续经过身份验证的事务中使用的随机数与最初发送的内容相同，因此路径上的攻击者无法对其进行修改。此外，客户端还被要求在下一个经过身份验证的事务中将接收到的 PASSWORD-ALGORITHMS 属性复制到该服务器。
 



   将检测到移除 PASSWORD-ALGORITHMS 的路径上攻击，因为客户端将无法在下一次经过身份验证的事务中将其发送回服务器。客户端将检测到该攻击，因为设置了安全位，但缺少匹配的属性；这将结束会话。使用该协议旧版本的客户端将不会发送回PASSWORD-ALGORITHMS，但无论如何都只能使用MD5，因此攻击是无关紧要的。
 
   路径上攻击还可能尝试删除安全位和密码算法属性，但服务器会在下一个经过身份验证的事务包含无效随机数时发现这一点。
 
   从 PASSWORD-ALGORITHMS 属性中删除某些算法的路径上攻击将同样失败，因为当服务器在随后的验证事务中对其进行验证时，该属性将与原始属性不同。
 
   请注意，本文档中引入的降价保护机制固有地受到以下事实的限制：在服务器接收到401(未经身份验证)响应之后的第二个请求之前，不可能检测到攻击。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 



   由于与[RFC7616]的兼容性，SHA-256被选为密码哈希的新默认算法，但由于SHA-256(与MD5一样)是一个相对较快的算法，它对阻止暴力攻击几乎没有什么作用。具体地说，这意味着如果用户具有弱密码，则捕获单个交换的攻击者可以使用暴力攻击来获取用户的密码，然后可能会将该用户模拟到服务器和使用相同密码的其他服务器。请注意，这样的攻击者可以在没有任何暴力攻击的情况下将用户模拟到服务器本身。
 



   更强(也就是更慢)的算法，如Argon2[Argon2]，将对这两种情况都有帮助；然而，在第一种情况下，只有在该用户的数据库条目更新为只使用该更强的机制之后，它才会有帮助。
 
   该协议中的降价防御防止攻击者使用比客户端和服务器共同支持的更弱的算法来强迫客户端和服务器完成握手，但前提是最弱的联合算法足够强大，不能被暴力攻击破坏。但是，这并不能抵御对这些算法的许多攻击；具体地说，路径上的攻击者可能会在同时支持Argon2[Argon2]和SHA-256进行密码散列的客户端上执行降价攻击，并使用它来收集消息完整性SHA256值，然后使用该值进行脱机暴力攻击。当服务器收到第二个请求时，就会检测到这一点，但这并不能阻止攻击者获取消息完整性SHA256值。





 
   同样，对USERHASH机制的攻击将无法成功建立会话，因为服务器将检测到路径上的功能已被丢弃，但客户端仍将被说服在USERNAME 属性中以明文发送其用户名，从而将其泄露给攻击者。
 
   最后，当降价保护机制被用于未来用于保护消息的HMAC算法的升级时，如果当前的HMAC算法已经被破坏，它将仅提供有限的保护。




 
16.2.  影响使用的攻击
 
   本部分列出了可能针对STUN使用发起的攻击。每种STUN用法都必须考虑这些攻击是否适用于它，如果适用，则讨论对策。
 
  </pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 




   本节中的大多数攻击都围绕着攻击者通过绑定请求/响应事务修改STUN客户端获取的自反地址。由于反身地址的使用是用法的函数，因此这些攻击的适用性和补救是特定于用法的。在一般情况下，路径上的攻击者很容易修改自反地址。例如，考虑STUN直接在UDP上运行的常见情况。在这种情况下，路径上的攻击者可以在绑定请求到达STUN服务器之前修改其源IP地址。然后，STUN服务器将XOR-MAP-ADDRESS属性中的该IP地址返回给客户端，并将响应发送回该(伪造的)IP地址和端口。如果攻击者也可以拦截此响应，则可以将其定向回客户端。通过使用消息完整性检查来防御此攻击是不可能的，因为消息完整性值不能覆盖源IP地址，并且介入NAT必须能够修改此值。相反，防止下面列出的攻击的一个解决方案是让客户端验证学习到的自反地址，就像ICE[RFC8445]中所做的那样。
 
   其他用法可能会使用其他方法来防止这些攻击。
 



16.2.1.  Attack I: 针对目标的分布式DoS(DDoS)
 
   在此攻击中，攻击者向一个或多个客户端提供指向目标的相同伪造自反地址。这将欺骗STUN客户端，使其认为它们的自反地址与目标地址相同。如果客户端分发该自反地址以便在其上接收流量(例如，在SIP消息中)，则流量将改为发送到目标。此攻击可提供大量放大功能，特别是在与使用STUN启用多媒体应用程序的客户端一起使用时。但是，它只能针对从STUN服务器发往目标的数据包通过攻击者的目标发起攻击，从而限制了可能发起攻击的情况。
 



16.2.2.  Attack II: 使客户端静默
 
   在此攻击中，攻击者向STUN客户端提供伪造的反身地址。它提供的反身地址是一个不会路由到任何地方的传输地址。因此，当客户端分发自反地址时，它将不会收到任何预期接收的包。攻击者对这种利用并不是很感兴趣。它会影响单个客户端，而这通常不是理想的目标。此外，任何可以发动攻击的攻击者还可以通过其他方式拒绝向客户端提供服务，例如阻止客户端从STUN服务器甚至是DHCP服务器接收任何响应。与第16.2.1节中描述的攻击一样，仅当攻击者在从STUN服务器向此未使用的IP地址发送的数据包的路径上时，此攻击才可能发生。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

16.2.3.  Attack III: 伪装客户端的身份
 
   此攻击类似于攻击II。但是，伪造的反射性地址指向攻击者本身。这使得攻击者能够接收发往客户端的通信量。
 
16.2.4.  Attack IV: 窃听
 
   在此攻击中，攻击者强制客户端使用路由到其自身的自反地址。然后，它将其接收到的任何数据包转发到客户端。此攻击允许攻击者观察发送到客户端的所有数据包。但是，要发起攻击，攻击者必须已经能够观察到从客户端到STUN服务器的数据包。在大多数情况下(例如从接入网络发起攻击时)，这意味着攻击者可能已经观察到发送到客户端的数据包。因此，这种攻击只适用于观察攻击者在从客户端到STUN服务器的路径上的通信量，而不是通常在路由到客户端的数据包路径上的通信量。
 
   请注意，这种攻击可以由STUN服务器本身发起，因此STUN服务器的用户应该与任何其他可以插入通信流的节点一样，对STUN服务器的用户具有相同级别的信任。
 






16.3.  哈希敏捷性计划
 
   此规范使用HMAC-SHA256计算消息完整性，有时与HMAC-SHA1结合使用。如果以后发现HMAC-SHA256受到威胁，应采取以下补救措施：
 
   o  将在标准跟踪文档中分配新的消息完整性属性和新的STUN安全特征位。新的消息完整性属性将使用新的散列来计算其值。STUN安全特征位将用于同时1)使用长期凭证机制向STUN客户端发信号通知该服务器支持该新的散列算法，以及2)防止对新的消息完整性属性的降价攻击。
 
   o  使用短期凭据机制的STUN客户端和服务器将需要更新它们用来通知正在使用哪些消息完整性属性的外部机制。
 
   本文档中描述的降价保护机制是新的，因此目前不能防止将散列算法的强度降低到HMAC-SHA1的降价攻击。这就是为什么，在一段过渡期之后，更新这个文档的新文档将为过时的HMAC-SHA1分配一个新的STUN安全特征位。使用时，此位将表示HMAC-SHA1已弃用，不应再使用。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

  
 
   类似地，如果发现HMAC-SHA256被破坏，将在标准跟踪文档中分配新的用户散列属性和新的STUN安全特征位。新的用户散列属性将使用新的散列来计算其值。STUN安全特征位将用于同时1)使用长期凭证机制向STUN客户端发信号通知该服务器支持该新的用户散列属性的散列算法，以及2)防止对新的用户散列属性的降价攻击。
 







17.  IAB 注意事项
 
   IAB研究了单边自地址固定(Unsaf)问题，这是客户端试图通过协作协议反射机制确定其在NAT另一端的另一个域中的地址的一般过程[RFC3424]。如果一个代理位于NAT之后，而另一个代理位于NAT的公共端，则可以使用STUN使用绑定请求/响应事务来执行此功能。
 
   IAB建议，为此目的制定的议定书应记录一组具体的考虑事项。由于某些STUN用法提供UNSAF 功能(如ICE[RFC8445])，而另一些用法(如SIP Outbound[RFC5626])不提供 UNSAF 功能，因此这些注意事项的答案需要由用法本身解决。
 




18.  IANA 注意事项
 
18.1.  STUN 安全功能注册表
 
   STUN安全功能集定义24位标志。
 
   IANA创建了一个新的注册表，其中包含STUN安全功能，这些功能受9.2.1节中描述的降价攻击预防机制保护。
 
   The initial STUN Security Features are:
 
   Bit 0: Password algorithms
   Bit 1: Username anonymity
   Bit 2-23: Unassigned</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

   位是从位集的最高有效侧开始分配的，因此位0是最左侧的位，位23是最右侧的位。
 
   新的安全功能由标准操作[RFC8126]分配。
 
18.2.  STUN 方法注册表
 
   STUN方法是介于0x000-0x0FF之间的十六进制数字。有关将STUN方法编码为STUN消息的说明，请参阅第5节。
 
   0x000-0x07F范围内的STUN方法由IETF审查[RFC8126]指定。由Expert Review[RFC8126]指定0x080-0x0FF范围内的STUN方法。专家的责任是核实所选择的码点没有被使用，并且该请求不是针对异常大量的码点。对延期的技术审查本身不属于指定专家的责任范围。
 
   IANA已更新方法0x002的名称，如下所述，并更新了以下STUN方法从RFC 5389到RFC 8489的引用：
 
   0x000: Reserved
   0x001: Binding
   0x002: Reserved; was SharedSecret prior to [RFC5389]
 
18.3.  STUN 属性注册表
 
   STUN属性类型是0x0000-0xFFFF范围内的十六进制数字。范围0x0000-0x7FFF的STUN属性类型被认为是理解必需的；范围0x8000-0xFFFF的STUN属性类型被认为是理解可选的。STUN代理处理未知理解-必需属性和理解-可选属性的方式不同。
 
   位于必须理解范围(0x0000-0x3FFF)的前半部分和理解-可选范围(0x8000-0xBFFF)的前半部分的STUN属性类型由IETF Review[RFC8126]指定。需要理解范围(0x4000-0x7FFF)的后半部分和理解-可选范围(0xC000-0xFFFF)的后半部分的STUN属性类型由专家评审分配[RFC8126]。专家的责任是核实所选择的码点没有被使用，并且该请求不是针对异常大量的码点。对延期的技术审查本身不属于指定专家的责任范围。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

18.3.1.  已更新的属性
 
   IANA更新了属性0x0002、0x0004、0x0005、0x0007和0x000B的名称，并为以下每个STUN方法更新了从RFC 5389到RFC 8489的引用。
 
   此外，[RFC5389]在属性0x0003的名称中引入了一个错误；[RFC5389]将其称为 CHANGE-ADDRESS，而它以前实际上被称为CHANGE-REQUEST.。因此，IANA已将0x0003的描述更新为“Reserved; was RESPONSE-ADDRESS prior to [RFC5389]”。
 
   Comprehension-required range (0x0000-0x7FFF):
   0x0000: Reserved
   0x0001: MAPPED-ADDRESS
   0x0002: Reserved; was RESPONSE-ADDRESS prior to [RFC5389]
   0x0003: Reserved; was CHANGE-REQUEST prior to [RFC5389]
   0x0004: Reserved; was SOURCE-ADDRESS prior to [RFC5389]
   0x0005: Reserved; was CHANGED-ADDRESS prior to [RFC5389]
   0x0006: USERNAME
   0x0007: Reserved; was PASSWORD prior to [RFC5389]
   0x0008: MESSAGE-INTEGRITY
   0x0009: ERROR-CODE
   0x000A: UNKNOWN-ATTRIBUTES
   0x000B: Reserved; was REFLECTED-FROM prior to [RFC5389]
   0x0014: REALM
   0x0015: NONCE
   0x0020: XOR-MAPPED-ADDRESS

   Comprehension-optional range (0x8000-0xFFFF)
   0x8022: SOFTWARE
   0x8023: ALTERNATE-SERVER
   0x8028: FINGERPRINT
 
18.3.2.  新增属性
 
   IANA已将以下属性添加到“STUN Attributes”注册表：
 
   Comprehension-required range (0x0000-0x7FFF):
   0x001C: MESSAGE-INTEGRITY-SHA256
   0x001D: PASSWORD-ALGORITHM
   0x001E: USERHASH

   Comprehension-optional range (0x8000-0xFFFF)
   0x8002: PASSWORD-ALGORITHMS
   0x8003: ALTERNATE-DOMAIN</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

18.4.  STUN 错误码注册表
 
   STUN错误代码是介于0-699之间的数字。STUN错误代码伴随着UTF-8[RFC3629]中的文本原因短语，该短语仅供人类使用，可以是任何适当的内容；本文档仅建议使用建议值。
 
   STUN错误代码在码点分配和语义上与SIP[RFC3261]和HTTP[RFC7231]一致。
 
   根据IETF审查[RFC8126]分配新的STUN错误代码。在批准请求之前，规范必须仔细考虑不理解此错误代码的客户端将如何处理它。请参见第6.3.4节中的规则。
 
   IANA已针对第14.8节中定义的错误代码更新了从RFC 5389到RFC 8489的参考。
 
   IANA已将401错误代码的名称从“Unauthorized”更改为“Unauthenticated”。
 








18.5.  STUN 密码算法注册表
 
   IANA创建了一个名为“STUN密码算法”的新注册表。
 
   密码算法是介于0x0000-0xFFFF之间的十六进制数字。
 
   “密码算法”注册表的初始内容如下：
 
   0x0000: Reserved
   0x0001: MD5
   0x0002: SHA-256
   0x0003-0xFFFF: Unassigned
 
   范围前半部分(0x0000-0x7FFF)中的密码算法由IETF审查[RFC8126]指定。范围后半部分(0x8000-0xFFFF)的密码算法由Expert Review[RFC8126]指定。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

18.5.1.  密码算法
 
18.5.1.1.  MD5
 
   此密码算法取自[RFC1321]。
 
   密钥长度为16字节，参数值为空。
 
      注意：此算法只能用于与旧系统兼容。
 
                key = MD5(username ":" OpaqueString(realm)
                  ":" OpaqueString(password))
 
18.5.1.2.  SHA-256
 
   此密码算法取自[RFC7616]。
 
   密钥长度为32字节，参数值为空。
 
              key = SHA-256(username ":" OpaqueString(realm)
                ":" OpaqueString(password))
 
18.6.  STUN UDP and TCP 端口号
 
   IANA已在“服务名称和传输协议端口号注册表”中为以下端口更新了从RFC 5389到RFC 8489的引用。
 
   stun   3478/tcp   Session Traversal Utilities for NAT (STUN) port
   stun   3478/udp   Session Traversal Utilities for NAT (STUN) port
   stuns  5349/tcp   Session Traversal Utilities for NAT (STUN) port
 
19.  RFC 5389以来的变化
 
   本规范将废弃[RFC5389]。此规范与RFC 5389在以下方面不同：
 
   o  添加了对 DTLS-over-UDP 的支持[RFC6347]。
 
   o  明确指出，如果没有与服务器的事务，则认为RTO已过时。
 
   o  使RTO计算与[RFC6298]一致。
 
   o  更新了TLS的密码套件。
 
   o  添加了对STUN URI的支持[RFC7064]。</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

   o  添加了对SHA256消息完整性的支持。
 
   o  根据[RFC8265]更新了国际化字符串(PRECI)支持的准备、实施和比较。
 
   o  添加了协议和注册表以选择密码加密算法。
 
   o  添加了对匿名用户名的支持。
 
   o  添加了防止降价攻击的协议和注册表。
 
   o  指定不再允许共享 NONCE。
 
   o  增加了在备用服务器机制中使用域名的可能性。
 
   o  添加了更多的C代码片段。
 
   o  添加了测试向量。
 

20.  引用
 
20.1.  引用标准
 
   [ITU.V42.2002]
              International Telecommunication Union, "Error-correcting
              procedures for DCEs using asynchronous-to-synchronous
              conversion", ITU-T Recommendation V.42, March 2002.

   [KARN87]   Karn, P. and C. Partridge, "Improving Round-Trip Time
              Estimates in Reliable Transport Protocols", SIGCOMM '87,
              Proceedings of the ACM workshop on Frontiers in computer
              communications technology, Pages 2-7,
              DOI 10.1145/55483.55484, August 1987.

   [RFC0791]  Postel, J., "Internet Protocol", STD 5, RFC 791,
              DOI 10.17487/RFC0791, September 1981,
              <https: www.rfc-editor.org="" info="" rfc791="">.

   [RFC1122]  Braden, R., Ed., "Requirements for Internet Hosts -
              Communication Layers", STD 3, RFC 1122,
              DOI 10.17487/RFC1122, October 1989,
              <https: www.rfc-editor.org="" info="" rfc1122="">.</https:></https:></pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;">

   [RFC1123]  Braden, R., Ed., "Requirements for Internet Hosts -
              Application and Support", STD 3, RFC 1123,
              DOI 10.17487/RFC1123, October 1989,
              <https: www.rfc-editor.org="" info="" rfc1123="">.

   [RFC1321]  Rivest, R., "The MD5 Message-Digest Algorithm", RFC 1321,
              DOI 10.17487/RFC1321, April 1992,
              <https: www.rfc-editor.org="" info="" rfc1321="">.

   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", RFC 2104,
              DOI 10.17487/RFC2104, February 1997,
              <https: www.rfc-editor.org="" info="" rfc2104="">.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https: www.rfc-editor.org="" info="" rfc2119="">.

   [RFC2782]  Gulbrandsen, A., Vixie, P., and L. Esibov, "A DNS RR for
              specifying the location of services (DNS SRV)", RFC 2782,
              DOI 10.17487/RFC2782, February 2000,
              <https: www.rfc-editor.org="" info="" rfc2782="">.

   [RFC3629]  Yergeau, F., "UTF-8, a transformation format of ISO
              10646", STD 63, RFC 3629, DOI 10.17487/RFC3629, November
              2003, <https: www.rfc-editor.org="" info="" rfc3629="">.

   [RFC4648]  Josefsson, S., "The Base16, Base32, and Base64 Data
              Encodings", RFC 4648, DOI 10.17487/RFC4648, October 2006,
              <https: www.rfc-editor.org="" info="" rfc4648="">.

   [RFC5890]  Klensin, J., "Internationalized Domain Names for
              Applications (IDNA): Definitions and Document Framework",
              RFC 5890, DOI 10.17487/RFC5890, August 2010,
              <https: www.rfc-editor.org="" info="" rfc5890="">.

   [RFC6125]  Saint-Andre, P. and J. Hodges, "Representation and
              Verification of Domain-Based Application Service Identity
              within Internet Public Key Infrastructure Using X.509
              (PKIX) Certificates in the Context of Transport Layer
              Security (TLS)", RFC 6125, DOI 10.17487/RFC6125, March
              2011, <https: www.rfc-editor.org="" info="" rfc6125="">.

   [RFC6151]  Turner, S. and L. Chen, "Updated Security Considerations
              for the MD5 Message-Digest and the HMAC-MD5 Algorithms",
              RFC 6151, DOI 10.17487/RFC6151, March 2011,
              <https: www.rfc-editor.org="" info="" rfc6151="">.</https:></https:></https:></https:></https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

   [RFC6298]  Paxson, V., Allman, M., Chu, J., and M. Sargent,
              "Computing TCP's Retransmission Timer", RFC 6298,
              DOI 10.17487/RFC6298, June 2011,
              <https: www.rfc-editor.org="" info="" rfc6298="">.

   [RFC6347]  Rescorla, E. and N. Modadugu, "Datagram Transport Layer
              Security Version 1.2", RFC 6347, DOI 10.17487/RFC6347,
              January 2012, <https: www.rfc-editor.org="" info="" rfc6347="">.

   [RFC7064]  Nandakumar, S., Salgueiro, G., Jones, P., and M. Petit-
              Huguenin, "URI Scheme for the Session Traversal Utilities
              for NAT (STUN) Protocol", RFC 7064, DOI 10.17487/RFC7064,
              November 2013, <https: www.rfc-editor.org="" info="" rfc7064="">.

   [RFC7350]  Petit-Huguenin, M. and G. Salgueiro, "Datagram Transport
              Layer Security (DTLS) as Transport for Session Traversal
              Utilities for NAT (STUN)", RFC 7350, DOI 10.17487/RFC7350,
              August 2014, <https: www.rfc-editor.org="" info="" rfc7350="">.

   [RFC7616]  Shekh-Yusef, R., Ed., Ahrens, D., and S. Bremer, "HTTP
              Digest Access Authentication", RFC 7616,
              DOI 10.17487/RFC7616, September 2015,
              <https: www.rfc-editor.org="" info="" rfc7616="">.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https: www.rfc-editor.org="" info="" rfc8174="">.

   [RFC8200]  Deering, S. and R. Hinden, "Internet Protocol, Version 6
              (IPv6) Specification", STD 86, RFC 8200,
              DOI 10.17487/RFC8200, July 2017,
              <https: www.rfc-editor.org="" info="" rfc8200="">.

   [RFC8265]  Saint-Andre, P. and A. Melnikov, "Preparation,
              Enforcement, and Comparison of Internationalized Strings
              Representing Usernames and Passwords", RFC 8265,
              DOI 10.17487/RFC8265, October 2017,
              <https: www.rfc-editor.org="" info="" rfc8265="">.

   [RFC8305]  Schinazi, D. and T. Pauly, "Happy Eyeballs Version 2:
              Better Connectivity Using Concurrency", RFC 8305,
              DOI 10.17487/RFC8305, December 2017,
              <https: www.rfc-editor.org="" info="" rfc8305="">.</https:></https:></https:></https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

20.2.  信息性参考文献
 
   [Argon2]   Biryukov, A., Dinu, D., Khovratovich, D., and S.
              Josefsson, "The memory-hard Argon2 password hash and
              proof-of-work function", Work in Progress, draft-irtf-
              cfrg-argon2-09, November 2019.

   [BCP195]   Sheffer, Y., Holz, R., and P. Saint-Andre,
              "Recommendations for Secure Use of Transport Layer
              Security (TLS) and Datagram Transport Layer Security
              (DTLS)", BCP 195, RFC 7525, May 2015,
              <https: www.rfc-editor.org="" info="" bcp195="">.

   [RFC1952]  Deutsch, P., "GZIP file format specification version 4.3",
              RFC 1952, DOI 10.17487/RFC1952, May 1996,
              <https: www.rfc-editor.org="" info="" rfc1952="">.

   [RFC2279]  Yergeau, F., "UTF-8, a transformation format of ISO
              10646", RFC 2279, DOI 10.17487/RFC2279, January 1998,
              <https: www.rfc-editor.org="" info="" rfc2279="">.

   [RFC3261]  Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,
              A., Peterson, J., Sparks, R., Handley, M., and E.
              Schooler, "SIP: Session Initiation Protocol", RFC 3261,
              DOI 10.17487/RFC3261, June 2002,
              <https: www.rfc-editor.org="" info="" rfc3261="">.

   [RFC3424]  Daigle, L., Ed. and IAB, "IAB Considerations for
              UNilateral Self-Address Fixing (UNSAF) Across Network
              Address Translation", RFC 3424, DOI 10.17487/RFC3424,
              November 2002, <https: www.rfc-editor.org="" info="" rfc3424="">.

   [RFC3454]  Hoffman, P. and M. Blanchet, "Preparation of
              Internationalized Strings ("stringprep")", RFC 3454,
              DOI 10.17487/RFC3454, December 2002,
              <https: www.rfc-editor.org="" info="" rfc3454="">.

   [RFC3489]  Rosenberg, J., Weinberger, J., Huitema, C., and R. Mahy,
              "STUN - Simple Traversal of User Datagram Protocol (UDP)
              Through Network Address Translators (NATs)", RFC 3489,
              DOI 10.17487/RFC3489, March 2003,
              <https: www.rfc-editor.org="" info="" rfc3489="">.

   [RFC4013]  Zeilenga, K., "SASLprep: Stringprep Profile for User Names
              and Passwords", RFC 4013, DOI 10.17487/RFC4013, February
              2005, <https: www.rfc-editor.org="" info="" rfc4013="">.</https:></https:></https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

   [RFC4107]  Bellovin, S. and R. Housley, "Guidelines for Cryptographic
              Key Management", BCP 107, RFC 4107, DOI 10.17487/RFC4107,
              June 2005, <https: www.rfc-editor.org="" info="" rfc4107="">.

   [RFC5090]  Sterman, B., Sadolevsky, D., Schwartz, D., Williams, D.,
              and W. Beck, "RADIUS Extension for Digest Authentication",
              RFC 5090, DOI 10.17487/RFC5090, February 2008,
              <https: www.rfc-editor.org="" info="" rfc5090="">.

   [RFC5389]  Rosenberg, J., Mahy, R., Matthews, P., and D. Wing,
              "Session Traversal Utilities for NAT (STUN)", RFC 5389,
              DOI 10.17487/RFC5389, October 2008,
              <https: www.rfc-editor.org="" info="" rfc5389="">.

   [RFC5626]  Jennings, C., Ed., Mahy, R., Ed., and F. Audet, Ed.,
              "Managing Client-Initiated Connections in the Session
              Initiation Protocol (SIP)", RFC 5626,
              DOI 10.17487/RFC5626, October 2009,
              <https: www.rfc-editor.org="" info="" rfc5626="">.

   [RFC5766]  Mahy, R., Matthews, P., and J. Rosenberg, "Traversal Using
              Relays around NAT (TURN): Relay Extensions to Session
              Traversal Utilities for NAT (STUN)", RFC 5766,
              DOI 10.17487/RFC5766, April 2010,
              <https: www.rfc-editor.org="" info="" rfc5766="">.

   [RFC5769]  Denis-Courmont, R., "Test Vectors for Session Traversal
              Utilities for NAT (STUN)", RFC 5769, DOI 10.17487/RFC5769,
              April 2010, <https: www.rfc-editor.org="" info="" rfc5769="">.

   [RFC5780]  MacDonald, D. and B. Lowekamp, "NAT Behavior Discovery
              Using Session Traversal Utilities for NAT (STUN)",
              RFC 5780, DOI 10.17487/RFC5780, May 2010,
              <https: www.rfc-editor.org="" info="" rfc5780="">.

   [RFC6544]  Rosenberg, J., Keranen, A., Lowekamp, B., and A. Roach,
              "TCP Candidates with Interactive Connectivity
              Establishment (ICE)", RFC 6544, DOI 10.17487/RFC6544,
              March 2012, <https: www.rfc-editor.org="" info="" rfc6544="">.

   [RFC7231]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content", RFC 7231,
              DOI 10.17487/RFC7231, June 2014,
              <https: www.rfc-editor.org="" info="" rfc7231="">.</https:></https:></https:></https:></https:></https:></https:></https:></https:></pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for
              Writing an IANA Considerations Section in RFCs", BCP 26,
              RFC 8126, DOI 10.17487/RFC8126, June 2017,
              <https: www.rfc-editor.org="" info="" rfc8126="">.

   [RFC8264]  Saint-Andre, P. and M. Blanchet, "PRECIS Framework:
              Preparation, Enforcement, and Comparison of
              Internationalized Strings in Application Protocols",
              RFC 8264, DOI 10.17487/RFC8264, October 2017,
              <https: www.rfc-editor.org="" info="" rfc8264="">.

   [RFC8445]  Keranen, A., Holmberg, C., and J. Rosenberg, "Interactive
              Connectivity Establishment (ICE): A Protocol for Network
              Address Translator (NAT) Traversal", RFC 8445,
              DOI 10.17487/RFC8445, July 2018,
              <https: www.rfc-editor.org="" info="" rfc8445="">.

   [RFC8446]  Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https: www.rfc-editor.org="" info="" rfc8446="">.

   [STUN-PMTUD]
              Petit-Huguenin, M., Salgueiro, G., and F. Garrido,
              "Packetization Layer Path MTU Discovery (PLMTUD) For UDP
              Transports Using Session Traversal Utilities for NAT
              (STUN)", Work in Progress, draft-ietf-tram-stun-pmtud-15,
              December 2019.

   [UAX15]    Unicode Standard Annex #15, "Unicode Normalization Forms",
              edited by Mark Davis and Ken Whistler.  An integral part
              of The Unicode Standard,
              <http: unicode.org="" reports="" tr15="">.</http:></https:></https:></https:></https:></pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

Appendix A.  用于确定STUN消息类型的C代码段
 
   给定msg_type参数中以主机字节顺序表示的16位STUN消息类型值，下面是用于确定STUN消息类型的C宏：
 
   <code begins="">
   #define IS_REQUEST(msg_type)       (((msg_type) &amp; 0x0110) == 0x0000)
   #define IS_INDICATION(msg_type)    (((msg_type) &amp; 0x0110) == 0x0010)
   #define IS_SUCCESS_RESP(msg_type)  (((msg_type) &amp; 0x0110) == 0x0100)
   #define IS_ERR_RESP(msg_type)      (((msg_type) &amp; 0x0110) == 0x0110)
   <code ends="">
 
   将方法和类转换为消息类型的函数：
 
   <code begins="">
   int type(int method, int cls) {
     return (method &amp; 0x1F80) &lt;&lt; 2 | (method &amp; 0x0070) &lt;&lt; 1
       | (method &amp; 0x000F) | (cls &amp; 0x0002) &lt;&lt; 7
       | (cls &amp; 0x0001) &lt;&lt; 4;
     }
   <code ends="">

   从消息类型提取方法的函数：

   <code begins="">
   int method(int type) {
     return (type &amp; 0x3E00) &gt;&gt; 2 | (type &amp; 0x00E0) &gt;&gt; 1
       | (type &amp; 0x000F);
     }
   <code ends="">

   从消息类型中提取类的函数：

   <code begins="">
   int cls(int type) {
     return (type &amp; 0x0100) &gt;&gt; 7 | (type &amp; 0x0010) &gt;&gt; 4;
     }
   <code ends=""></code></code></code></code></code></code></code></code></pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

Appendix B.  测试向量
 
   本节使用 MESSAGE-INTEGRITY-SHA256 补充了[RFC5769]中定义的测试向量列表。[RFC5769]第 ；2节中列出的所有格式和定义均适用于此。
 
B.1.  使用 MESSAGE-INTEGRITY-SHA256 和 USERHASH 进行长期身份验证的示例请求
 
   该请求使用以下参数：
 
   Username: "<u+30de><u+30c8><u+30ea><u+30c3><u+30af><u+30b9>" (去掉引号) unaffected by OpaqueString [RFC8265] processing
 
   Password: "The<u+00ad>M<u+00aa>tr<u+2168>" and "TheMatrIX" (去掉引号) 分别是OpaqueString[RFC8265]处理前后
 
   Nonce: "obMatJos2AAACf//499k954d6OL34oL9FSTvy64sA" (去掉引号)
 
   Realm: "example.org" (去掉引号)
 
        00 01 00 9c      Request type and message length
        21 12 a4 42      Magic cookie
        78 ad 34 33   }
        c6 ad 72 c0   }  Transaction ID
        29 da 41 2e   }
        00 1e 00 20      USERHASH attribute header
        4a 3c f3 8f   }
        ef 69 92 bd   }
        a9 52 c6 78   }
        04 17 da 0f   }  Userhash value (32 bytes)
        24 81 94 15   }
        56 9e 60 b2   }
        05 c4 6e 41   }
        40 7f 17 04   }
        00 15 00 29      NONCE attribute header
        6f 62 4d 61   }
        74 4a 6f 73   }
        32 41 41 41   }
        43 66 2f 2f   }
        34 39 39 6b   }  Nonce value and padding (3 bytes)
        39 35 34 64   }
        36 4f 4c 33   }
        34 6f 4c 39   }
        46 53 54 76   }
        79 36 34 73   }
        41 00 00 00   }</u+2168></u+00aa></u+00ad></u+30b9></u+30af></u+30c3></u+30ea></u+30c8></u+30de></pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 


        00 14 00 0b      REALM attribute header
        65 78 61 6d   }
        70 6c 65 2e   }  Realm value (11 bytes) and padding (1 byte)
        6f 72 67 00   }
        00 1c 00 20      MESSAGE-INTEGRITY-SHA256 attribute header
        e4 68 6c 8f   }
        0e de b5 90   }
        13 e0 70 90   }
        01 0a 93 ef   }  HMAC-SHA256 value
        cc bc cc 54   }
        4c 0a 45 d9   }
        f8 30 aa 6d   }
        6f 73 5a 01   }
 
Acknowledgements
 
   Thanks to Michael Tuexen, Tirumaleswar Reddy, Oleg Moskalenko, Simon   Perreault, Benjamin Schwartz, Rifaat Shekh-Yusef, Alan Johnston,   Jonathan Lennox, Brandon Williams, Olle Johansson, Martin Thomson,   Mihaly Meszaros, Tolga Asveren, Noriyuki Torii, Spencer Dawkins, Dale   Worley, Matthew Miller, Peter Saint-Andre, Julien Elie, Mirja   Kuehlewind, Eric Rescorla, Ben Campbell, Adam Roach, Alexey Melnikov,   and Benjamin Kaduk for the comments, suggestions, and questions that   helped improve this document.
 
   The Acknowledgements section of RFC 5389 appeared as follows:
 
   The authors would like to thank Cedric Aoun, Pete Cordell, Cullen   Jennings, Bob Penfield, Xavier Marjou, Magnus Westerlund, Miguel   Garcia, Bruce Lowekamp, and Chris Sullivan for their comments, and   Baruch Sterman and Alan Hawrylyshen for initial implementations.   Thanks for Leslie Daigle, Allison Mankin, Eric Rescorla, and Henning   Schulzrinne for IESG and IAB input on this work.
 
Contributors
 
   Christian Huitema and Joel Weinberger were original coauthors of   RFC 3489.</pre>
<hr class="noprint"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap; font-size: 14px; font-family: fangsong;"> 

Authors' Addresses

   Marc Petit-Huguenin
   Impedance Mismatch

   Email: marc@petit-huguenin.org


   Gonzalo Salgueiro
   Cisco
   7200-12 Kit Creek Road
   Research Triangle Park, NC  27709
   United States of America

   Email: gsalguei@cisco.com


   Jonathan Rosenberg
   Five9
   Edison, NJ
   United States of America

   Email: jdrosen@jdrosen.net
   URI:   http://www.jdrosen.net


   Dan Wing
   Citrix Systems, Inc.
   United States of America

   Email: dwing-ietf@fuggles.com


   Rohan Mahy
   Unaffiliated

   Email: rohan.ietf@gmail.com


   Philip Matthews
   Nokia
   600 March Road
   Ottawa, Ontario  K2K 2T6
   Canada

   Phone: 613-784-3139
   Email: philip_matthews@magma.ca
 

 
</pre>




</div>
