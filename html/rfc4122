<div class="content" style="float: left; margin: 0px 30%; width: 579px; font-size: 10pt;">
   <div style="height: 13px;">
      <div onmouseover="this.style.cursor='pointer';" onclick="showElem('legend');" onmouseout="hideElem('legend')" style="height: 6px; position: absolute; cursor: pointer;" class="pre noprint docinfo bgblue" title="Click for colour legend.">                                                                        </div>
      <div id="legend" class="docinfo noprint pre legend" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; " onmouseover="showElem('legend');" onmouseout="hideElem('legend');">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="../html/" title="Document search and retrieval page">Docs</a>] [<a href="/rfc/rfc4122.txt" title="Plaintext version of this document">txt</a>|<a href="/pdf/rfc4122" title="PDF version of this document">pdf</a>] [<a href="./draft-mealling-uuid-urn" title="draft-mealling-uuid-urn">draft-mealling-...</a>] [<a href="https://datatracker.ietf.org/doc/rfc4122" title="IESG Datatracker information for this document">Tracker</a>] [<a href="/rfcdiff?difftype=--hwdiff&amp;url2=rfc4122" title="Inline diff (wdiff)">Diff1</a>] [<a href="/rfcdiff?url2=rfc4122" title="Side-by-side diff">Diff2</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=4122">Errata</a>]</span><br>
<span class="pre noprint docinfo">                                                                        </span><br>
<span class="pre noprint docinfo">                                                       PROPOSED STANDARD</span><br>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br>
<pre style="height: 780px; white-space: pre-wrap;">Network Working Group                                           P. Leach
Request for Comments: 4122                                     Microsoft
Category: Standards Track                                    M. Mealling
                                                Refactored Networks, LLC
                                                                 R. Salz
                                              DataPower Technology, Inc.
                                                               July 2005
 

                   通用唯一标识器 (UUID) URN 命名空间
 
本备忘录的状态
 
   本文档为 Internet 社区指定了 Internet 标准跟踪协议,并请求讨论和改进建议。 有关
   此协议的标准化状态和状态,请参阅当前版本的"互联网官方协议标准"(STD 1)。 此备忘录的
   分发是无限制的。
 
版权声明
 
   版权所有(C) 互联网协会(2005年)。
 
摘要
 
   此规范为 UUID(通用唯一标识器)定义了统一资源名称命名空间,也称为 GUID(全局唯一标
   识)。 UUID 长 128 位,可以保证跨空间和跨时间的唯一性。 UUID 最初用于 Apollo 
   网络计算系统,后来在开放软件基金会 (OSF) 分布式计算环境 (DCE) 中,然后在 
   Microsoft Windows 平台中使用。
 
   此规范派生自具有 OSF(现在称为开放组)的某种权限的 DCE 规范。  来自早期版本的 DCE 
   规范的信息已纳入本文档。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
目录
 
   1. 介绍  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  2
   2. 起因  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3
   3. 命名空间注册模板  . . . . . . . .   . . . . . . . . . . . . . . .  3
   4. 规范  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5
      4.1. 格式 . . . . . . . . . . . . . . . . . . . . . . . . . . .  5
           4.1.1. 变种    . . . . . . . . . . . . . . . . . . . . . .  6
           4.1.2. 布局和字节顺序          . . . . . . . . . . . . . . .  6
           4.1.3. 版本    . . . . . . . . . . . . . . . . . . . . . .  7
           4.1.4. 时间戳    . . . . . . . . . . . . . . . . . . . . .  8
           4.1.5. 时钟序列         . . . . . . . . . . . . . . . . . .  8
           4.1.6. 节点  . . . . . . . . . . . . . . . . . . . . . . .  9
           4.1.7. nil UUID . . . . . . . . . . . . . . . . . . . . .  9
      4.2. 用于创建基于时间的 UUID 的算法                 . . . . . . . .  9
           4.2.1. 基本算法         . . . . . . . . . . . . . . . . . . 10
           4.2.2. 生成详细信息          . . . . . . . . . . . . . . . . 12
      4.3. 创建基于名称的 UUID 的算法                  . . . . . . . . . 13
      4.4. 从真正随机或伪随机数创建 UUID 的算法  . . . . . . . . . . . . . 14
      4.5. 未认证主机的节点标识                      . . . . . . . . . . 15
   5. 社区注意事项               . . . . . . . . . . . . . . . . . . . 15
   6. 安全注意事项               . . . . . . . . . . . . . . . . . . . 16
   7. 致谢              . . . . . . . . . . . . . . . . . . . . . . . 16
   8. 参考规范               . . . . . . . . . . . . . . . . . . . . . 16
   A. 附录 A - 示例实现                     . . . . . . . . . . . . . . 18
   B. 附录 B - utest 的样本输出               . . . . . . . . . . . . . 29
   C. 附录 C - 部分名称空间               . . . . . . . . . . . . . . . 30
 
<h2>
<a class="selflink" name="section-1" href="#section-1">1</a>.  介绍
</h2>
 
   此规范为 UUID(通用唯一标识器)定义了统一资源名称命名空间,也称为 GUID(全局唯一标
   识)。 UUID 长 128 位,无需中央注册过程。
 
   此处的信息旨在成为希望使用 UUID 作为 URN 实施服务的人员的简明指南。 本文档中的
   任何内容均不应解释为覆盖定义 UUID 的 DCE 标准。
 
   ITU-T 建议和 ISO/IEC 标准 [3] 源自本文档的早期版本。 两套规格均已对齐,在技术上
   完全兼容。 此外,ITU-T电信标准化局正在提供全球注册功能;  有关详细信息,请参阅
   <a href="http://www.itu.int/ITU-T/asn1/uuid.html">http://www.itu.int/ITU-T/asn1/uuid.html</a></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
<h2><a class="selflink" name="section-2" href="#section-2">2</a>.  起因</h2>
 
   使用 UUID 的主要原因之一是不需要集中机构来管理它们(尽管一种格式使用 IEEE 802 节点
   标识符,但其他格式不使用)。 因此,按需生成可以完全自动化,并用于各种目的。 此处描述的
   UUID 生成算法支持高达每秒 1000 万/台(如有必要)的非常高的分配速率,以便它们甚至可以
   用作事务 ID。
 
   UUID 是固定大小(128 位),与其他替代方法相比相当小。 这非常适合对各种排序、排序和
   哈希,在数据库中存储,进行简单的分配,并且通常易于编程。
 
   由于 UUID 是唯一且持久的,因此它们会创建出色的统一资源名称。 在没有注册过程的情况下
   生成新的 UUID 的独特能力使 UUID 成为具有最低造币成本的 URN 之一。
 
<h2><a class="selflink" name="section-3" href="#section-3">3</a>.  命名空间注册模板</h2>
 
   命名空间 ID:  UUID
   注册信息:
      注册日期: 2003-10-01
 
   已声明的命名空间注册人:
      JTC 1/SC6 (ASN.1 Rapporteur Group)
 
   语法结构声明:
      UUID 是一个标识符,相对于所有 UUID 的空间,在空间和时间上都是唯一的。 由于 UUID
      是固定大小且包含时间字段,因此值可以滚动(大约在 A.D. 3400 附近,具体取决于所使
      用的特定算法)。 UUID 可用于多种目的,从标记生存期极短的对象到可靠地识别网络中
      非常持久的对象。
 
      UUID 的内部表示形式是内存中特定的位序列,如第 4 节所述。 要将 UUID 准确地表示
      为 URN,必须将位序列转换为字符串表示形式。
 
      每个字段都被视为整数,其值打印为具有数字零填充的十六进制数字字符串。 十六
      进制值 "a" 到 "f" 作为小写字符输出,并且对输入不区分大小写。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
      UUID 字符串表示形式的正式定义由以下 ABNF [7]提供:
 
      UUID                   = time-low "-" time-mid "-"
                               time-high-and-version "-"
                               clock-seq-and-reserved
                               clock-seq-low "-" node
      time-low               = [4]hexOctet
      time-mid               = [2]hexOctet
      time-high-and-version  = [2]hexOctet
      clock-seq-and-reserved = [1]hexOctet
      clock-seq-low          = [1]hexOctet
      node                   = [6]hexOctet
      hexOctet               = hexDigit hexDigit
      hexDigit =
            "0" / "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9" /
            "a" / "b" / "c" / "d" / "e" / "f" /
            "A" / "B" / "C" / "D" / "E" / "F"
 
   下面是 UUID 作为 URN 的字符串表示形式的示例:
 
   urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6
 
   相关辅助文件:
      [1][2]
   标识符唯一性注意事项:
      本文档指定了三种算法来生成 UUID:第一种算法利用 802 MAC 地址的唯一值来保证
      唯一性,第二种算法使用伪随机数生成器,第三种算法使用加密哈希和应用程序-提供的文本
      字符串。因此,根据此处的机制生成的 UUID 将不同于已分配或将分配的所有其他 UUID。
 
   标识符持久性注意事项:
      从全球意义上讲, UUID 本身就很难解决。这一点,加上 UUID 在其空间上下文中在时间上
      是唯一的事实,可确保 UUID 尽可能持久。
 
   标识符分配过程:
      生成 UUID 不需要联系注册机构。一种算法要求每个生成器在空间上具有唯一值。此值
      通常是 IEEE 802 MAC 地址,通常在联网的主机上已有可用。可以从从 IEEE 注册机构
      获取的地址块分配地址。 如果没有此类地址,或者隐私问题使其使用不可取, 第 4.5 节
      指定两种备选方案。 另一种方法是使用版本 3 或版本 4 。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
      


 
   标识符解析过程:
      由于 UUID 无法全局解析,因此这不适用。
 
   词汇等价规则:
      将 UUID 的每个字段视为无符号整数,如第 4.1.2 节中的表所示。 然后,比较一对 
      UUID,按显著性顺序和数据类型对每个 UUID 的相应字段进行比较。仅当所有相应的
      字段都相等时,两个 UUID 才相等。
 
      作为实现说明,可以通过执行适当的字节顺序规范化,然后将两个 UUID 视为 128 位
      无符号整数,在许多系统上执行相等比较。
 
      本文档中定义的 UUID 也可以按字典顺序排序。 对于一对 UUID,如果 UUID 中最重要
      的字段对于第一个 UUID 较大,则第一个 UUID 紧随其后。 如果 UUID 中的最重要的
      字段大于第二个 UUID,则第二个字段位于第一个字段之前。
 
   符合 URN 语法:
      UUID 的字符串表示形式与 URN 语法完全兼容。 将 UUID 的面向位、内存中表示形式
      转换为 URN 时,必须注意严格遵守字符串表示部分中提到的字节顺序问题。
 
   验证机制:
      除了确定 UUID 的时间戳部分是否位于将来,因此尚未分配之外,没有机制可以确定 UUID
      是否"有效"。
 
   范围：
      UUID 是全局范围的。
 
4. 规格
 
4.1. 格式
 
   UUID 格式为 16 个八位字节;下面指定八位变量字段的某些位更精细的结构。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.1.1. 变体
 
   变体字段确定 UUID 的布局。 也就是说,UUID 中所有其他位的解释取决于变体字段中位的
   设置。 因此,可以更准确地称为类型字段;我们保留原始兼容性术语。 变体字段由 UUID 的
   八位字节 8 的可变数组成。
 
   下表列出了变体字段的内容,其中字母 "x" 表示 "don't-care" 值。
 
   Msb0  Msb1  Msb2  Description
 
    0     x     x    保留,NCS 向后兼容性。
 
    1     0     x    本文档中指定的变体。
 
    1     1     0    保留,微软公司向后兼容性
 
    1     1     1    保留以供将来定义。
 
   任何形式的互操作性(与此处定义的变体以外的变体)都不能保证,在实践中也不太可能成为
   问题。
 
4.1.2. 布局和字节顺序
 
   为了尽量减少对八位内位分配的混淆,UUID 记录定义仅根据八位字节的整数字段进行定义。
   首先,字段将呈现其中最重要的字段。
 
   字段                     数据类型      位置    提示
                                        #
 
   time_low               unsigned 32   0-3    时间戳的低位
                          bit integer          
 
   time_mid               unsigned 16   4-5    时间戳的中间位
                          bit integer          
 
   time_hi_and_version    unsigned 16   6-7    使用版本号多路复用的时间戳的
                          bit integer          高位字段
   
   clock-seq-and-reserved  unsigned 8    8     时钟序列的高位与变体多路复用
                          bit integer

   clock_seq_low          unsigned 8     9     时钟序列的低位
                          bit integer

   node                   unsigned 48   10-15  空间唯一节点标识符
                          bit integer      </pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 











 
   在没有明确的应用程序或表示协议规范相反的情况下,UUID 被编码为 128 位对象,如下所示:
 
   字段编码为 16 个八位字节,上面定义了字段的大小和顺序,并且每个字段首先使用"大端法"
   编码(称为网络字节顺序)。 请注意,字段名称(尤其是多路复用字段)遵循历史实践。
 
   0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          time_low                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       time_mid                |         time_hi_and_version   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |clk_seq_hi_res |  clk_seq_low  |         node (0-1)            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         node (2-5)                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 
4.1.3. 版本
 
   版本号位于时间戳的 4 位中(time_hi_and_version 字段的 4 到 7 位)。
 
   下表列出了此 UUID 变体的当前定义版本。
 
   Msb0  Msb1  Msb2  Msb3   Version  Description
 
    0     0     0     1        1     本文档中指定的基于时间的版本。
 
    0     0     1     0        2     DCE 安全版本,具有嵌入式 POSIX UID。

    0     0     1     1        3     使用 MD5 哈希的基于名称的版本。

    0     1     0     0        4     随机或伪随机生成的版本。

    0     1     0     1        5     使用 SHA-1 哈希的基于名称的版本。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 













 
   这里的"版本"更准确地说是"子类型";同样,我们保留了兼容性的术语。
 
4.1.4. 时间戳
 
   时间戳是 60 位值。 对于 UUID 版本 1,这由协调世界时间 (UTC) 表示为自 1582 年
   10 月 15 日 00:00:00.00(基督教历公历改革日期)以来的 100 纳秒间隔计数。
 
   对于没有 UTC 可用但具有本地时间的系统,它们可以使用该系统而不是 UTC,只要它们在整个
   系统中始终如一地使用 UTC。 但是,不建议这样做,因为从本地时间生成 UTC 只需要时区
   偏移量。
 
   对于 UUID 版本 3 或 5,时间戳是一个 60 位值,由第 4.3 节中所述的名称构造。
 
   对于 UUID 版本 4,时间戳是随机或伪随机生成的 60 位值,如第 4.4 节所述。
 





4.1.5. 时钟序列
 
   对于 UUID 版本 1,时钟序列用于帮助避免在时间向后设置时钟或节点 ID 更改时可能出现
   的重复。
 
   如果时钟是向后设置的,或者可能已向后设置(例如,当系统关闭电源时),并且 UUID 生成器
   无法确保没有生成时间戳大于时钟设置的 UUID 值 ,则时钟序列必须改变。 如果时钟
   序列的上一个值是已知的,它可以只是增加;否则,应将其设置为随机或高质量的伪随机值。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   同样,如果节点 ID 发生更改(例如,因为网卡已在计算机之间移动),将时钟序列设置为随机数
   可最大程度地降低由于计算机时钟设置略有不同而导致的重复的可能性。 如果已知与已更改的
   节点 ID 关联的时钟序列值,则时钟序列可能只是递增的,但不太可能。
 
   时钟序列必须最初(即,在系统的生存期内一次)初始化为随机数,以尽量减少系统之间的关联。
   这提供了针对节点标识符的最大保护,这些节点标识符可能会快速移动或从系统切换到系统。
   初始值不得与节点标识符关联。
 
   对于 UUID 版本 3 或 5,时钟序列是一个 14 位值,该值由第 4.3 节中所述的名称构造。
 
   对于 UUID 版本 4,时钟序列是随机或伪随机生成的 14 位值,如第 4.4 节所述。
 





4.1.6. 节点
 
   对于 UUID 版本 1,节点字段由 IEEE 802 MAC 地址(通常是主机地址)组成。 对于具有
   多个 IEEE 802 地址的系统,可以使用任何可用地址。 最低地址八位字节(八位字节数 10)
   包含全局/本地位和单播/多播位,并且是在 802.3 LAN 上传输的地址的第一个八位字节。
 
   对于没有 IEEE 地址的系统,可以使用随机或伪随机生成的值;参见第 4.5 节。 多播位必须
   在此类地址中设置,以便它们永远不会与从网卡获取的地址冲突。
 
   对于 UUID 版本 3 或 5,节点字段是一个 48 位值,该值由第 4.3 节中所述的名称构造。
 
   对于 UUID 版本 4,节点字段是随机或伪随机生成的 48 位值,如第 4.4 节所述。
 
4.1.7. Nil UUID
 
   nil UUID 是特殊形式的 UUID,指定将所有 128 位设置为零。
 
4.2. 创建基于时间的 UUID 的算法
 
   以下各节将讨论创建版本 1 UUID 的算法的各个方面。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.1. 基本算法
 
   以下算法简单、正确且效率低下:
 
   o 获取系统范围全局锁
 
   o 从系统范围的共享稳定存储(例如,文件)中读取 UUID 生成器状态:用于生成最后一个 
     UUID 的时间戳、时钟序列和节点 ID 的值。
 
   o 获取当前时间作为自 1582 年 10 月 15 日 00:00:00.00 以来的 100 纳秒间隔的
     60 位计数。
 
   o 获取当前节点 ID。
 
   o 如果状态不可用(例如,不存在或已损坏),或者保存的节点 ID 与当前节点 ID 不同,则
     生成随机时钟序列值。
 
   o 如果状态可用,但保存的时间戳晚于当前时间戳,则递增时钟序列值。
 
   o 将状态(当前时间戳、时钟序列和节点 ID)保存回稳定存储。
 
   o 释放全局锁。
 
   o 根据第 4.2.2 节中的步骤,从当前时间戳、时钟序列和节点 ID 值格式化 UUID。
 
   如果 UUD 不需要频繁生成,则上述算法可能完全足够。 但是,对于更高的性能要求,基本算法
   的问题包括:
 
   o 每次从稳定存储读取状态的效率很低。
 
   o 系统时钟的分辨率不能为 100 纳秒。
 
   o 每次将状态写入稳定存储是低效的。
 
   o 跨进程边界共享状态可能效率低下。
 
   通过对读取和写入状态和读取时钟的函数进行局部改进,可以以模块化方式解决每个问题。
   我们将在以下各节中依次讨论它们。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 4.2.1.1. 读取稳定存储
 
   如果状态读取到系统范围的共享易失性存储(并在稳定存储更新时更新),则只需在启动时从稳定
   存储读取一次状态。
 
   如果实现没有任何可用的稳定存储,则始终可以说值不可用。 这是最不理想的实现,因为它会
   增加创建新时钟序列号的频率,从而增加重复的可能性。
 
   如果节点 ID 永远无法更改(例如,网卡与系统密不可分),或者如果任何更改也重新初始化时钟
   序列到随机值,则不将其保持在稳定的存储中,则可以返回当前节点 ID。
 
4.2.1.2. 系统时钟分辨率
 
   时间戳由系统时间生成,其分辨率可能小于 UUID 时间戳的分辨率。
 
   如果不需要频繁生成 UUID,则时间戳可以简单地将系统时间乘以每个系统时间间隔 100 纳秒
   间隔数。
 
   如果系统在单个系统时间间隔内请求太多 UUID 而使生成器溢出,则 UUID 服务必须返回
   错误,或使 UUID 生成器停止,直到系统时钟赶上。
 
   高分辨率时间戳可以通过保留具有相同系统时间值生成的 UUID 数的计数,并使用它构造时间戳
   的低阶位来模拟。 计数范围为 0 和每个系统时间间隔的 100 纳秒间隔数。
 
   注意: 如果处理器频繁超过 UUID 生成,则可以向系统分配其他节点标识符,这将允许通过为
   每个时间戳值提供多个 UUID 来实现更高的分配速度。
 
4.2.1.3. 写入稳定存储
 
   每次生成 UUID 时,状态并不总是需要写入稳定存储。 稳定存储中的时间戳可以定期设置为
   大于 UUID 中尚未使用的任何值的值。 只要生成的 UUID 的时间戳小于该值,并且时钟序列
   和节点 ID 保持不变,则只需要更新状态的共享可变副本。 此外,如果稳定存储中的时间戳值
   在将来小于重新启动系统的典型时间,则崩溃不会导致时钟序列的重新初始化。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   




 
4.2.1.4. 跨进程共享状态
 
   如果每次生成 UUID 时访问共享状态的成本太高,则可以实现系统范围的生成器,以在每次调用
   时分配时间戳块;如果每次生成共享状态,则可以实现该开销。每个进程生成器可以从该模块
   分配,直到它耗尽。
 
4.2.2. 生成器详细信息
 
   版本 1 UUID 根据以下算法生成:
 
   o 确定 UUID 中使用的基于 UTC 的时间戳和时钟序列的值,如第 4.2.1 节所述。
 
   o 出于此算法的目的,将时间戳视为 60 位无符号整数,将时钟序列视为 14 位无符号整数。
     按顺序对字段中的位进行编号,以零开头表示最低位。
 
   o 以相同的顺序将 time_low 设置为时间戳的 0 到 31 位。
 
   o 以相同的顺序将 time_mid 字段设置为时间戳 32 到 47 位。
 
   o 以相同的顺序将时间戳中等于位 48 到 59 的 time_hi_and_version 字段的
     12 个位(0到 11)设置为 48 到 59。
 
   o 将 time_hi_and_version 字段的四个版本位(位 12 到 15)设置为与正在创建的
     UUID 版本对应的 4 位版本号,如上表所示。
 
   o 以相同的显著性顺序将 clock_seq_low 字段设置为时钟序列的八个最低显著位
     (0到 7)。

   o 以相同的显著性顺序将 clock_seq_hi_and_reserved 的 0 到 5 设置为时钟序列
     的 8 到 13 。
 
   o 将 clock_seq_hi_and_reserved 的 6 和 7 位分别设置为零和一。
 
   o 以与地址相同的显著性顺序将 node 字段设置为 48 位 IEEE 地址。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   










 
4.3. 创建基于名称的 UUID 的算法
 
   版本 3 或 5 UUID 用于从某些"名称空间"中绘制且唯一的"名称"生成 UUD。 名称和名称
   空间的概念应广义地解释,而不应仅限于文本名称。 例如,某些名称空间是域名系统、URL、
   ISO 对象 ID (OID)、X.500 可分辨名称 (DN) 和编程语言中的保留字。 用于分配名称
   并确保其在其名称空间内的唯一性的机制或约定超出了此规范的范围。
 
   这些类型的 UUD 的要求如下:
 
   o 同一命名空间中同一名称在不同时间生成的 UUID 必须相等。
 
   o 在同一命名空间中由两个不同的名称生成的 UUID 应该不同(概率非常高)。
 
   o 两个不同命名空间中从同一名称生成的 UUID 应该与 (非常高的概率) 不同。
 
   o 如果从名称生成的两个 UUID 相等,则它们从同一命名空间中的同一名称生成(概率非常高)。
 
   从名称和名称空间生成 UUID 的算法如下所示:
 
   o 分配 UUID 以用作从该名称空间中的名称生成的所有 UUID 的"名称空间 ID";有关一些
     预定义的值,请参阅附录 C。
 
   o 选择 MD5 [4] 或 SHA-1 [8] 作为哈希算法;如果向后兼容性不是问题,则首选 SHA-1。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   o 将名称转换为八位字节的规范序列(由其名称空间的标准或约定定义);将名称空间 ID 按
     网络字节顺序排列。
 
   o 计算与名称连接的名称空间 ID 的哈希。
 
   o 将零到 3 的 time_low 设置为哈希的 0 到 3 的八位字节。
 
   o 将八位字节设置为零,并将一个 time_mid field 字段设置为哈希的第 4 和 5 位。
 
   o 将八位字节零和一个 time_hi_and_version 字段设置为哈希的第 6 和 7 位。
 
   o 将 time_hi_and_version 字段的四个位(位 12 到 15)设置为第 4.1.3 节中相应
     的 4 位版本号。
 
   o 将 clock_seq_hi_and_reserved 字段设置为哈希的第 8 位。
 
   o 将 clock_seq_hi_and_reserved 的位(位 6 和 7)分别设置为零和一。
 
   o 将 clock_seq_low 字段设置为哈希的第 9 位。
 
   o 将 node 字段的0-5设置为哈希的 10-15 位。
 
   o 将生成的 UUID 转换为本地字节顺序。




 
4.4. 从真正随机或伪随机数创建 UUID 的算法
 
   版本 4 UUID 用于从真正随机或伪随机数生成 UUD。
 
   算法如下:
 
   o 将 clock_seq_hi_and_reserved 的位 6 和 7 分别设置为零和一。
 
   o 将 time_hi_and_version 的位 12 到 15 设置为第 4.1.3 节中的 4 位版本号。
 
   o 将所有其他位设置为随机(或伪随机)选择的值。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   有关随机数的讨论,请参阅第 4.5 节。
 
4.5. 未认证主机的节点标识
 
   本节介绍,如果 IEEE 802 地址不可用,或者不需要使用,如何生成版本 1 的 UUID。
 
   一种方法是联系 IEEE 并获取单独的地址块。 在撰写本文时,可以在
   <a href="http://standards.ieee.org/regauth/oui/pilot-ind.html">http://standards.ieee.org/regauth/oui/pilot-ind.html</a>找到申请,
   费用为 550 美元。
 
   更好的解决方案是获取 47 位加密质量随机数,并将其用作 node ID 的低 47 位, 
   node ID 的第一个八位字节中最低位设置为 1。 此位是单播/多播位,永远不会在从网卡
   获取的 IEEE 802 地址中设置。 因此,由有网卡和无网卡的计算机生成的 UUID 之间永远
   不会发生冲突。 (回想一下,IEEE 802 规范讨论传输顺序,这与本文档中讨论的内存表示
   相反。
 
   为了与早期规范兼容,请注意,本文档使用单播/多播位,而不是可能更正确的局部/全局位。
 
   有关生成加密质量随机数的建议,请参阅 RFC1750 [5]。
 
   此外,诸如计算机名称和操作系统名称等项目虽然严格地说不是随机的,但将有助于将结果与
   其他系统获得的结果区分开来。
 
   使用这些数据生成节点 ID 的确切算法是特定于系统的,因为可用的数据和获取它们的函数
   通常都是特定于系统的。 但是,一个通用方法是将尽可能多的源累积到缓冲区中,使用消息
   摘要(如 MD5 [4] 或 SHA-1 [8]),从哈希值获取任意的 6 个字节,并设置如上所述的
   多播位。
 









5. 社区考虑
 
   UUID 的使用在计算中极为普遍。 它们构成了许多操作系统(微软 Windows)和应用程序
   (Mozilla 浏览器)的核心标识符基础结构,在许多情况下,它们以许多非标准方式向 
   Web 公开。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   此规范试图尽可能公开地标准化该做法,并尝试以有利于整个 Internet 的方式。
 
6. 安全注意事项
 
   不要假定 UUD 很难猜到;例如,它们不应用作安全功能(仅拥有授予访问权限的标识符)。可
   预测的随机数源将加剧这种情况。
 
   不要假定很容易确定 UUID 是否稍微转置,以便将引用重定向到另一个对象。人类无法简单地
   通过扫视UUID的完整性来轻松检查它的完整性。
 
   在各种主机上生成 UUD 的分布式应用程序必须愿意依赖所有主机的随机数源。如果这不可行,
   则应使用命名空间变体。
 
7.  感谢
 
   本文档大量借鉴了 UUID 的 OSF DCE 规范。  Ted Ts'o 提供了有用的评论,特别是在
   字节排序部分,我们主要从他提供的拟议措辞中借鉴(但是,该部分中的所有错误都是我们的
   责任)。
 
   我们也感谢拉尔夫·恩格尔沙尔、约翰·拉茅斯和保罗·索普的认真阅读和细读。 拉茅斯教授在
   与ISO/IEC的协调方面也是非常宝贵的。
 






8.  参考规范
 
   [1]  Zahn, L., Dineen, T., and P. Leach, "Network Computing        Architecture", ISBN 0-13-611674-4, January 1990.
 
   [2]  "DCE: Remote Procedure Call", Open Group CAE Specification C309,        ISBN 1-85912-041-5, August 1994.
 
   [3]  ISO/IEC 9834-8:2004 Information Technology, "Procedures for the        operation of OSI Registration Authorities: Generation and        registration of Universally Unique Identifiers (UUIDs) and their        use as ASN.1 Object Identifier components" ITU-T Rec. X.667,        2004.
 
   [4]  Rivest, R., "The MD5 Message-Digest Algorithm ", RFC 1321, April        1992.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [5]  Eastlake, D., 3rd, Schiller, J., and S. Crocker, "Randomness        Requirements for Security", BCP 106, RFC 4086, June 2005.
 
   [6]  Moats, R., "URN Syntax", RFC 2141, May 1997.
 
   [7]  Crocker, D. and P. Overell, "Augmented BNF for Syntax        Specifications: ABNF", RFC 2234, November 1997.
 
   [8]  National Institute of Standards and Technology, "Secure Hash        Standard", FIPS PUB 180-1, April 1995,
        <http: www.itl.nist.gov="" fipspubs="" fip180-1.htm="">.</http:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
附录 A.  附录 A - 示例实现
 
   此实现由 5 个文件组成:uuid.h、uuid.c、sysdep.h、sysdep.c 和 utest.c。
   uuid.* 文件是上述 UUID 生成算法的系统独立实现,除跨进程的有效状态共享外,上述所有
   优化除外。 该代码已在 Linux (红帽 4.0) 上测试,其 GCC (2.7.2) 和 Windows NT
   4.0 和 VC++ 5.0。  该代码假定 64 位整数支持,这使得它更加清晰。
 
   以下所有源文件都应包含以下版权声明:
 
copyrt.h
 
/*
** Copyright (c) 1990- 1993, 1996 Open Software Foundation, Inc.
** Copyright (c) 1989 by Hewlett-Packard Company, Palo Alto, Ca. &amp;
** Digital Equipment Corporation, Maynard, Mass.
** Copyright (c) 1998 Microsoft.
** To anyone who acknowledges that this file is provided "AS IS"
** without any express or implied warranty: permission to use, copy,
** modify, and distribute this file for any purpose is hereby
** granted without fee, provided that the above copyright notices and
** this notice appears in all source code copies, and that none of
** the names of Open Software Foundation, Inc., Hewlett-Packard
** Company, Microsoft, or Digital Equipment Corporation be used in
** advertising or publicity pertaining to distribution of the software
** without specific, written prior permission. Neither Open Software
** Foundation, Inc., Hewlett-Packard Company, Microsoft, nor Digital
** Equipment Corporation makes any representations about the
** suitability of this software for any purpose.
*/
 

uuid.h
 
#include "copyrt.h"
#undef uuid_t
typedef struct {
    unsigned32  time_low;
    unsigned16  time_mid;
    unsigned16  time_hi_and_version;
    unsigned8   clock_seq_hi_and_reserved;
    unsigned8   clock_seq_low;
    byte        node[6];
} uuid_t;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
/* uuid_create -- generate a UUID */
int uuid_create(uuid_t * uuid);
 
/* uuid_create_md5_from_name -- create a version 3 (MD5) UUID using a
   "name" from a "name space" */
void uuid_create_md5_from_name(
    uuid_t *uuid,         /* resulting UUID */
    uuid_t nsid,          /* UUID of the namespace */
    void *name,           /* the name from which to generate a UUID */
    int namelen           /* the length of the name */
);
 
/* uuid_create_sha1_from_name -- create a version 5 (SHA-1) UUID
   using a "name" from a "name space" */
void uuid_create_sha1_from_name(
 
    uuid_t *uuid,         /* resulting UUID */
    uuid_t nsid,          /* UUID of the namespace */
    void *name,           /* the name from which to generate a UUID */
    int namelen           /* the length of the name */
);
 
/* uuid_compare --  Compare two UUID's "lexically" and return
        -1   u1 is lexically before u2
         0   u1 is equal to u2
         1   u1 is lexically after u2
   Note that lexical ordering is not temporal ordering!
*/
int uuid_compare(uuid_t *u1, uuid_t *u2);
 

uuid.c
 
#include "copyrt.h"
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include "sysdep.h"
#include "uuid.h"
 
/* various forward declarations */
static int read_state(unsigned16 *clockseq, uuid_time_t *timestamp,
    uuid_node_t *node);
static void write_state(unsigned16 clockseq, uuid_time_t timestamp,
    uuid_node_t node);
static void format_uuid_v1(uuid_t *uuid, unsigned16 clockseq,
    uuid_time_t timestamp, uuid_node_t node);</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
static void format_uuid_v3or5(uuid_t *uuid, unsigned char hash[16],
    int v);
static void get_current_time(uuid_time_t *timestamp);
static unsigned16 true_random(void);
 
/* uuid_create -- generator a UUID */
int uuid_create(uuid_t *uuid)
{
     uuid_time_t timestamp, last_time;
     unsigned16 clockseq;
     uuid_node_t node;
     uuid_node_t last_node;
     int f;
 
     /* acquire system-wide lock so we're alone */
     LOCK;
     /* get time, node ID, saved state from non-volatile storage */
     get_current_time(&amp;timestamp);
     get_ieee_node_identifier(&amp;node);
     f = read_state(&amp;clockseq, &amp;last_time, &amp;last_node);
 
     /* if no NV state, or if clock went backwards, or node ID        changed (e.g., new network card) change clockseq */
     if (!f || memcmp(&amp;node, &amp;last_node, sizeof node))
         clockseq = true_random();
     else if (timestamp &lt; last_time)
         clockseq++;
 
     /* save the state for next time */
     write_state(clockseq, timestamp, node);
 
     UNLOCK;
 
     /* stuff fields into the UUID */
     format_uuid_v1(uuid, clockseq, timestamp, node);     return 1;
}
 
/* format_uuid_v1 -- make a UUID from the timestamp, clockseq,
                     and node ID */
void format_uuid_v1(uuid_t* uuid, unsigned16 clock_seq,
                    uuid_time_t timestamp, uuid_node_t node)
{
    /* Construct a version 1 uuid with the information we've gathered
       plus a few constants. */
    uuid-&gt;time_low = (unsigned long)(timestamp &amp; 0xFFFFFFFF);
    uuid-&gt;time_mid = (unsigned short)((timestamp &gt;&gt; 32) &amp; 0xFFFF);
    uuid-&gt;time_hi_and_version =</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
        (unsigned short)((timestamp &gt;&gt; 48) &amp; 0x0FFF);
    uuid-&gt;time_hi_and_version |= (1 &lt;&lt; 12);
    uuid-&gt;clock_seq_low = clock_seq &amp; 0xFF;
    uuid-&gt;clock_seq_hi_and_reserved = (clock_seq &amp; 0x3F00) &gt;&gt; 8;
    uuid-&gt;clock_seq_hi_and_reserved |= 0x80;
    memcpy(&amp;uuid-&gt;node, &amp;node, sizeof uuid-&gt;node);
}
 
/* data type for UUID generator persistent state */
typedef struct {
    uuid_time_t  ts;       /* saved timestamp */
    uuid_node_t  node;     /* saved node ID */
    unsigned16   cs;       /* saved clock sequence */
} uuid_state;
 
static uuid_state st;
 
/* read_state -- read UUID generator state from non-volatile store */
int read_state(unsigned16 *clockseq, uuid_time_t *timestamp,
               uuid_node_t *node)
{
    static int inited = 0;
    FILE *fp;
 
    /* only need to read state once per boot */
    if (!inited) {
        fp = fopen("state", "rb");
        if (fp == NULL)
            return 0;
        fread(&amp;st, sizeof st, 1, fp);
        fclose(fp);
        inited = 1;
    }
    *clockseq = st.cs;
    *timestamp = st.ts;
    *node = st.node;
    return 1;
}
 
/* write_state -- save UUID generator state back to non-volatile
   storage */
void write_state(unsigned16 clockseq, uuid_time_t timestamp,
                 uuid_node_t node)
{
    static int inited = 0;
    static uuid_time_t next_save;
    FILE* fp;</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
    if (!inited) {
        next_save = timestamp;
        inited = 1;
    }
 
    /* always save state to volatile shared state */
    st.cs = clockseq;
    st.ts = timestamp;
    st.node = node;
    if (timestamp &gt;= next_save) {
        fp = fopen("state", "wb");
        fwrite(&amp;st, sizeof st, 1, fp);
        fclose(fp);
        /* schedule next save for 10 seconds from now */
        next_save = timestamp + (10 * 10 * 1000 * 1000);
    }
}
 
/* get-current_time -- get time as 60-bit 100ns ticks since UUID epoch.
   Compensate for the fact that real clock resolution is
   less than 100ns. */
void get_current_time(uuid_time_t *timestamp)
{
    static int inited = 0;
    static uuid_time_t time_last;
    static unsigned16 uuids_this_tick;
    uuid_time_t time_now;
 
    if (!inited) {
        get_system_time(&amp;time_now);
        uuids_this_tick = UUIDS_PER_TICK;
        inited = 1;
    }
 
    for ( ; ; ) {
        get_system_time(&amp;time_now);
 
        /* if clock reading changed since last UUID generated, */
        if (time_last != time_now) {
            /* reset count of uuids gen'd with this clock reading */
            uuids_this_tick = 0;
            time_last = time_now;
            break;
        }
        if (uuids_this_tick &lt; UUIDS_PER_TICK) {
            uuids_this_tick++;
            break;
        }</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
        /* going too fast for our clock; spin */
    }
    /* add the count of uuids to low order bits of the clock reading */
    *timestamp = time_now + uuids_this_tick;
}
 
/* true_random -- generate a crypto-quality random number.
   **This sample doesn't do that.** */
static unsigned16 true_random(void)
{
    static int inited = 0;
    uuid_time_t time_now;
 
    if (!inited) {
        get_system_time(&amp;time_now);
        time_now = time_now / UUIDS_PER_TICK;
        srand((unsigned int)
               (((time_now &gt;&gt; 32) ^ time_now) &amp; 0xffffffff));
        inited = 1;
    }
 
    return rand();
}
 
/* uuid_create_md5_from_name -- create a version 3 (MD5) UUID using a
   "name" from a "name space" */
void uuid_create_md5_from_name(uuid_t *uuid, uuid_t nsid, void *name,
                               int namelen)
{
    MD5_CTX c;
    unsigned char hash[16];
    uuid_t net_nsid;
 
    /* put name space ID in network byte order so it hashes the same
       no matter what endian machine we're on */
    net_nsid = nsid;
    net_nsid.time_low = htonl(net_nsid.time_low);
    net_nsid.time_mid = htons(net_nsid.time_mid);
    net_nsid.time_hi_and_version = htons(net_nsid.time_hi_and_version);
 
    MD5Init(&amp;c);
    MD5Update(&amp;c, &amp;net_nsid, sizeof net_nsid);
    MD5Update(&amp;c, name, namelen);
    MD5Final(hash, &amp;c);
 
    /* the hash is in network byte order at this point */
    format_uuid_v3or5(uuid, hash, 3);
}</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
void uuid_create_sha1_from_name(uuid_t *uuid, uuid_t nsid, void *name,
                                int namelen)
{
    SHA_CTX c;
    unsigned char hash[20];
    uuid_t net_nsid;
 
    /* put name space ID in network byte order so it hashes the same
       no matter what endian machine we're on */
    net_nsid = nsid;
    net_nsid.time_low = htonl(net_nsid.time_low);
    net_nsid.time_mid = htons(net_nsid.time_mid);
    net_nsid.time_hi_and_version = htons(net_nsid.time_hi_and_version);
 
    SHA1_Init(&amp;c);
    SHA1_Update(&amp;c, &amp;net_nsid, sizeof net_nsid);
    SHA1_Update(&amp;c, name, namelen);
    SHA1_Final(hash, &amp;c);
 
    /* the hash is in network byte order at this point */
    format_uuid_v3or5(uuid, hash, 5);
}
 
/* format_uuid_v3or5 -- make a UUID from a (pseudo)random 128-bit
   number */
void format_uuid_v3or5(uuid_t *uuid, unsigned char hash[16], int v)
{
    /* convert UUID to local byte order */
    memcpy(uuid, hash, sizeof *uuid);
    uuid-&gt;time_low = ntohl(uuid-&gt;time_low);
    uuid-&gt;time_mid = ntohs(uuid-&gt;time_mid);
    uuid-&gt;time_hi_and_version = ntohs(uuid-&gt;time_hi_and_version);
 
    /* put in the variant and version bits */
    uuid-&gt;time_hi_and_version &amp;= 0x0FFF;
    uuid-&gt;time_hi_and_version |= (v &lt;&lt; 12);
    uuid-&gt;clock_seq_hi_and_reserved &amp;= 0x3F;
    uuid-&gt;clock_seq_hi_and_reserved |= 0x80;
}
 
/* uuid_compare --  Compare two UUID's "lexically" and return */
#define CHECK(f1, f2) if (f1 != f2) return f1 &lt; f2 ? -1 : 1;
int uuid_compare(uuid_t *u1, uuid_t *u2)
{
    int i;
 
    CHECK(u1-&gt;time_low, u2-&gt;time_low);
    CHECK(u1-&gt;time_mid, u2-&gt;time_mid);</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
    CHECK(u1-&gt;time_hi_and_version, u2-&gt;time_hi_and_version);
    CHECK(u1-&gt;clock_seq_hi_and_reserved, u2-&gt;clock_seq_hi_and_reserved);
    CHECK(u1-&gt;clock_seq_low, u2-&gt;clock_seq_low)
    for (i = 0; i &lt; 6; i++) {
        if (u1-&gt;node[i] &lt; u2-&gt;node[i])
            return -1;
        if (u1-&gt;node[i] &gt; u2-&gt;node[i])
            return 1;
    }
    return 0;
}
#undef CHECK
 

sysdep.h
 
#include "copyrt.h"
/* remove the following define if you aren't running WIN32 */
#define WININC 0
 
#ifdef WININC
#include &lt;windows.h&gt;
#else
#include &lt;sys types.h=""&gt;
#include &lt;sys time.h=""&gt;
#include &lt;sys sysinfo.h=""&gt;
#endif
 
#include "global.h"
/* change to point to where MD5 .h's live; RFC 1321 has sample
   implementation */
#include "md5.h"
 
/* set the following to the number of 100ns ticks of the actual
   resolution of your system's clock */
#define UUIDS_PER_TICK 1024
 
/* Set the following to a calls to get and release a global lock */
#define LOCK
#define UNLOCK
 
typedef unsigned long   unsigned32;
typedef unsigned short  unsigned16;
typedef unsigned char   unsigned8;
typedef unsigned char   byte;
 
/* Set this to what your compiler uses for 64-bit data type */
#ifdef WININC</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
#define unsigned64_t unsigned __int64
#define I64(C) C
#else
#define unsigned64_t unsigned long long
#define I64(C) C##LL
#endif
 
typedef unsigned64_t uuid_time_t;
typedef struct {
    char nodeID[6];
} uuid_node_t;
 
void get_ieee_node_identifier(uuid_node_t *node);
void get_system_time(uuid_time_t *uuid_time);
void get_random_info(char seed[16]);
 

sysdep.c
 
#include "copyrt.h"
#include &lt;stdio.h&gt;
#include "sysdep.h"
 
/* system dependent call to get IEEE node ID.
   This sample implementation generates a random node ID. */
void get_ieee_node_identifier(uuid_node_t *node)
{
    static inited = 0;
    static uuid_node_t saved_node;
    char seed[16];
    FILE *fp;
 
    if (!inited) {
        fp = fopen("nodeid", "rb");
        if (fp) {
            fread(&amp;saved_node, sizeof saved_node, 1, fp);
            fclose(fp);
        }
        else {
            get_random_info(seed);
            seed[0] |= 0x01;
            memcpy(&amp;saved_node, seed, sizeof saved_node);
            fp = fopen("nodeid", "wb");
            if (fp) {
                fwrite(&amp;saved_node, sizeof saved_node, 1, fp);
                fclose(fp);
            }
        }</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
        inited = 1;
    }
 
    *node = saved_node;
}
 
/* system dependent call to get the current system time. Returned as
   100ns ticks since UUID epoch, but resolution may be less than
   100ns. */
#ifdef _WINDOWS_
 
void get_system_time(uuid_time_t *uuid_time)
{
    ULARGE_INTEGER time;
 
    /* NT keeps time in FILETIME format which is 100ns ticks since
       Jan 1, 1601. UUIDs use time in 100ns ticks since Oct 15, 1582.
       The difference is 17 Days in Oct + 30 (Nov) + 31 (Dec)
       + 18 years and 5 leap days. */
    GetSystemTimeAsFileTime((FILETIME *)&amp;time);
    time.QuadPart +=
 
          (unsigned __int64) (1000*1000*10)       // seconds
        * (unsigned __int64) (60 * 60 * 24)       // days
        * (unsigned __int64) (17+30+31+365*18+5); // # of days
    *uuid_time = time.QuadPart;
}
 
/* Sample code, not for use in production; see RFC 1750 */
void get_random_info(char seed[16])
{
    MD5_CTX c;
    struct {
        MEMORYSTATUS m;
        SYSTEM_INFO s;
        FILETIME t;
        LARGE_INTEGER pc;
        DWORD tc;
        DWORD l;
        char hostname[MAX_COMPUTERNAME_LENGTH + 1];
    } r;
 
    MD5Init(&amp;c);
    GlobalMemoryStatus(&amp;r.m);
    GetSystemInfo(&amp;r.s);
    GetSystemTimeAsFileTime(&amp;r.t);
    QueryPerformanceCounter(&amp;r.pc);
    r.tc = GetTickCount();</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
    r.l = MAX_COMPUTERNAME_LENGTH + 1;
    GetComputerName(r.hostname, &amp;r.l);
    MD5Update(&amp;c, &amp;r, sizeof r);
    MD5Final(seed, &amp;c);
}
 
#else
 
void get_system_time(uuid_time_t *uuid_time)
{
    struct timeval tp;
 
    gettimeofday(&amp;tp, (struct timezone *)0);
 
    /* Offset between UUID formatted times and Unix formatted times.
       UUID UTC base time is October 15, 1582.
       Unix base time is January 1, 1970.*/
    *uuid_time = ((unsigned64)tp.tv_sec * 10000000)
        + ((unsigned64)tp.tv_usec * 10)
        + I64(0x01B21DD213814000);
}
 
/* Sample code, not for use in production; see RFC 1750 */
void get_random_info(char seed[16])
{
    MD5_CTX c;
    struct {
        struct sysinfo s;
        struct timeval t;
        char hostname[257];
    } r;
 
    MD5Init(&amp;c);
    sysinfo(&amp;r.s);
    gettimeofday(&amp;r.t, (struct timezone *)0);
    gethostname(r.hostname, 256);
    MD5Update(&amp;c, &amp;r, sizeof r);
    MD5Final(seed, &amp;c);
}
 
#endif
 
utest.c
 
#include "copyrt.h"
#include "sysdep.h"
#include &lt;stdio.h&gt;
#include "uuid.h"</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
uuid_t NameSpace_DNS = { /* 6ba7b810-9dad-11d1-80b4-00c04fd430c8 */
    0x6ba7b810,
    0x9dad,
    0x11d1,
    0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8
};
 
/* puid -- print a UUID */
void puid(uuid_t u)
{
    int i;
 
    printf("%8.8x-%4.4x-%4.4x-%2.2x%2.2x-", u.time_low, u.time_mid,
    u.time_hi_and_version, u.clock_seq_hi_and_reserved,
    u.clock_seq_low);
    for (i = 0; i &lt; 6; i++)
        printf("%2.2x", u.node[i]);
    printf("\n");
}
 
/* Simple driver for UUID generator */
void main(int argc, char **argv)
{
    uuid_t u;
    int f;
 
    uuid_create(&amp;u);
    printf("uuid_create(): "); puid(u);
 
    f = uuid_compare(&amp;u, &amp;u);
    printf("uuid_compare(u,u): %d\n", f);     /* should be 0 */
    f = uuid_compare(&amp;u, &amp;NameSpace_DNS);
    printf("uuid_compare(u, NameSpace_DNS): %d\n", f); /* s.b. 1 */
    f = uuid_compare(&amp;NameSpace_DNS, &amp;u);
    printf("uuid_compare(NameSpace_DNS, u): %d\n", f); /* s.b. -1 */
    uuid_create_md5_from_name(&amp;u, NameSpace_DNS, "www.widgets.com", 15);
    printf("uuid_create_md5_from_name(): "); puid(u);}
 
Appendix B.  Appendix B - Sample Output of utest
 
     uuid_create(): 7d444840-9dc0-11d1-b245-5ffdce74fad2
     uuid_compare(u,u): 0
     uuid_compare(u, NameSpace_DNS): 1
     uuid_compare(NameSpace_DNS, u): -1
     uuid_create_md5_from_name(): e902893a-9d22-3c7e-a7b8-d6e313b71d9f</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
Appendix C.  Appendix C - Some Name Space IDs
 
   本附录列出了某些可能感兴趣的名称空间的名称空间 D,如初始化的 C 结构和上面定义的
   字符串表示形式。
 
   /* Name string is a fully-qualified domain name */
   uuid_t NameSpace_DNS = { /* 6ba7b810-9dad-11d1-80b4-00c04fd430c8 */
       0x6ba7b810,
       0x9dad,
       0x11d1,
       0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8
   };
 
   /* Name string is a URL */
   uuid_t NameSpace_URL = { /* 6ba7b811-9dad-11d1-80b4-00c04fd430c8 */
       0x6ba7b811,
       0x9dad,
       0x11d1,
       0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8
   };
 
   /* Name string is an ISO OID */
   uuid_t NameSpace_OID = { /* 6ba7b812-9dad-11d1-80b4-00c04fd430c8 */
       0x6ba7b812,
       0x9dad,
       0x11d1,
       0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8
   };
 
   /* Name string is an X.500 DN (in DER or a text output format) */
   uuid_t NameSpace_X500 = { /* 6ba7b814-9dad-11d1-80b4-00c04fd430c8 */
       0x6ba7b814,
       0x9dad,
       0x11d1,
       0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8
   };</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
Authors' Addresses
 
   Paul J. Leach
   Microsoft
   1 Microsoft Way
   Redmond, WA  98052
   US
 
   Phone: +1 425-882-8080
   EMail: paulle@microsoft.com
 

   Michael Mealling
   Refactored Networks, LLC
   1635 Old Hwy 41
   Suite 112, Box 138
   Kennesaw, GA 30152
   US
 
   Phone: +1-678-581-9656
   EMail: michael@refactored-networks.com
   URI: http://www.refactored-networks.com
 

   Rich Salz
   DataPower Technology, Inc.
   1 Alewife Center
   Cambridge, MA  02142
   US
 
   Phone: +1 617-864-0455
   EMail: rsalz@datapower.com
   URI:   http://www.datapower.com</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
完整版权声明
 
   Copyright (C) The Internet Society (2005).
 
   This document is subject to the rights, licenses and restrictions   contained in BCP 78, and except as set forth therein, the authors   retain all their rights.
 
   This document and the information contained herein are provided on an   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
 
知识产权
 
   The IETF takes no position regarding the validity or scope of any   Intellectual Property Rights or other rights that might be claimed to   pertain to the implementation or use of the technology described in   this document or the extent to which any license under such rights   might or might not be available; nor does it represent that it has   made any independent effort to identify any such rights.  Information   on the procedures with respect to rights in RFC documents can be   found in BCP 78 and BCP 79.
 
   Copies of IPR disclosures made to the IETF Secretariat and any   assurances of licenses to be made available, or the result of an   attempt made to obtain a general license or permission for the use of   such proprietary rights by implementers or users of this   specification can be obtained from the IETF on-line IPR repository at   http://www.ietf.org/ipr.
 
   The IETF invites any interested party to bring to its attention any   copyrights, patents or patent applications, or other proprietary   rights that may cover technology that may be required to implement   this standard.  Please address the information to the IETF at ietf-   ipr@ietf.org.
 
Acknowledgement
 
   Funding for the RFC Editor function is currently provided by the   Internet Society.
 

 

 

 
Leach, et al.               Standards Track                    [Page 32]</pre><br>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.129c, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>
