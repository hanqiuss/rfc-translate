<div class="content" style="float: left; margin: 0px 30%; width: 579px; font-size: 10pt;">
   <div style="height: 13px;">
      <div onmouseover="this.style.cursor='pointer';" onclick="showElem('legend');" onmouseout="hideElem('legend')" style="height: 6px; position: absolute; cursor: pointer;" class="pre noprint docinfo bgorange" title="Click for colour legend.">                                                                        </div>
      <div id="legend" class="docinfo noprint pre legend" style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; " onmouseover="showElem('legend');" onmouseout="hideElem('legend');">
      </div>
   </div>
<span class="pre noprint docinfo top">[<a href="../html/" title="Document search and retrieval page">Docs</a>] [<a href="/rfc/rfc6819.txt" title="Plaintext version of this document">txt</a>|<a href="/pdf/rfc6819" title="PDF version of this document">pdf</a>] [<a href="./draft-ietf-oauth-v2-threatmodel" title="draft-ietf-oauth-v2-threatmodel">draft-ietf-oaut...</a>] [<a href="https://datatracker.ietf.org/doc/rfc6819" title="IESG Datatracker information for this document">Tracker</a>] [<a href="/rfcdiff?difftype=--hwdiff&amp;url2=rfc6819" title="Inline diff (wdiff)">Diff1</a>] [<a href="/rfcdiff?url2=rfc6819" title="Side-by-side diff">Diff2</a>] [<a href="https://www.rfc-editor.org/errata_search.php?rfc=6819">Errata</a>]</span><br>
<span class="pre noprint docinfo">                                                                        </span><br>
<span class="pre noprint docinfo">                                                           INFORMATIONAL</span><br>
<span class="pre noprint docinfo">                                                            <span style="color: #C00;">Errata Exist</span></span><br>
<pre style="height: 780px; white-space: pre-wrap;">Internet Engineering Task Force (IETF)               T. Lodderstedt, Ed.
Request for Comments: 6819                           Deutsche Telekom AG
Category: Informational                                       M. McGloin
ISSN: 2070-1721                                                      IBM
                                                                 P. Hunt
                                                      Oracle Corporation
                                                            January 2013
 

                      OAuth 2.0 威胁模型和安全注意事项
 
摘要
 
   本文档基于 OAuth 2.0 协议的全面威胁模型,为 OAuth 提供了除 OAuth 2.0 规范
   之外的其他安全注意事项。
 
本备忘录的状态
 
   本文档不是互联网标准跟踪规范;发布这些信息是为了提供信息。
 
   本文档是互联网工程任务组 (IETF) 的产品。 它代表了IETF社区的共识。 它已接受公众
   审查,并经互联网工程指导小组批准出版。 并非所有由 IESG 批准的文件都是任何级别的
   互联网标准的候选人;请参阅 RFC 5741 第 2 节。
 
   有关本文档的当前状态、任何勘误表以及如何提供有关文档的反馈的信息,请查阅以下信息:
   http://www.rfc-editor.org/info/rfc6819.
 
Copyright Notice
 
   Copyright (c) 2013 IETF Trust and the persons identified as the   document authors.  All rights reserved.
 
   This document is subject to BCP 78 and the IETF Trust's Legal   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of   publication of this document.  Please review these documents   carefully, as they describe your rights and restrictions with respect   to this document.  Code Components extracted from this document must   include Simplified BSD License text as described in Section 4.e of   the Trust Legal Provisions and are provided without warranty as   described in the Simplified BSD License.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
目录
 <pre style="font-family: 新宋体;">   1. 介绍 ............................................................6
   2. 概述 ............................................................7
      2.1. 范围 .......................................................7
      2.2. 攻击假设 ...................................................7
      2.3. 架构假设  ..................................................8
           2.3.1. 授权服务器 ..........................................8
           2.3.2. 资源服务器 ..........................................9
           2.3.3. 客户端...............................................9
   3. 安全特性          ...............................................9
      3.1. 令牌   ....................................................10
           3.1.1. 范围  ..............................................11
           3.1.2. 受限访问令牌生存期            ......................11
      3.2. 访问令牌     ..............................................11
      3.3. 刷新令牌      .............................................11
      3.4. 授权 "code"          ......................................12
      3.5. 重定向 URI   ..............................................13
      3.6. "state" 参数      .........................................13
      3.7. 客户端标识符      .........................................13
   4. 威胁模型     ...................................................15
      4.1. 客户端  ...................................................16
           4.1.1. 威胁:获取客户端密码              ...................16
           4.1.2. 威胁:获取刷新令牌                ...................17
           4.1.3. 威胁:获取访问令牌               ....................19
           4.1.4. 威胁:使用受攻击或嵌入式浏览器仿冒最终用户凭据 ......19
           4.1.5. 威胁:在客户端上打开重定向 ..........................20
      4.2. 授权节点 ............. ....................................21
           4.2.1. 威胁:伪造授权服务器的密码网络钓鱼 ..................21
           4.2.2. 威胁:用户无意中授予了过多的访问范围.................21
           4.2.3. 威胁:恶意客户端通过欺诈获得现有授权.................22
           4.2.4. 威胁:开放式重定向 ..................................22
      4.3. 令牌节点 ..................................................23
           4.3.1. 威胁:窃听访问令牌 ..................................23
           4.3.2. 威胁:从授权服务器数据库获取访问令牌.................23
           4.3.3. 威胁:传输过程中客户端凭据的泄露.....................23
           4.3.4. 威胁:从授权服务器数据库获取客户端密钥...............24
           4.3.5. 威胁:通过在线猜测获取客户端密码.....................24

</pre></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

  <pre style="font-family: 新宋体;">      4.4. 获得授权                ...................................25
           4.4.1. 授权 "code"          ...............................25
                  4.4.1.1. 威胁:窃听或泄漏授权"codes".................25
                  4.4.1.2. 威胁:从授权服务器数据库获取授权"codes" ....26
                  4.4.1.3. 威胁:在线猜测授权"codes" ..................27
                  4.4.1.4. 威胁:恶意客户端获得授权 ...................27
                  4.4.1.5. 威胁:授权"codes"网络钓鱼 ..................29
                  4.4.1.6. 威胁:用户会话模拟 .........................29
                  4.4.1.7. 威胁:授权"codes"通过假冒客户端泄漏.........30
                  4.4.1.8. 威胁:CSRF uri重定向攻击  ..................32
                  4.4.1.9. 威胁:点击对授权的攻击   ...................33
                  4.4.1.10. 威胁:资源所有者模拟                  .....33
                  4.4.1.11. 威胁:消耗资源的 DoS 攻击     .............34
                  4.4.1.12. 威胁:使用制造授权"codes"的 DoS............35
                  4.4.1.13. 威胁:代码替换(OAuth 登录)       ..........36
           4.4.2. 隐式授权 ...........................................37
                  4.4.2.1. 威胁:传输/端点中的访问令牌泄漏.............37
                  4.4.2.2. 威胁:浏览器历史记录中的访问令牌泄漏........38
                  4.4.2.3. 威胁:恶意客户端获得授权      ..............38
                  4.4.2.4. 威胁:脚本操作                   ...........38
                  4.4.2.5. 威胁:CSRF uri重定向攻击 ...................39
                  4.4.2.6. 威胁:令牌替换(OAuth 登录) .................39
           4.4.3. 资源所有者密码凭据 .................................40
                  4.4.3.1. 威胁:在客户端意外泄露密码 0................41
                  4.4.3.2. 威胁:客户端在没有最终用户授权的情况下获取
                           作用域 ....................................42
                  4.4.3.3. 威胁:客户端通过自动授权获取刷新令牌   .....42
                  4.4.3.4. 威胁:在运输层上获取用户密码................43
                  4.4.3.5. 威胁:从授权服务器数据库获取用户密码 .......43
                  4.4.3.6. 威胁:在线猜测           ...................43
           4.4.4. 客户端凭据         .................................44

</pre></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

  <pre style="font-family: 新宋体;">      4.5. 刷新访问令牌               ................................44
           4.5.1. 威胁:从授权服务器窃听刷新令牌.......................44
           4.5.2. 威胁:从授权服务器数据库获取刷新令牌.................44
           4.5.3. 威胁:通过在线猜测获取刷新令牌.......................45
           4.5.4. 威胁:通过伪造授权服务器刷新令牌网络钓鱼.............45
      4.6. 访问受保护的资源              .............................46
           4.6.1. 威胁:在传输上窃听访问令牌                        ...46
           4.6.2. 威胁:授权资源服务器请求的重播    ...................46
           4.6.3. 威胁:猜测访问令牌              .....................46
           4.6.4. 威胁:假冒资源服务器访问令牌网络钓鱼.................47
           4.6.5. 威胁:合法资源服务器或客户端滥用令牌  ...............48
           4.6.6. 威胁:HTTP 代理中机密数据泄露                      ..48
           4.6.7. 威胁:通过日志文件和 HTTP 引用器的令牌泄漏...........48
   5. 安全注意事项            ........................................49
      5.1. 一般    ...................................................49
           5.1.1. 确保请求的机密性                   .................49
           5.1.2. 利用服务器身份验证            ......................50
           5.1.3. 始终通知资源所有者                      ............50
           5.1.4. 凭据        ........................................51
                  5.1.4.1. 实施凭据存储保护最佳实践  .................51
                  5.1.4.2. 对密钥的在线攻击          .................52
           5.1.5. 令牌(访问、刷新、code)         .....................53
                  5.1.5.1. 限制令牌范围      .........................53
                  5.1.5.2. 确定过期时间              .................54
                  5.1.5.3. 使用较短的过期时间        .................54
                  5.1.5.4. 限制使用量或一次性使用数                 ..55
                  5.1.5.5. 将令牌绑定到特定资源服务器(用户)  .........55
                  5.1.5.6. 使用端点地址作为令牌受众               ....56
                  5.1.5.7. 对受众和令牌使用显式定义的作用域 ..........56
                  5.1.5.8. 将令牌绑定到客户端 ID   ...................56
                  5.1.5.9. 签名自包含令牌             ................56
                  5.1.5.10. 加密令牌内容          ....................56
                  5.1.5.11. 采用标准断言格式                  ........57
           5.1.6. 访问令牌      ......................................57
</pre></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 
 <pre style="font-family: 新宋体;"> 
      5.2. 授权服务器           ......................................57
           5.2.1. 授权"codes" ........................................57
                  5.2.1.1. 如果检测到滥用,则自动吊销派生令牌..........57
           5.2.2. 刷新令牌       .....................................57
                  5.2.2.1. 限制发行刷新令牌                      .....57
                  5.2.2.2. 将刷新令牌绑定到 "client_id"            ...58
                  5.2.2.3. 刷新令牌旋转           ....................58
                  5.2.2.4. 撤销刷新令牌                 ..............58
                  5.2.2.5. 设备标识              .....................59
                  5.2.2.6. X-FRAME-OPTIONS Header ....................59
           5.2.3. 客户端身份验证和授权 ............59
                  5.2.3.1. 不要向具有不当安全策略的客户发布密钥.......60
                  5.2.3.2. 要求无秘密的公共客户端的用户同意...........60
                  5.2.3.3. 发出"client_id"仅与"redirect_uri"的组合 ...61
                  5.2.3.4. 发布特定于安装的客户端密钥.................61
                  5.2.3.5. 验证预注册 "redirect_uri"              ....62
                  5.2.3.6. 撤销客户密钥          .....................63
                  5.2.3.7. 使用强客户端身份验证(例如,客户端断言/
                           客户端令牌) ...............................63
           5.2.4. End-User Authorization .............................63
                  5.2.4.1. 重复授权的自动处理需要客户端验证 ..........63
                  5.2.4.2. 基于透明度的知情决定 ......................63
                  5.2.4.3. 最终用户对客户端属性的验证...... ..........64
                  5.2.4.4. Authorization "code"绑定"client_id" .......64
                  5.2.4.5. Authorization "code" 绑定 "redirect_uri" ..64
      5.3. 客户端应用程序安全性.......................................65
           5.3.1. 不要将凭据存储在与软件包捆绑的代码或资源中 .........65
           5.3.2. 使用标准 Web 服务器保护措施(用于配置文件和数据库)...65
           5.3.3. 将密钥存储到安全存储中          ....................65
           5.3.4. 利用设备锁定防止未经授权的设备访问  ................66
           5.3.5. "state" 参数链接到用户代理会话                   ...66
      5.4. 资源服务器 ..........................................66
           5.4.1. Authorization Headers ..............................66
           5.4.2. Authenticated Requests .............................67
           5.4.3. Signed Requests ....................................67
      5.5. A Word on User Interaction and User-Installed Apps ........68


</pre></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   6. Acknowledgements ...............................................69
   7. References .....................................................69
      7.1. Normative References ......................................69
      7.2. Informative References ....................................69
 
1.  简介
 
   本文档基于 OAuth 2.0 协议 [RFC6749] 的全面威胁模型,为 OAuth 提供了除 
   OAuth 规范之外的其他安全注意事项。 它包含以下内容:
 
   o  记录创建威胁模型时考虑的任何假设和范围。
 
   o  描述 OAuth 协议中内置的安全功能,以及这些功能如何阻止攻击。
 
   o  为 OAuth 提供一个全面的威胁模型,并描述了相应的对策来挫败这些威胁。
 
   威胁包括对 OAuth 令牌和受 OAuth 令牌保护的资源的任何故意攻击,以及如果不实施
   适当的安全措施,将引入安全风险。 威胁的结构是按协议结构构建的,以帮助开发团队安全
   地实施协议的每个部分,例如,授予访问权限的所有威胁,或特定授予类型的所有威胁,或用于
   保护资源服务器。
 
   注意:本文档无法评估与特定威胁相关的概率或风险,因为这些方面在很大程度上取决于使用
   特定应用程序和部署 OAuth 进行保护。 同样,在相当抽象的层面上也给出了影响。但此处
   提供的信息可能作为特定于部署的威胁模型的基础。实施者可以细化和详细说明抽象威胁
   模型,以便考虑其部署的特定属性并得出风险分析。由于本文档基于 OAuth 2.0基础规范,
   因此不考虑建议的扩展,如客户端注册或发现,其中许多扩展仍在讨论之中。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
2.  概述
 
2.1.  范围
 
   此安全注意事项文档仅考虑受 [RFC6749] 支持的绑定到特定部署的客户端。 此类部署
   具有以下特征:
 
   o  资源服务器 URL 是静态的,在开发时确定;授权服务器 URL 可以是静态的,也
      可以是已发现的。
 
   o  令牌范围值(例如,适用的 URL 和方法)在开发时是确定的。
 
   o  客户端注册已不在当前核心规范的范围之内。 因此,本文档假定了多种选项,从开发
      期间的静态注册到运行时的动态注册。
 
   下列情况被认为在范围之内:
 
   o  授权服务器和资源服务器之间的通信。
 
   o  令牌格式。
 
   o  除了资源所有者密码凭据授予类型(参见 [RFC6749],第 4.3 节)外,授权服务器用于
      对用户进行身份验证的机制除外。
 
   o  用户通过该机制获得断言,以及由于断言为 false 而引发的任何攻击。
 
   o  未绑定到特定部署的客户端:示例可能是支持通过便携式联系人 API 访问联系人列表的
      邮件客户端(请参阅 [Portable-Contacts])。 此类客户端无法预先注册特定部署,
      应动态发现与 OAuth 协议相关的 URL。
 






2.2.  攻击假设
 
   以下假设与攻击者和攻击者可用的资源有关。 假定:
 
   o  攻击者分别对客户端和授权服务器以及客户端和资源服务器之间的网络拥有完全访问
      权限。 攻击者可能会窃听这些方之间的任何通信。 不假定他有权访问授权服务器和
      资源服务器之间的通信。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
      
 
   o  攻击者拥有无限的资源来发起攻击。
 
   o  参与 OAuth 协议的三方中的两个可能串通对第三方发动攻击。 例如,客户端和授权
      服务器可能受攻击者控制,并串通诱骗用户访问资源。
 



2.3.  架构假设
 
   本节介绍有关 OAuth 部署不同实体的功能、限制和设计选项的假设,以及这些实体管理的
   安全敏感数据元素。 这些假设是威胁分析的基础。
 
   OAuth 协议使部署在如何实施和应用标准方面拥有一定程度的自由。 核心规范定义了授权
   服务器和资源服务器的核心概念。 两个服务器可以在同一服务器实体中实现,也可以是不同
   的实体。 后者通常适用于具有单个身份验证和授权系统的多服务提供商,在中间件体系结构
   中更为典型。
 







2.3.1. 授权服务器
 
   以下数据元素在授权服务器上存储或访问:
 
   o  用户名和密码
 
   o  客户端 ID 和密钥
 
   o  特定于客户端的刷新令牌
 
   o  特定于客户端的访问令牌(在基于句柄的设计的情况下;参见第 3.1 节
 
   o  HTTPS certificate/key
 
   o  每个授权过程(在基于句柄的设计的情况下;第 3.1 节): "redirect_uri", 
      "client_id", authorization "code"</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
2.3.2.  资源服务器
 
   以下数据元素在资源服务器上存储或访问:
 
   o  用户数据(范围外)
 
   o  HTTPS certificate/key
 
   o  授权服务器凭据(基于句柄的设计;请参阅第 3.1 节)或授权服务器共享密钥/公钥
      (基于断言的设计;请参阅第 3.1 节)
 
   o  access tokens (per request)
 
   假定资源服务器不知道刷新令牌、用户密码或客户端密钥。
 
2.3.3.  Client
 
   在 OAuth 中,客户端是代表资源所有者及其授权发出受保护资源请求的应用程序。有不同
   类型的具有不同实现和安全特征的客户端,例如 Web、基于用户代理的应用程序和本机应用
   程序。 [RFC6749] 第 2.1 节给出了不同客户端类型和配置文件的完整定义。
 
   以下数据元素在客户端上存储或访问:
 
   o  客户端 ID(以及客户端密钥或相应的客户端凭据)
 
   o  每个终端用户或其他安全上下文或委派上下文的一个或多个刷新令牌(持久)和访问令牌
     (暂时性)
 
   o  受信任的证书颁发机构 (CA) 证书 (HTTPS)
 
   o  每个授权过程: "redirect_uri", authorization "code"
 
3.  安全功能
 
   这些是 OAuth 2.0 协议中内置的一些安全功能,用于缓解攻击和安全问题。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
3.1.  令牌
 
   OAuth 广泛使用多种令牌(访问令牌、刷新令牌、授权code)。 令牌的信息内容可以通过
   两种方式表示,如下所示:
 
   句柄(或artifact) "句柄"是对授权服务器内某些内部数据结构的引用;内部数据结构包含
      令牌的属性,如用户 ID (UID)、作用域等。句柄启用简单的吊销,并且不需要加密机制
      来保护令牌内容不被修改。另一方面,句柄需要颁发和使用实体(例如,授权服务器和资源
      服务器)之间的通信,以便验证令牌并获取令牌绑定数据。 如果两个实体都驻留在不同的
      系统上,则此通信可能会对性能和可伸缩性产生负面影响。 因此,如果颁发和使用实体
      相同,则通常使用句柄。"句柄"令牌通常称为"不透明"令牌,因为资源服务器不需要能够
      直接解释令牌;因此,资源服务器不需要直接解释令牌。它只是使用令牌。
 
   断言(也称为自包含令牌)断言是可解析的令牌。 断言通常具有持续时间、访问群体,并且
      通过数字签名来确保数据完整性和源身份验证。 它包含有关用户和客户端的信息。 
      断言格式的示例包括安全断言标记语言 (SAML) 断言 [OASIS.saml-core-2.0-os]
      和 Kerberos 票证 [RFC4120]。 断言通常可以直接由资源服务器验证和使用,而
      无需与授权服务器交互。 这在发布和使用实体驻留在不同系统上的部署中,可提供更好
      的性能和可伸缩性。 与句柄相比,实现令牌吊销在断言中更加困难。
 
   令牌可用于两种方式在资源服务器上调用请求,如下所示:
 
   bearer令牌 "bearer token"是任何收到令牌的客户端可以使用的令牌(例如
       [RFC6750])。 由于单纯的占有足以使用令牌,因此必须保护终结点之间的通信,以
       确保只有经过授权的端点才能捕获令牌。 承载令牌便于客户端应用程序使用,因为它
       不需要它们执行任何操作来使用它们(如身份证明)。 承载令牌具有与浏览器中使用的
       Web 单一登录 (SSO) Cookie 类似的特征。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   证明令牌  "证明令牌"是只能由特定客户端使用的令牌。 每次使用令牌都需要客户端执行
      某些操作,以证明其是令牌的授权用户。 这些示例是 MAC 类型的访问令牌,它要求
      客户端使用与随请求发送的特定令牌对应的机密对资源请求进行数字签名
      (例如,[OAuth-HTTP-MAC])。
 
3.1.1.  scope
 
   scope 表示与特定令牌关联的与这些资源上的资源服务器、资源和方法关联的访问授权。 
   scope 是显式管理与访问令牌关联的资源的 OAuth 方法。 scope可以由授权服务器和
   最终用户控制,以限制这些参与方认为不太安全或值得信任的 OAuth 客户端对资源的访问。
   或者,客户端可以请求范围以应用于令牌,但仅请求范围小于授予的范围,例如,如果此令牌
   通过不安全的通道发送,则减少潜在影响。 范围通常由令牌的生存期限制来补充。
 
3.1.2.  受限访问令牌生存期
 
   协议参数"expires_in"允许授权服务器(基于其策略或代表最终用户)限制访问令牌的
   生存期并将此信息传递给客户端。 此机制可用于向授权服务器认为不太安全的 OAuth 
   客户端发出短期令牌,或者通过不安全的通道发送令牌。
 
3.2.  访问令牌
 
   客户端使用访问令牌访问资源。访问令牌通常具有涵盖典型会话生存期的较短的生命周期
   (分钟或小时)。 访问令牌可以通过使用刷新令牌刷新。 访问令牌的短寿命与刷新令牌的
   使用相结合,使得在当前访问令牌到期时被动吊销访问授权成为可能。
 
3.3.  刷新令牌
 
   刷新令牌表示特定客户端代表资源所有者访问资源的持久授权。 此类令牌仅在客户端和
   授权服务器之间交换。 客户端使用这种令牌来获取(“刷新”)用于资源服务器调用的新
   访问令牌。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   刷新令牌加上较短的访问令牌生存期,可用于授予对资源的较长访问权限,而无需涉及最终
   用户授权。这在资源服务器和授权服务器不是同一实体(例如,在分布式环境中)提供了优势,
   因为刷新令牌始终在授权服务器上交换。授权服务器可以随时撤消刷新令牌,从而导致在
   当前访问令牌过期后吊销授予的访问权限。 因此,如果及时吊销是高优先级,则短访问令牌
   生存期非常重要。
 
   刷新令牌也是绑定到最初请求授权的客户端标识符和客户端实例的机密。刷新令牌还表示
   原始资源所有者授予。授权过程确保这一点,如下所示:
 
   1.  资源所有者和用户代理首先安全地将授权"code"传递到客户端实例。
 
   2.  客户端立即将其用于与授权服务器的安全传输级通信,然后安全地存储长生存的刷新
       令牌。
 
   3.  客户端始终使用安全传输级通信中的刷新令牌到授权服务器以获取访问令牌(并可以
       选择滚动刷新令牌)。
 
   因此,只要客户端能够确保特定令牌的机密性,刷新令牌也可以用作验证客户端实例本身的
   替代方法。
 
3.4.  Authorization "code"
 
   授权"code"表示成功的最终用户授权过程的中间结果,客户端用于获取访问和刷新令牌。 
   出于两个目的,授权"code"发送到客户端的重定向 URI,而不是令牌:
 
   1.  基于浏览器的流通过 URI 查询参数(HTTP 引用器)、浏览器缓存或日志文件条目向
       潜在攻击者公开协议参数,并可以重播。 为了减少这种威胁,通过短命授权"code"而
       不是令牌,并通过客户端和授权服务器之间的更安全的直接连接交换令牌。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   2.  在客户端和授权服务器之间的直接请求期间对客户端进行身份验证比在间接授权请求的
       上下文中进行身份验证要简单得多。 后者需要数字签名。
 
3.5.  Redirect URI
 
   重定向 URI 有助于检测恶意客户端,并防止客户端的网络钓鱼攻击,这些客户端试图诱使
   用户相信网络钓鱼者是客户端。 授权请求中使用的实际重定向 URI 的值必须显示,并在
   将授权"code"交换为令牌时进行验证。这有助于防止通过重定向者和假冒 Web 应用程序
   客户端显示授权"code"的攻击。授权服务器应要求公共客户端和机密客户端使用隐式授予
   类型预先注册其重定向 URI,并针对授权请求中的注册重定向 URI 进行验证。
 
3.6.  "state" 参数
 
   state"参数用于链接请求和回调,以防止跨站点请求伪造攻击(参见第 4.4.1.8 节),
   攻击者授权访问自己的资源,然后诱使用户使用攻击者的令牌进行重定向。此参数应绑定到
   用户代理中的已验证状态,并且根据核心 OAuth 规范,用户代理必须能够将其保留在客户端
   和用户代理仅可访问的位置,即受同源策略保护的位置。
 
3.7.  客户端标识符
 
   身份验证协议通常不考虑代表最终用户执行的软件组件的标识。OAuth 这样做是为了在
   授权方案中提高安全级别,并且因为客户端能够在用户在场的情况下执行操作。
 
   OAuth 使用客户端标识符将关联的请求整理给同一发起人,例如
 
   o  特定的最终用户授权过程和令牌节点上的相应请求,用于将授权"code"交换为令牌,或</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   o  最终用户对特定客户端的初始授权和令牌颁发,以及此客户端随后请求在未经用户同意
      的情况下获取令牌(自动处理重复授权)
 
   当请求同意特定客户端请求的范围时,授权服务器也可以使用此标识符向用户显示相关的
   注册信息。 客户端标识符可用于限制特定客户端的请求数或为每个请求向客户端收费。
   此外,区分不同客户端(例如服务器日志文件中的访问)可能也很有用。
 
   OAuth 根据使用授权服务器进行身份验证的能力(即维护其客户端凭据的机密性)定义了两种
   客户端类型,即机密和公共类型。机密客户端能够维护客户端凭据的机密性(即与客户端
   标识符关联的客户端机密)或能够使用其他方法(如客户端断言(例如 SAML)或密钥)保护
   客户端身份验证密码。 后者被认为更安全。
 
   授权服务器应确定客户端是否能够对其机密保密或使用安全身份验证。 或者,最终用户可以
   验证客户端的身份,例如,只需安装受信任的应用程序。 重定向 URI 可用于在某些情况下
   获得最终用户授权后防止将凭据传递到假冒客户端,但不能用于验证客户端标识符。
 
   客户端可以根据客户端类型、配置文件(例如,本机应用程序与 Web 应用程序;请参阅
   [RFC6749]、第 9 节)和部署模型进行如下分类:
 
   与部署无关的"client_id"具有预注册的"redirect_uri",并且没有
      "client_secret"   此类标识符由同一软件包的多个安装使用。 此类客户端的标识符
      只能在最终用户的帮助下验证。 对于本机应用程序来说,这是一个可行的选项,以便标识
      客户端,以便向用户显示有关客户端的元信息,并在日志文件中区分客户端。 与此类
      客户端标识符关联的权限的吊销将影响相应软件的所有部署。
      （共用一个id,一个重定向uri，无secret）</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   与部署无关的"client_id"具有预注册的"redirect_uri"和"client_secret"   这是
      仅本机应用程序的选项,因为 Web 应用程序需要不同的重定向 URI。 此类别不可取,
      因为客户端密钥无法得到适当的保护(请参阅第 4.1.1 节)。 由于其安全漏洞,此类
      客户端标识具有与部署无关的客户端相同的信任级别,没有机密。吊销将影响所有部署。
      （共用一个id,一个重定向uri，有secret）
 
   特定于部署的"client_id",具有预注册的"redirect_uri"和"client_secret" 
      客户端注册过程可确保验证客户端的属性,例如重定向 URI、网站 URL、网站名称和
      联系人。 此类客户端标识符可用于上述所有相关用例。Web 应用程序可以结合手动或
      用户绑定注册过程实现此级别。 实现本机应用程序的此级别要困难得多。 应用程序的
      安装由管理员执行,管理员验证客户端的真实性,或者从验证应用程序到在设备上安装
      应用程序和创建客户端凭据的过程是由单个实体(例如,应用程序市场提供商)控制端
      到端。 吊销将仅影响单个部署。
      （每个应用一个id）
 
   具有"client_secret"且不经过验证属性的特定的"client_id"部署  授权服务器可以在
      具有后续请求的事务中识别此类客户端(例如,授权和令牌颁发、刷新令牌颁发、和访问
      令牌刷新)。授权服务器无法向最终用户保证客户端的任何属性。也可以允许自动处理
      重新授权。此类客户端凭据可以自动生成,而无需对客户端属性进行任何验证,这使得
      它成为另一个选项,尤其是对于本机应用程序。吊销将仅影响单个部署。
 
4.  威胁模型
 
   本节给出了 OAuth 2.0 的综合威胁模型。威胁首先由针对 OAuth 组件(即客户端、
   授权服务器和资源服务器)的攻击进行分组。 随后,它们按流分组,例如,获取令牌或访问
   受保护的资源。每个对策描述都引用了第 5 节中的详细描述。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.1.  Clients
 
   本节介绍针对 OAuth 客户端的可能威胁。
 
4.1.1.  威胁:获取客户端密钥
 
   攻击者可以尝试访问特定客户端的密钥,以便:
 
   o  重播其刷新令牌和授权"codes",或
 
   o  代表受攻击的客户端获取令牌,该"client_id"作为客户端的实例具有特权。
 
   由此产生的影响如下:
 
   o  可以绕过对授权服务器访问的客户端身份验证。
 
   o  可以重播被盗刷新令牌或授权 "codes" .
 
   根据客户端类别,可以使用以下攻击来获取客户端机密。
 
   攻击:从源代码或二进制文件获取密钥:
 
   这适用于所有客户端类型。 对于开源项目,可以直接从公共存储库中的源代码中提取密钥。
   当已发布的源对攻击者不可用时,也可以从应用程序二进制文件轻松提取密钥。即使应用程序
   在其应用程序分发中采取了大量措施来混淆密钥,人们也应该考虑,任何有权访问完整功能的
   应用程序捆绑包或二进制文件的人仍然可以对该密钥进行反向工程。
 
   对策：
 
   o  不要向具有不当安全策略的公共客户或客户发布密钥(第 5.2.3.1 节)。
 
   o  公共客户端需要用户同意(第 5.2.3.2 节)。
 
   o  使用特定于部署的客户端密钥(第 5.2.3.4 节)。
 
   o  撤销客户密钥(第 5.2.3.6 节)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   攻击:获取特定于部署的密钥:
 
   攻击者可能尝试从客户端安装获取机密,无论是从网站(Web 服务器)还是从特定设备
   (本机应用程序)。
 
   对策：
 
   o  Web 服务器:应用标准 Web 服务器保护措施(用于配置文件和数据库)
      (请参阅第 5.3.2 节)。
 
   o  本机应用程序:在安全的本地存储中存储机密(第 5.3.3 节)。
 
   o  撤销客户机密(第 5.2.3.6 节)。
 
4.1.2.  威胁:获取刷新令牌
 
   根据客户端类型,可能会以不同的方式向攻击者显示刷新令牌。 以下子部分更详细地描述了
   针对不同客户端类型的不同攻击和进一步的专门对策。 在详细说明这些威胁之前,下面是
   一些通常适用的对策:
 
   o  授权服务器应该通过每个刷新请求来验证与特定刷新令牌相关联的客户端ID
      (第 5.2.2.2 节)。
 
   o  限制令牌范围(第 5.1.5.1 节)。
 
   o  撤销刷新令牌(第 5.2.2.4 节)。
 
   o  撤销客户密钥(第 5.2.3.6 节)。
 
   o  可以自动替换刷新令牌,以便检测另一方未经授权的令牌使用
      (请参阅"刷新令牌旋转",第 5.2.2.3 节)。
 

   攻击:从 Web 应用程序获取刷新令牌:
 
   攻击者可以通过克服 Web 服务器的安全控制来获取颁发给 Web 应用程序的刷新令牌。
 
   影响:由于 Web 应用程序管理特定站点的用户帐户,因此此类攻击将导致攻击者公开该
   站点上的所有刷新令牌。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   对策:
 
   o  标准 Web 服务器保护措施(第 5.3.2 节)。
 
   o  使用强客户端身份验证(例如,客户端断言/客户端令牌),以便攻击者无法获得交换
      令牌所需的客户端密钥(第 5.2.3.7 节)。
 

   攻击:从本机客户端获取刷新令牌:
 
   在本机客户端上,刷新令牌的泄漏通常仅影响单个用户。
 
   从本地文件系统读取:攻击者可能会尝试在设备上获取文件系统访问权限并读取刷新令牌。
   攻击者可能会为此利用恶意应用程序。
 
   对策：
 
   o  在安全存储中存储密钥(第 5.3.3 节)。
 
   o  利用设备锁定防止未经授权的设备访问(第 5.3.4 节)。
 

   攻击:窃取设备:
 
   主机设备(例如移动电话)可能被盗。 在这种情况下,攻击者可以根据合法用户的身份访问
   所有应用程序。
 
   对策：
 
   o  利用设备锁定防止未经授权的设备访问(第 5.3.4 节)。
 
   o  如果用户知道设备被盗,他们可以撤销受影响的令牌(第 5.2.2.4 节)。
 

   攻击:克隆设备:
 
   所有设备数据和应用程序都将复制到其他设备。应用程序在目标设备上同样使用。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   对策：
 
   o  利用设备锁定防止未经授权的设备访问(第 5.3.4 节)。
 
   o  将刷新令牌请求与设备标识相结合(第 5.2.2.5 节)。
 
   o  刷新令牌旋转(第 5.2.2.3 节)。
 
   o  如果用户知道设备已被克隆,他们可以使用刷新令牌吊销(第 5.2.2.4 节)。
 
4.1.3.  威胁:获取访问令牌
 
   根据客户端类型,访问令牌可能会以不同方式透露给攻击者。如果应用程序将访问令牌存储
   在其他应用程序可访问的存储设备中,则访问令牌可能会从设备中被盗。
 
   影响:如果令牌是bearer令牌,并且没有任何其他机制用于标识客户端,则攻击者可以访问与
   令牌及其作用域关联的所有资源。
 
   对策：
 
   o  将访问令牌保留在瞬态内存中并限制授予(第 5.1.6 节)。
 
   o  限制令牌范围(第 5.1.5.1 节)。
 
   o  将访问令牌保留在专用内存中,或应用与刷新令牌相同的保护手段(第 5.2.2 节)。
 
   o  保持访问令牌生存期较短(第 5.1.5.3 节)。
 
4.1.4.  威胁:使用受攻击或嵌入式浏览器仿冒最终用户凭据
 
   恶意应用程序可能试图通过在最终用户授权过程中滥用嵌入式浏览器,或通过显示自己的
   用户界面而不是允许受信任的系统浏览器呈现授权用户来欺骗最终用户密码接口。这样,
   通常的可视化信任机制可能会被绕过(例如,传输层安全 (TLS) 确认、网站机制)。通过
   使用嵌入式或内部客户端应用程序用户界面,客户端应用程序可以访问它不应访问的其他
   信息(例如 UID/密码)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   影响:如果客户端应用程序或通信受到威胁,用户将不知道这一点,并且可以捕获授权交换中
   的所有信息,如用户名和密码。
 
   对策：
 
   o  oAuth 流的设计使客户端应用程序无需知道用户密码。客户端应用程序应避免直接询问
      用户其凭据。 此外,最终用户可以了解网络钓鱼攻击和最佳实践,例如仅访问受信任的
      客户端,因为 OAuth 不提供针对恶意应用程序的任何保护,并且最终用户对任何已安装
      本机应用程序客户端的可信度负有全部责任。。
 
   o  客户端应用程序可以在应用程序市场发布之前进行验证,供用户访问。该验证已不用于
      OAuth 的范围,但可能包括验证客户端应用程序是否以适当的方式处理用户身份验证。
 
   o  客户端开发人员不应编写直接从用户收集身份验证信息的客户端应用程序,而应将其任务
      委派给受信任的系统组件,例如系统浏览器。
 
4.1.5.  威胁:在客户端上打开重定向
 
   打开的重定向器是使用参数自动将用户代理重定向到参数值指定的位置而不进行任何验证的
   节点。 如果授权服务器允许客户端仅注册重定向 URI 的一部分,则攻击者可以使用客户端
   操作的开放式重定向器来构造重定向 URI,该 URI 将通过授权服务器验证,但会发送
   授权"code"或访问攻击者控制下的节点的令牌。
 
   影响:攻击者可以访问授权"code"或访问令牌。
 
   对策：
 
   o  要求客户端注册完全重定向 URI(第 5.2.3.5 节)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.  授权节点
 
4.2.1.  威胁:伪造授权服务器的密码网络钓鱼
 
   OAuth 不尝试验证授权服务器的真实性。 敌对方可以通过拦截客户的请求并返回误导性或
   其他不正确的响应来利用这一点。这可以通过 DNS 或地址解析协议 (ARP) 欺骗来实现。
   OAuth 和类似协议的广泛部署可能导致用户习惯于被重定向到要求他们输入密码的网站。
   如果用户在输入凭据之前不谨慎验证这些网站的真实性,攻击者可能会利用这种做法窃取
   用户的密码。
 
   对策：
 
   o  授权服务器在基于 OAuth 开发服务时应考虑此类攻击,并且应要求对授权服务器或
      请求响应的真实性存在问题的任何请求使用传输层安全性(第 5.1.2 节)。
 
   o  授权服务器应尝试教育用户有关网络钓鱼攻击带来的风险,并应提供机制,使用户能够
      轻松地确认其网站的真实性。
 
4.2.2.  威胁:用户无意中授予了过多的访问范围
 
   获得最终用户授权时,最终用户可能不理解授予访问权限的范围和授予谁,或者他们最终可能
   向客户端提供不应允许的资源访问权限。
 
   对策：
 
   o  以易于理解的方式解释用户即将授予的范围(资源和权限)(第 5.2.4.2 节)。
 
   o  根据客户端缩小范围。 在获得最终用户授权和客户端请求作用域时,授权服务器可能
      需要考虑是否基于客户端标识符遵守该作用域。 此决定位于客户端和授权服务器之间,
      超出了此规范的范围。 授权服务器可能还需要考虑根据客户端类型授予哪些作用域,
      例如,为公共客户端提供较低的作用域(第 5.1.5.1 节)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.2.3.  威胁:恶意客户端通过欺诈获取现有授权
 
   授权服务器可能希望自动处理来自以前由用户授权的客户端的授权请求。当用户被重定向
   到授权服务器的最终用户授权节点以授予访问权限时,授权服务器将检测到用户已授予对
   该特定客户端的访问权限。授权服务器会自动将用户重定向回客户端,而不是提示用户批准。
 
   恶意客户端可能会利用该功能,并尝试获取此类授权"code",而不是合法客户端。
 
   对策：
 
   o  授权服务器不应自动处理公共客户端的重复授权,除非使用预先注册的重定向 URI
      (第 5.2.3.5 节)验证客户端。
 
   o  授权服务器可以通过限制通过自动批准获得的访问令牌的范围来降低与自动处理相关
      的风险(第 5.1.5.1 节)。
 
4.2.4.  威胁:开放式重定向
 
   攻击者可以使用最终用户授权终结点和重定向 URI 参数滥用授权服务器作为开放式重定向
   器。打开的重定向器是使用参数自动将用户代理重定向到参数值指定的位置而不进行任何
   验证的节点。
 
   影响:攻击者可以利用用户对授权服务器的信任来发起网络钓鱼攻击。
 
   对策：
 
   o  要求客户端注册任何完全重定向 URI(第 5.2.3.5 节)。
 
   o  如果无法验证客户端标识符或重定向 URI,则不要重定向到重定向 URI
      (第 5.2.3.5 节)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.3.  令牌节点
 
4.3.1.  威胁:窃听访问令牌
 
   攻击者可能尝试窃听从授权服务器到客户端的传输中的访问令牌。
 
   影响:攻击者能够访问具有特定访问令牌范围涵盖的权限的所有资源。
 
   对策：
 
   o  根据 OAuth 核心规范,授权服务器必须确保使用传输层机制(如 TLS)保护这些传输
      (参见第 5.1.1 节)。
 
   o  如果不能保证端到端机密性,则可以减少访问令牌的范围(见第 5.1.5.1 节)和到期
      时间(第 5.1.5.3 节),以减少泄漏时的损害。
 
4.3.2.  威胁:从授权服务器数据库获取访问令牌
 
   如果授权服务器将访问令牌作为句柄存储在数据库中,则此威胁适用。攻击者可以通过访问
   数据库或发起 SQL 注入攻击从授权服务器的数据库获取访问令牌。
 
   影响:泄露所有访问令牌。
 
   对策：
 
   o  实施系统安全措施(第 5.1.4.1.1 节)。
 
   o  仅存储访问令牌哈希(第 5.1.4.1.3 节)。
 
   o  实施标准 SQL 注入对策(第 5.1.4.1.2 节)。
 
4.3.3.  威胁:传输过程中泄露客户端凭据
 
   攻击者可能会尝试在客户端身份验证过程中或 OAuth 令牌请求期间窃听客户端凭据在
   客户端和服务器之间的传输。
 
   影响:客户端凭据的启示,允许网络钓鱼或模拟客户端服务。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   对策：
 
   o  必须使用传输层机制(如 TLS)保护客户端凭据的传输(参见第 5.1.1 节)。
 
   o  使用替代身份验证意味着不需要通过无线方式发送纯文本凭据
      (例如,基于哈希的消息身份验证代码)。
 
4.3.4.  威胁:从授权服务器数据库获取客户端密钥
 
   攻击者可以通过访问数据库或发起 SQL 注入攻击,从授权服务器的数据库获取有效的
   "client_id"/secret 组合。
 
   影响:披露所有"client_id"/secret组合。 这允许攻击者代表合法客户端执行操作。
 
   对策：
 
   o  实施系统安全措施(第 5.1.4.1.1 节)。
 
   o  实施标准 SQL 注入对策(第 5.1.4.1.2 节)。
 
   o  确保根据"强制凭据存储保护最佳做法"正确处理凭据(第 5.1.4.1 节)。
 
4.3.5.  威胁:通过在线猜测获取客户端机密
 
   攻击者可能会尝试猜测有效的 "client_id"/secret 对.
 
   影响:披露单个 "client_id"/secret 对.
 
   对策：
 
   o  对secret使用高熵(第 5.1.4.2.2 节)。
 
   o  锁定帐户(第 5.1.4.2.3 节)。
 
   o  使用强客户端身份验证(第 5.2.3.7 节)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.4.  获得授权
 
   本节介绍特定于用于获取访问令牌的某些流程的威胁。 每个流程分别具有最终用户授权和
   令牌终结点上的响应类型和/或授予类型。
 
4.4.1.  Authorization "code"
 
4.4.1.1.  威胁:窃听或泄漏授权 "codes"
 
   攻击者可能会尝试在授权服务器和客户端之间窃听授权"codes"的传输。 此外,授权
   "codes"通过浏览器传递,这可能会无意中以不同的方式将这些代码泄露给不受信任的网站
   和攻击者:
 
   o  Referrer headers: 当网页嵌入内容或当用户从一个网页传播到另一个网页时,
      浏览器通常会传递"Referrer"header。 即使源站点不信任目标站点,也可以发送
      这些Referrer headers。 出于流量分析目的,通常记录Referrer headers。
 
   o  请求日志:Web 服务器请求日志通常包括请求上的查询参数。
 
   o  打开重定向器:网站有时需要通过重定向器将用户发送到另一个目的地。开放式重定向器
      对基于 Web 的委派协议构成特殊风险,因为重定向器可能会将验证码泄漏到不受信任的
      目标站点。
 
   o  浏览器历史记录:Web 浏览器通常在浏览器历史记录中记录访问过的 URL。 同一 Web
      浏览器的其他用户可能能够查看以前用户访问的 URL。
 
   注意:对 SAML 协议的类似攻击的描述可在[OASIS.sstc-saml-bindings-1.1] 
   第 4.1.1.9.1 节、[Sec-Analysis]
   和[OASIS.sstc-sec-analysis-response-01]中找到.</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   对策：
 
   o  根据 OAuth 核心规范,授权服务器和客户端必须确保使用传输层机制(如 TLS)保护
      这些传输(请参阅第 5.1.1 节)。
 
   o  授权服务器将要求客户端尽可能进行身份验证,以便以可靠的方式验证授权"code"到
      特定客户端的绑定(请参阅第 5.2.4.4 节)。
 
   o  使用较短的到期时间进行授权"code"(第 5.1.5.3 节)。
 
   o  授权服务器应强制实施一次性使用限制(请参阅第 5.1.5.4 节)。
 
   o  如果授权服务器观察到多次尝试兑换授权"code",则授权服务器可能希望撤销基于
      授权"code"授予的所有令牌(请参阅第 5.2.1.1 节)。
 
   o  在没有这些对策的情况下,减少访问令牌的范围(第 5.1.5.1 节)和到期时间
      (第 5.1.5.3 节)可用于减少泄漏时的损害。
 
   o  客户端服务器可能会重新加载重定向 URI 的目标页面,以便自动清理浏览器缓存。
 
4.4.1.2.  威胁:从授权服务器数据库获取授权 "codes" 
 
   如果授权服务器将授权 "codes"作为句柄存储在数据库中,则此威胁适用。攻击者可以通过
   访问数据库或发起 SQL 注入攻击,从授权服务器的数据库获取授权"codes"。
 
   影响:披露所有授权"codes",很可能与相应的"redirect_uri"和"client_id"值一起
   披露。
 
   对策：
 
   o  应采用凭据存储保护的最佳做法(第 5.1.4.1 节)。
 
   o  实施系统安全措施(第 5.1.4.1.1 节)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   o  仅存储访问令牌哈希(第 5.1.4.1.3 节)。
 
   o  实施标准 SQL 注入对策(第 5.1.4.1.2 节)。
 
4.4.1.3.  威胁:在线猜测授权"codes"
 
   攻击者可能会尝试猜测有效的授权"codes"值,并使用授予类型"codes"发送猜测的代码
   值,以便获取有效的访问令牌。
 
   影响:泄露单个访问令牌,可能还包括关联的刷新令牌。
 
   对策：
 
   o  基于句柄的令牌必须使用高熵(第 5.1.4.2.2 节)。
 
   o  应对基于断言的令牌进行签名(第 5.1.5.9 节)。
 
   o  验证客户端;这将添加攻击者必须猜测的另一个值(第 5.2.3.4 节)。
 
   o  将授权"codes"绑定到重定向 URI;这将添加攻击者必须猜测的另一个值
      (第 5.2.4.5 节)。
 
   o  对令牌使用较短的到期时间(第 5.1.5.3 节)。
 
4.4.1.4.  威胁:恶意客户端获得授权
 
   恶意客户端可以假装是有效的客户端,并以这种方式获取访问授权。 恶意客户端甚至可以
   利用屏幕抓取技术来模拟授权流中的用户同意。
 
   假设:授权服务器的任务不是保护最终用户的设备免受恶意软件的攻击。 这是在特定设备上
   运行的平台的责任,可能与相应生态系统的其他组件(例如,应用程序管理基础结构)合作。 
   授权服务器的唯一责任是控制对资源服务器中维护的最终用户资源的访问,并防止通过 
   OAuth 协议未经授权访问这些资源。 基于此假设,可以使用以下对策来应对威胁。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   对策：
 
   o  授权服务器应验证客户端(如果可能)(请参阅第 5.2.3.4 节)。 注意:身份验证在
      最终用户授权访问后进行。
 
   o  授权服务器应根据预先注册的重定向 URI 验证客户端的重定向 URI(如果存在该
      URI(请参阅第 5.2.3.5 节)。 注意: 无效重定向 URI 指示无效的客户端,而有效的
      重定向 URI 不一定指示有效的客户端。 置信度取决于客户端类型。 对于 Web 应用
      程序,置信度很高,因为重定向 URI 是指此应用程序的全局唯一网络节点,用户代理
      也使用 HTTPS 服务器身份验证验证其完全限定的域名 (FQDN)。相反,对于本机
      客户端,重定向 URI 通常是指设备本地资源,例如自定义方案。因此,特定设备上的恶意
      客户端可以使用合法客户端在所有其他设备上使用的有效重定向 URI。
 
   o  对最终用户进行身份验证后,授权服务器应征求他/她的同意。在此上下文中,授权服务器
      应向最终用户解释客户端请求的授权目的、范围和持续时间。此外,授权服务器应向用户
      显示其为该客户端提供的任何标识信息。用户应验证此数据对特定应用程序(例如Name)
      的绑定,并批准授权请求(请参阅第 5.2.4.3 节)。
 
   o  授权服务器不应为其无法可靠地进行身份验证或验证的客户端执行自动重新授权
      (参见第 5.2.4.1 节)。
 
   o  如果授权服务器自动对最终用户进行身份验证,则仍可能需要一些用户输入以防止屏幕
      抓取。 例如 验证码(完全自动化的公共图灵测试,以告诉计算机和人类分开)或其他
      多重身份验证技术,如随机问题,令牌代码生成器等。
 
   o  授权服务器也可能限制它向无法可靠验证的客户端颁发令牌的范围
      (请参阅第 5.1.5.1 节)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.4.1.5.  威胁:授权"code"网络钓鱼
 
   敌对方可以模拟客户端站点并访问授权"code"。这可以通过 DNS 或 ARP 欺骗来实现。
   这适用于客户端,即 Web 应用程序;因此,重定向 URI 不是运行用户浏览器的主机的本地
   URI。
 
   影响:这会影响 Web 应用程序,并可能导致授权"code"的泄露,并可能导致相应的访问和
   刷新令牌泄露。
 
   对策：
 
   强烈建议采用以下对策之一,以防止这种攻击:
 
   o  客户端的重定向 URI 应指向受 HTTPS 保护的终结点,并且应利用浏览器使用服务器
      身份验证验证此重定向 URI(请参阅第 5.1.2 节)。
 
   o  授权服务器应要求对客户端进行身份验证,即机密客户端,以便以可靠的方式验证授权
      "code"对特定客户端的绑定(参见第 5.2.4.4 节)。
 
4.4.1.6.   威胁:用户会话模拟
 
   敌对方可以模拟客户端站点并在此客户端上模拟用户的会话。 这可以通过 DNS 或 ARP 
   欺骗来实现。 这适用于客户端,即 Web 应用程序;  因此,重定向 URI 不是运行用户
   浏览器的主机的本地 URI。
 
   影响:在浏览器将授权"code"发送到回调节点时拦截该授权"code"的攻击者可以通过向
   客户端提交授权"code"来访问受保护的资源。 客户端将交换访问令牌的授权"code",并
   使用访问令牌来访问受保护的资源，以使攻击者受益，将受保护的资源交付给攻击者，或
   按照攻击者的指示修改受保护的资源。如果客户端使用 OAuth 将身份验证委派给社交网站
   (例如,在第三方社交网络站点上实现"登录"按钮),则攻击者可以使用截获的授权"code"
   作为用户登录客户端。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   注意:在授权"code"交换期间对客户端进行身份验证无助于检测此类攻击,因为它是获取
   令牌的合法客户端。
 
   对策：
 
   o  为了防止攻击者模拟最终用户的会话,客户端的重定向 URI 应指向受 HTTPS 保护的
      终结点,并且应利用浏览器使用服务器身份验证验证此重定向 URI
      (请参阅第 5.1.2 节)。
 
4.4.1.7.  威胁:授权"code"通过假冒客户端泄漏
 
   攻击者利用授权"code"授予类型,试图让其他用户(受害者)登录,授权访问他/她的资源,
   然后获取授权"code",并将其注入客户端应用程序使用攻击者的帐户。目标是将受害者资源
   的访问权限与客户端站点上攻击者的用户帐户相关联。
 
   攻击者滥用现有客户端应用程序,并将其与自己的仿冒客户端网站相结合。 攻击者依赖于
   预期客户端应用程序请求访问特定资源服务器的受害者。受害者只看到预期申请的正常请求,
   就批准该请求。然后,攻击者使用受害者的授权在不知情的情况下访问受害者授权的信息。
 
   攻击者执行流程:
 
   1.  攻击者访问客户端网站(或应用程序),并启动对特定资源服务器的数据访问。客户端
       网站反过来向资源服务器的授权服务器发起授权请求。攻击者修改由客户端构造的授权
       服务器最终用户授权 URL,以包括引用其控制的网站(攻击者的 Web)的重定向 URI 
       参数,而不是继续授权过程站点)。
 
   2.  攻击者诱使其他用户(受害者)打开修改后的最终用户授权 URI 并授权访问(例如,
       通过电子邮件链接或博客链接)。攻击者实现此目标的方式已不包括范围。
 
   3.  单击链接后,请受害者对客户端站点进行身份验证并授权其访问。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   4.  授权过程完成后,授权服务器将用户代理重定向到攻击者的网站,而不是原始客户端
       网站。
 
   5.  攻击者通过本文档范围外的方式从其网站获取授权"code"。
 
   6.  然后,他根据原始授权请求的重定向 URI 和新获得的授权"code"构造重定向 URI 到
       目标网站(或应用程序),并将他的用户代理定向到此 URL。 授权"code"被注入到
       原始客户端站点(或应用程序)。
 
   7.  客户端站点使用授权"code"从授权服务器获取令牌,并将此令牌与攻击者在此站点上
       的用户帐户相关联。
 
   8.  攻击者现在可以使用客户端站点访问受害者的资源。
 
   影响:攻击者获得对受害者资源的访问权限,这些资源与其在客户端站点上的帐户相关联。
 
   对策：
 
   o  攻击者将需要为其授权过程使用另一个重定向URI,而不是目标网站,因为它需要拦截流。
      因此,如果授权服务器将授权"code"与特定最终用户授权的重定向 URI 相关联,并将此
      重定向 URI 与传递给令牌终结点的重定向 URI 一起验证,则检测到此类攻击
      (请参阅 Section 5.2.4.5)。
 
   o  授权服务器还可以强制使用和验证预先注册的重定向 URI(请参阅第 5.2.3.5 节)。 
      这将允许尽早识别授权"code"披露给假冒客户。
 
   o  对于本机应用程序,还可以考虑使用特定于部署的客户端 ID 和密钥(请参阅第 5.2.3.4
      节),以及将授权"code"绑定到"client_ids"(参见第 5.2.4.4 节),以检测此类
      攻击,因为攻击者无法访问特定于部署的机密。 因此,他将无法交换授权"code"。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   o  客户端可以考虑使用其他不受此类攻击的流程,例如隐式授予类型(请参阅第 4.4.2 节)
      或资源所有者密码凭据(请参阅第 4.4.3 节)。
 
4.4.1.8.  威胁:CSRF 攻击uri重定向
 
   跨站点请求伪造 (CSRF) 是一种基于 Web 的攻击,根据该攻击,HTTP 请求从网站信任或
   经过身份验证的用户(例如,通过 HTTP 重定向或 HTML 表单)传输。 CSRF 对 OAuth 
   批准的攻击可能允许攻击者在未经用户同意的情况下获得对 OAuth 受保护资源的授权。
 
   此攻击适用于授权"code"流中使用的重定向 URI。 攻击者可以授权授权"code"到授权
   服务器上其自己的受保护资源。然后,他中止重定向流回其设备上的客户端,并诱使受害者
   执行重定向回客户端。客户端接收重定向,从授权服务器获取令牌,并将受害者的客户端会话
   与使用令牌可访问的资源相关联。
 
   影响:用户代表攻击者访问资源。有效影响取决于访问的资源类型。例如,用户可以将私有项目
   上载到攻击者的资源。 或者,在第三方登录方案中使用 OAuth 时,用户可能会将其客户端
   帐户与外部标识提供程序中的攻击者身份相关联。通过这种方式,攻击者可以轻松地在客户端
   访问受害者的数据,方法是使用外部标识提供程序的凭据从另一台设备登录。
 
   对策：
 
   o  应使用"state"参数将授权请求与用于传递访问令牌的重定向 URI 绑定
      (第 5.3.5 节)。
 
   o  可以教育客户端开发人员和最终用户不要点击不受信任的 URL。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.4.1.9.  威胁:点击对授权的攻击
 
   通过点击劫持,恶意站点将目标站点加载到透明 iFrame 中(参见 [iFrame])中,这些虚拟
   按钮覆盖在一组虚拟按钮之上,这些虚拟按钮经过精心构造,可直接放置在目标站点的重要按钮
   下。 当用户单击可见按钮时,他们实际上是在单击隐藏页面上的按钮(如"授权"按钮)。
 
   影响:攻击者可以窃取用户的身份验证凭据并访问其资源。
 
   对策：
 
   o  对于较新的浏览器,可以使用 X-FRAME-OPTIONS 标头(第 5.2.2.6 节)在服务器端
      强制避免在授权期间使用 iFrame。
 
   o  对于较旧的浏览器,可以使用 JavaScript 破坏帧(请参阅 [Framebusting])技术,
      但可能并非在所有浏览器中都有效。
 
4.4.1.10.  威胁:资源所有者模拟
 
   当客户端请求访问受保护的资源时,授权流程通常涉及资源所有者对访问请求的显式响应,即
   授予或拒绝对受保护资源的访问权限。 恶意客户端可以通过以编程方式传输必要的请求并
   针对授权服务器模拟流程,利用此流的结构知识,在未经资源所有者同意的情况下获得授权。
   这样,客户可以在未经她批准的情况下访问受害人的资源。如果授权服务器使用非交互式身份
   验证机制或跨多个页面拆分授权流,则它容易受到此威胁的影响。
 
   恶意客户端可能会嵌入隐藏的 HTML 用户代理,解释授权服务器发送的 HTML 表单,并自动
   发送相应的 HTTP POST 请求表单。 作为先决条件,攻击者必须能够在资源所有者与授权
   服务器的已验证会话的上下文中执行授权过程。 实现此目的的方法有很多种:
 
   o  恶意客户端可能会滥用外部浏览器中的现有会话或特定设备上的跨浏览器 Cookie。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   o  恶意客户端还可以请求授权用户可接受的初始作用域,然后以静默方式滥用其浏览器实例
      中生成的会话以"silently"请求另一个作用域。
 
   o  或者,攻击者可能会利用授权服务器自动对资源所有者进行身份验证的能力,而无需用户
      交互(例如,基于证书)。
 
   在所有情况下,此类攻击仅限于在受害者设备上运行的客户端,无论是在用户代理中,还是作为
   本机应用。
 
   请注意:无法使用 CSRF 对策阻止此类攻击,因为攻击者只需"执行"授权服务器准备的 URL,
   包括任何 nonce 等。
 
   对策：
 
   授权服务器应根据对此威胁相关风险的分析,决定是否检测和预防此威胁。
 
   为了防止此类攻击,授权服务器可能会强制用户交互基于不可预测的输入值作为用户同意审批
   的一部分。 授权服务器可以
 
   o  将密码身份验证和用户同意合并为单一形式,
 
   o  利用验证码,或
 
   o  使用从带子中发送到资源所有者的一次性机密(例如,通过文本或即时消息)。
 
   或者,为了让资源所有者检测到滥用情况,授权服务器可以通过适当的方式(例如文本或即时
   消息或电子邮件)通知资源所有者任何批准。
 
4.4.1.11.  威胁:DoS 攻击耗尽资源
 
   如果授权服务器在授权"code"或访问令牌(限制可能的代码/令牌的数量)中包含大量熵,并且
   自动授予,无需用户干预,并且对每个代码或访问令牌没有限制用户,攻击者可以通过反复指示
   用户的浏览器请求授权code或访问令牌来耗尽授权池code。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   对策：
 
   o  授权服务器应考虑限制每个用户授予的访问令牌数。
 
   o  授权服务器应在授权"code"中包含相当数量的熵。
 
4.4.1.12.  威胁:使用制造授权的 DoS "code"
 
   拥有僵尸网络的攻击者可以定位侦听 HTTP 的客户端的重定向 URI,使用随机授权"code"
   访问它们,并导致大量 HTTPS 连接集中到授权服务器上。 这可能会导致对授权服务器上的
   拒绝服务 (DoS) 攻击。
 
   即使 CSRF 防御/"state"参数(参见第 4.4.1.8 节)部署在客户端,此攻击仍然有效。 
   使用此类防御,攻击者可能需要发出额外的 HTTP 请求才能获得有效的 CSRF 代码
   /"state"参数。 这显然将攻击的效果降低了2倍。 但是,如果 HTTPS/HTTP 成本比高于
   2(成本系数估计为 [SSL-延迟] 时约为 3.5 倍),则攻击者仍会以牺牲授权服务器为代价
   来放大资源利用率。
 
   影响:攻击者可以通过这个OAuth流完成一些他们不能轻易实现的效果。
 
   1.  连接清洗:使用客户端作为攻击者和授权服务器之间的中继,授权服务器很少或根本没有
       了解攻击者的身份信息。 由于难以识别攻击机器,因此对违规攻击者机器的速率限制等
       防御效果较差。 尽管攻击者还可以通过诸如 Tor 等匿名系统清洗其连接,但这种方法
       的有效性取决于匿名系统的能力。 另一方面,可能大量 OAuth 客户端可用于此攻击。
 
   2.  非对称资源利用率:攻击者产生 HTTP 连接的成本,并导致在授权服务器上建立 HTTPS
       连接;攻击者可以相对容易地协调多个客户端之间此类 HTTPS 连接的时间。 尽管攻击
       者可以实现类似目的,例如,通过在 HTTP 网页中包括指向授权服务器 HTTPS URL 的
       iFrame 并吸引 Web 用户访问该页面,使用此类方案进行计时攻击可能更加困难,因为
       看起来同步大量用户以同时访问攻击者控制的特定站点非常重要。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 



 
   对策：
 
   o  虽然 CSRF 防御和使用安全随机代码创建的"state"参数本身不是完整的对策,但应在
      客户端部署。 只有在验证 CSRF 令牌和"state"参数后,客户端才应将授权"code"
      转发给授权服务器。
 
   o  如果客户端通过单一登录协议或通过本地身份验证对用户进行身份验证,则如果此用户
      提交的无效授权"code"数超过一定的阈值,则客户端应暂停用户帐户的访问。
 
   o  授权服务器应向报告无效授权"code"的客户端发送错误响应,并限制或禁止来自无效
      请求数超过阈值的客户端的连接。
 
4.4.1.13.  T威胁:code替换(OAuth 登录)
 
   攻击者可能尝试使用受害者的身份登录应用程序或网站。 依赖 OAuth 受保护服务 API 
   提供的标识数据登录用户的应用程序容易受到此威胁的影响。 此模式可以在所谓的"社交
   登录"方案中找到。
 
   作为先决条件,资源服务器提供 API 来获取有关用户的个人信息,这些信息可能被解释为
   已获取用户标识。 从这个意义上讲,客户端将资源服务器 API 视为"标识"API。 客户端
   利用 OAuth 获取标识 API 的访问令牌。 然后,它查询标识符的标识 API,并使用它查找
   其内部用户帐户数据(登录)。 客户端假定,因为它能够获取有关用户的信息,因此用户已
   经过身份验证。
 
   如果客户端使用授予类型"code",则攻击者需要从目标客户端应用程序使用的同一标识提供
   程序收集相应受害者的有效授权"code"。 攻击者使用与目标应用程序相同的标识提供程序
   诱使受害者登录到恶意应用(对于标识提供程序可能是合法的)。 这将导致标识提供程序的
   授权服务器为各自的标识 API 颁发授权"code"。 然后,恶意应用将此代码发送给攻击者,
   从而触发目标应用程序中的登录进程。攻击者现在操纵授权响应,并将其代码(绑定到其身份)
   替换为受害者的代码。 然后,客户端将此代码交换为访问令牌,而访问令牌又被标识 API 
   接受,因为访问群体相对于资源服务器是正确的。 但是,由于标识 API 返回的标识符由访问
   令牌中的标识(根据受害者的代码颁发)确定,因此攻击者会以受害者的身份登录到目标应用
   程序。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 











 
   影响:攻击者获得对应用程序中用户特定数据的访问权限。
 
   对策：
 
   o  所有客户端都必须在每次请求中指示其客户端 ID,以便为访问令牌交换授权"code"。 
      授权服务器必须验证特定授权"code"是否已颁发给特定客户端。 如果可能,客户应
      事先进行验证。
 
   o  客户端应使用适当的协议,如 OpenID (参合 [OPENID]) 或 SAML
      (参看 [OASIS.sstc-saml-bindings-1.1]) 来实现用户登录。两者都支持对
      客户端的受众限制。
 
4.4.2.  隐式授权
 
   在隐式授予类型流中,访问令牌作为重定向 URI 的片段部分直接返回给客户端。 假定令牌
   未发送到重定向 URI 目标,因为 HTTP 用户代理不会将 URI 的片段部分发送到 HTTP 
   服务器。 因此,攻击者无法窃听此通信路径上的访问令牌,并且令牌无法通过 HTTP 引用
   标头泄漏。
 
4.4.2.1.  威胁:传输/端点中的访问令牌泄漏
 
   此令牌可能被攻击者窃听。 令牌通过重定向 URI 的 URI 片段从服务器发送到客户端。
   如果通信不安全或终结点未受到保护,则可以通过分析返回的 URI 泄漏令牌。
 
   影响：攻击者将能够获得令牌授予的相同权限。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   对策：
 
   o  授权服务器应确保从授权服务器到客户端的响应的机密性(例如,使用 TLS)
      (请参阅第 5.1.1 节)。
 
4.4.2.2.  威胁:浏览器历史记录中的访问令牌泄漏
 
   攻击者可以从浏览器的历史记录中获取令牌。 请注意,这意味着攻击者需要访问特定设备。
 
   对策：
 
   o  对令牌使用较短的到期时间(参见第 5.1.5.3 节)。 缩小令牌的范围可能会减少该
      攻击的影响(请参阅第 5.1.5.1 节)。
 
 
   o  使响应不可缓存。
 
4.4.2.3.  威胁:恶意客户端获得授权
 
   恶意客户端可能试图通过欺诈获取令牌。
 
   与第 4.4.1.4 节相同的对策适用,但客户端身份验证除外。
 
4.4.2.4.  威胁:脚本操作
 
   敌对方可以充当客户端 Web 服务器,并替换或修改客户端的实际实现(脚本)。 这可以通过
   DNS 或 ARP 欺骗来实现。 这适用于在 Web 浏览器中以脚本语言实现的客户端。
 
   影响:攻击者可以获取用户凭据信息并假定用户的完整身份。
 
   对策：
 
   o  授权服务器应对从中获取脚本的服务器进行身份验证(请参阅第 5.1.2 节)。
 
   o  客户端应确保在传输中获取的脚本未被更改(参见第 5.1.1 节)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   o  引入一次性使用的密钥(例如,"client_secret")值,这些值只能在从服务器加载后
      由小时间窗口中的脚本使用。 其目的是降低复制客户端脚本以在攻击者修改的代码中
      重复使用的有效性。
 
4.4.2.5.  威胁:CSRF 攻击重定向
 
   CSRF 攻击(参见第 4.4.1.8 节)也针对隐式授予流中使用的重定向 URI 起作用。攻击者
   可以获取对其受保护资源的访问令牌。 然后,他可以构造重定向 URI,并将他们的访问令牌
   嵌入到该 URI 中。 如果他可以诱使用户遵循重定向 URI,并且客户端没有针对此攻击的
   保护,则用户可能在其客户端中授权攻击者的访问令牌。
 
   影响:用户代表攻击者访问资源。有效影响取决于访问的资源类型。例如,用户可以将私有
   项目上载到攻击者的资源。 或者,在第三方登录方案中使用 OAuth 时,用户可能会将其
   客户端帐户与外部标识提供程序中的攻击者身份相关联。 通过这种方式,攻击者可以轻松地
   在客户端访问受害者的数据,方法是使用外部标识提供程序的凭据从另一台设备登录。
 
   对策：
 
   o  应使用"state"参数将授权请求与用于传递访问令牌的重定向 URI 相关联。这将确保
      客户端不会被骗完成任何重定向回调,除非它链接到客户端启动的授权请求。"state"
      参数不应是可猜测的,并且客户端应该能够保持"state"参数的秘密。
 
   o  可以教育客户端开发人员和最终用户不要遵循不受信任的 URL。
 
4.4.2.6.  威胁:令牌替换(OAuth 登录)
 
   攻击者可能尝试使用受害者的身份登录应用程序或网站。 依赖 OAuth 受保护服务 API 
   提供的标识数据登录用户的应用程序容易受到此威胁的影响。 此模式可以在所谓的
   "社交登录"方案中找到。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   作为先决条件,资源服务器提供 API 来获取有关用户的个人信息,这些信息可能被解释为
   已获取用户标识。 从这个意义上讲,客户端将资源服务器 API 视为"标识"API。 客户端
   利用 OAuth 获取标识 API 的访问令牌。 然后,它查询标识符的标识 API,并使用它查找
   其内部用户帐户数据(登录)。 客户端假定,因为它能够获取有关用户的信息,因此用户已
   经过身份验证。
 
   要成功,攻击者需要从目标客户端应用程序使用的同一标识提供程序收集相应受害者的有效
   访问令牌。 攻击者使用与目标应用程序相同的标识提供程序诱使受害者登录到恶意应用
   (对于标识提供程序可能是合法的)。  这将导致标识提供程序的授权服务器为各自的标识
    API 颁发访问令牌。 然后,恶意应用向攻击者发送此访问令牌,从而触发目标应用程序中
   的登录进程。 攻击者现在操作授权响应,并将其访问令牌(绑定到其身份)替换为受害者的
   访问令牌。 此令牌被标识 API 接受,因为访问群体相对于资源服务器是正确的。 但是,
   由于标识 API 返回的标识符由访问令牌中的标识确定,因此攻击者会根据受害者的身份
   登录到目标应用程序。
 
   影响:攻击者获得对应用程序和应用程序中用户特定数据的访问权限。
 
   对策：
 
   o  客户端应使用适当的协议,如 OpenID (参合 [OPENID]) 或 SAML(参看
      [OASIS.sstc-saml 绑定-1.1]) 来实现用户登录。 两者都支持对客户端的受众
      限制。
 
4.4.3.  资源所有者密码凭据
 
   资源所有者密码凭据授予类型(请参阅 [RFC6749],第 4.3 节),通常用于旧版/迁移原因,
   允许客户端使用最终用户的用户 ID 和密码以及自己的凭据请求访问令牌。 此授予类型
   具有更高的风险,因为它维护 UID/密码反模式。  此外,由于用户无法控制授权过程,因此
   使用此授予类型的客户端不受范围限制,而是具有与用户本身相同的功能。 由于没有授权
   步骤,因此将绕过提供令牌吊销的能力。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 



 
   由于密码通常用于 1 个以上的服务,因此此反模式也可能使所提供的凭据可访问的任何其他
   内容都面临风险。此外,任何容易获得的等效项(例如joe@example.com和
   joe@example.net)都可能很容易让人猜测同一密码可以在其他地方使用。
 
   影响:资源服务器只能根据与特定客户端关联的访问令牌来区分作用域。 客户端还可以获取
   长生存令牌,并将它们传递给攻击者的 Web 服务以进行进一步滥用。 客户端、窃听者或
   终结点可能会窃听用户 ID 和密码。
 
   对策：
 
   o  除迁移原因外,尽量减少使用此授权类型。
 
   o  授权服务器应使用每个刷新请求验证与特定刷新令牌关联的客户端 ID
      (第 5.2.2.2 节)。
 
   o  根据 OAuth 核心规范,授权服务器必须确保使用传输层机制(如 TLS)保护这些传输
      (请参阅第 5.1.1 节)。
 
   o  服务提供商不应鼓励用户使用 UID 和密码,而应鼓励用户不要对多个服务使用相同的
      密码。
 
   o  将资源所有者密码凭据授予的使用限制为客户端应用程序和授权服务来自同一组织的
      情况。
 
4.4.3.1.  威胁:在客户端意外泄露密码
 
   如果客户端没有提供足够的保护,攻击者或心怀不满的员工可以检索用户的密码。
 
   对策：
 
   o  使用不依赖客户端协作进行安全资源所有者凭据处理的其他流程。
 
   o  使用摘要身份验证而不是纯文本凭据处理。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   o  在日志中模糊密码。
 
4.4.3.2.  威胁:客户端在没有最终用户授权的情况下获取作用域
 
   与资源所有者的所有交互都由客户端执行。因此,客户端可能会有意或无意地获取资源所有者
   未知或意外的作用域的令牌。 例如,资源所有者可能认为客户端需要并仅获取对其媒体存储
   的只读访问权限,但客户端尝试获取具有完全访问权限的访问令牌。
 
   对策：
 
   o  使用不依赖客户端合作进行资源所有者交互的其他流。
 
   o  授权服务器通常可以限制此流颁发的访问令牌的范围(第 5.1.5.1 节)。 如果特定
      客户端是可信的,并且可以以可靠的方式进行身份验证,则授权服务器可以放宽此限制。
      资源所有者可以规定(例如,在其首选项中)使用此流的客户端的最大范围。
 
   o  授权服务器可以通过适当的媒体(例如电子邮件)通知资源所有者发放的授予
      (参见第 5.1.3 节)。
 
4.4.3.3.  威胁:客户端通过自动授权获取刷新令牌
 
   与资源所有者的所有交互都由客户端执行。 因此,即使资源所有者不打算获得由刷新令牌
   表示的长期授权,客户端也可能有意或无意地获得授权。
 
   对策：
 
   o  使用不依赖客户端合作进行资源所有者交互的其他流程。
 
   o  授权服务器通常可能拒绝在此流中颁发刷新令牌(请参阅第 5.2.2.1 节)。 如果特定
      客户端是可信的,并且可以以可靠的方式进行身份验证(请参阅客户端身份验证),则授权
      服务器可以放宽此限制。 资源所有者也可以允许或拒绝(例如,在其首选项中)使用此
      流程颁发刷新令牌。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 

 
   o  授权服务器可以通过适当的媒体(例如电子邮件)通知资源所有者发出的刷新令牌
      (请参阅第 5.1.3 节)。
 
4.4.3.4.  威胁:在传输时获取用户密码
 
   攻击者可能尝试在客户端和服务器之间窃听使用授予类型"密码"的最终用户凭据的传输。
 
   影响:披露单个最终用户的密码。
 
   对策：
 
   o  确保请求的机密性(第 5.1.1 节)。
 
   o  使用替代身份验证意味着不需要通过无线方式发送纯文本凭据
      (例如,基于哈希的消息身份验证代码)。
 
4.4.3.5.  威胁:从授权服务器数据库获取用户密码
 
   攻击者可以通过访问数据库或发起 SQL 注入攻击,从授权服务器的数据库获取有效的
   用户名/密码组合。
 
   影响:披露所有用户名/密码组合。其影响可能会超出授权服务器的域,因为许多用户倾向于
   在不同的服务上使用相同的凭据。
 
   对策：
 
   o  实施凭据存储保护最佳实践(第 5.1.4.1 节)。
 
4.4.3.6.  威胁:在线猜测
 
   攻击者可能会尝试使用授权类型"密码"来猜测有效的用户名/密码组合。
 
   影响:单个用户名/密码组合的泄露。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   对策：
 
   o  使用安全密码策略(第 5.1.4.2.1 节)。
 
   o  锁定帐户(第 5.1.4.2.3 节)。
 
   o  Use tar pit (Section 5.1.4.2.4).
 
   o  使用验证码 (Section 5.1.4.2.5).
 
   o  虑不使用授权类型"password".
 
   o   客户端身份验证(请参阅第 5.2.3 节)将提供另一个身份验证因素,从而阻碍攻击。
 
4.4.4.  客户端凭据
 
   客户端凭据(参见 [RFC6749],第 3 节)由标识符(不是机密)与验证客户端的附加手段
   (如匹配的客户端机密)结合在一起。 此授予类型的威胁与第 4.4.3 节中所述的威胁类似。
 
4.5.  刷新访问令牌
 
4.5.1.  威胁:从授权服务器窃听刷新令牌
 
   攻击者可能会窃听刷新令牌,当它们从授权服务器传输到客户端时。
 
   对策：
 
   o  根据 OAuth 核心规范,授权服务器必须确保使用传输层机制(如 TLS)保护这些传输
      (参见第 5.1.1 节)。
 
   o  如果不能保证端到端机密性,则减少已颁发访问令牌的范围(见第 5.1.5.1 节)和到期
      时间(见第 5.1.5.3 节)可用于减少泄漏时的损害。
 
4.5.2.  威胁:从授权服务器数据库获取刷新令牌
 
   如果授权服务器将刷新令牌作为句柄存储在数据库中,则此威胁适用。 攻击者可以通过访问
   数据库或发起 SQL 注入攻击从授权服务器的数据库获取刷新令牌。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   影响:披露所有刷新令牌。
 
   对策：
 
   o  实施凭据存储保护最佳实践(第 5.1.4.1 节)。
 
   o  如果攻击者无法获得所需的 ID 和密钥(第 5.1.5.8 节),则将令牌绑定到客户端 ID。
 
4.5.3.  威胁:通过在线猜测获取刷新令牌
 
   攻击者可能会尝试猜测有效的刷新令牌值,并使用授予类型"refresh_token"发送该值,
   以便获取有效的访问令牌。
 
   影响:单个刷新令牌和可派生访问令牌的曝光。
 
   对策：
 
   o  用于基于句柄的设计(第 5.1.4.2.2 节)。
 
   o  对于基于断言的设计(第 5.1.5.9 节)。
 
   o  将令牌绑定到客户端 ID,因为攻击者也会猜测匹配的客户端 ID
      (请参阅第 5.1.5.8 节)。
 
   o  验证客户端;这添加了攻击者必须猜测的另一个元素(请参阅第 5.2.3.4 节)。
 
4.5.4.  威胁:通过伪造授权服务器刷新令牌网络钓鱼
 
   攻击者可能尝试通过将请求代理到授权服务器来获取有效的刷新令牌。 假设授权服务器
   URL 在开发时是众所周知的,或者至少可以从已知的资源服务器获取,则攻击者必须利用
   某种欺骗才能成功。
 
   对策：
 
   o  利用服务器身份验证(如第 5.1.2 节所述)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.6.  访问受保护资源
 
4.6.1.  威胁:在传输上窃听访问令牌
 
   攻击者可以尝试在客户端和资源服务器之间的传输上获取有效的访问令牌。 由于访问令牌
   是授权服务器和资源服务器之间的共享机密,因此应与其他凭据(例如最终用户密码)一样
   谨慎对待这些令牌。
 
   对策：
 
   o  作为承载令牌发送的访问令牌不应通过不安全通道以明文方式发送。根据核心OAuth
      规范，必须使用TLS等传输层机制保护接入令牌的传输(参见第5.1.1节)。
 
   o  短生存期可减少令牌泄露时的影响(参见第 5.1.5.3 节)。
 
   o  访问令牌可以绑定到客户端的标识符,并要求客户端证明令牌对资源服务器的合法所有权
      (请参阅第 5.4.2 节)。
 
4.6.2.  威胁:重播授权资源服务器请求
 
   攻击者可能会尝试重播有效请求以获取或修改/销毁用户数据。
 
   对策：
 
   o  资源服务器应利用传输安全措施(例如 TLS)来防止此类攻击(见第 5.1.1 节)。
      这将阻止攻击者捕获有效的请求。
 
   o  或者,资源服务器可以使用签名的请求(参见第 5.4.3 节)以及随机字符串和时间戳,
      以便唯一地标识请求。 资源服务器应检测并拒绝每个重播的请求。
 
4.6.3.  威胁:猜测访问令牌
 
   如果令牌是句柄,攻击者可能会尝试根据他们从其他访问令牌获得的知识来猜测访问令牌值。
 
   影响:访问单个用户的数据。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   对策：
 
   o  句柄令牌应具有合理的熵级别(请参阅第 5.1.4.2.2 节),以使猜测有效的令牌值
      不可行。
 
   o  断言(或自包含令牌)令牌内容应受数字签名保护(请参阅第 5.1.5.9 节)。
 
   o  通过使用较短的访问令牌持续时间可以进一步加强安全性
      (请参阅第 5.1.5.2 节和 5.1.5.3 节)。
 
4.6.4.  威胁:假冒资源服务器访问令牌网络钓鱼
 
   攻击者可能伪装成特定资源服务器,并接受来自特定授权服务器的令牌。 如果客户端向此
   仿冒资源服务器发送有效的访问令牌,则服务器可能反过来使用该令牌代表资源所有者访问
   其他服务。
 
   对策：
 
   o  客户端不应使用访问令牌向不熟悉的资源服务器发出经过身份验证的请求,而不管是否
      存在安全通道。 如果客户端熟知资源服务器 URL,它可能会对资源服务器进行身份验证
      (请参阅第 5.1.2 节)。
 
   o  将客户端与之通信的资源服务器的终结点 URL 与访问令牌(例如,在访问群体字段中)
      相关联,并在合法的资源服务器上验证关联。 节点 URL 验证策略可能很严格(完全
      匹配)或更宽松(例如,同一主机)。 这将需要在授权过程中告知授权服务器有关资源
      服务器节点 URL 的信息。
 
   o  将访问令牌与客户端关联,并将客户端与资源服务器请求进行身份验证(通常通过签名,
      以便不向潜在攻击者泄露机密)。 这可以防止攻击,因为假定仿冒服务器缺乏代表资源
      服务器的合法客户端进行正确身份验证的能力(第 5.4.2 节)。
 
   o  限制令牌范围(请参阅第 5.1.5.1 节)和/或将令牌限制为特定资源服务器
      (第 5.1.5.5 节)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
4.6.5.  威胁:合法资源服务器或客户端滥用令牌
 
   合法的资源服务器可以尝试使用访问令牌访问另一个资源服务器。 同样,客户端可以尝试
   使用为另一个资源服务器上的一台服务器获取的令牌。
 
   对策：
 
   o  令牌应限制为特定的资源服务器(请参阅第 5.1.5.5 节)。
 
4.6.6.  威胁:HTTP 代理中机密数据泄露
 
   [RFC6749] 中讨论的 OAuth HTTP 身份验证方案是可选的。 但是,[RFC2616] 依赖于
   授权和 WWW-Authenticate标头来区分经过身份验证的内容,以便可以对其进行保护。 
   特别是,代理和缓存可能无法充分保护不使用这些标头的请求。 例如,私有身份验证的内容
   可以存储在(因此可以从)可公开访问的缓存中检索。
 
   对策：
 
   o  不使用 OAuth HTTP 身份验证方案的客户端和资源服务器(请参阅第 5.4.1 节)应
      注意使用缓存控制标头,以最大程度地降低经过身份验证的内容不受保护的风险。 此类
      客户端应发送包含"no-store"选项 [RFC2616] 的Cache-Control标头。资源
      服务器成功(2XX 状态)对这些请求的响应应包含具有"private"选项 [RFC2616] 的
      Cache-Control Header。
 
   o  减少访问令牌的范围(见第 5.1.5.1 节)和到期时间(第 5.1.5.3 节)可用于减少
      泄漏时的损害。
 
4.6.7.  威胁:通过日志文件和 HTTP 引用器的令牌泄漏
 
   如果访问令牌通过 URI 查询参数发送,则此类令牌可能会泄漏到日志文件和 
   HTTP "referer"。
 
   对策：
 
   o  使用授权标头或 POST 参数而不是 URI 请求参数(请参阅第 5.4.1 节)。
 
   o  适当地设置日志记录配置。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   o  防止未经授权的人员访问系统日志文件(参见第 5.1.4.1.1 节)。
 
   o  通过强制实施经过身份验证的请求,可以防止滥用泄露的访问令牌
      (请参阅第 5.4.2 节)。
 
   o  通过限制范围(参见第 5.1.5.1 节)和持续时间(参见第 5.1.5.3 节)以及强制实施
      一次性令牌使用(请参阅第 5.1.5.4 节),可以减少令牌泄漏的影响。
 
5.  安全注意事项
 
   本节介绍建议缓解第 4 节中所述威胁的对策。
 
5.1.  General
 
   本节介绍通常适用于所有 OAuth 组件(客户端、资源服务器、令牌服务器和用户代理)的
   注意事项。
 
5.1.1.  确保请求的机密性
 
   这适用于从客户端发送到授权服务器或资源服务器的所有请求。 虽然 OAuth 提供了一种
   验证请求完整性的机制,但它不保证请求的机密性。 除非采取进一步预防措施,否则窃听者
   将具有对请求内容的完全访问权限,并且可以使用请求的内容(例如,机密或令牌)发起拦截或
   重播攻击。
 
   通过使用传输层机制(如 TLS [RFC5246])可以缓解攻击。 虚拟专用网络 (VPN), 例如,
   基于 IPsec VPN [RFC4301], 也可以考虑.
 
   注意:本文档假定各个协议实体之间的端到端 TLS 受保护连接。 通过卸载 TLS(例如,在
   数据中心边缘)来偏离此假设的部署必须优化此威胁模型,以便考虑到可能导致的额外(主要
   是内部人员)威胁。
 
   这是针对以下威胁的对策:
 
   o  重播在令牌的终结点或资源服务器的节点上获取的访问令牌
 
   o  重放在令牌终结点上获取的刷新令牌</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   o  在令牌节点上重播获取的授权"code"(重定向?)
 
   o  重播用户密码和客户端机密
 
5.1.2.  利用服务器身份验证
 
   HTTPS 服务器身份验证或类似方法可用于验证服务器的标识。 目标是可靠地将服务器的
   完全限定域名绑定到服务器在建立连接期间提供的公钥(请参阅 [RFC2818])。
 
   客户端应验证服务器对其域名的绑定。 如果服务器无法证明绑定,则通信将被视为中间人
   攻击。 此安全措施取决于客户端为此目的信任的证书颁发机构。 客户端应仔细选择这些
   受信任的 CA,并保护受信任 CA 证书的存储免受修改。
 
   这是针对以下威胁的对策:
 
   o  欺骗
 
   o  代理
 
   o  仿冒服务器网络钓鱼
 
5.1.3.  始终通知资源所有者
 
   资源所有者的透明度是 OAuth 协议的关键元素。 用户应始终控制授权过程,并获得必要的
   信息以做出明智的决策。 此外,用户参与是一种进一步的安全对策。 用户可能比授权服务器
   更能识别某些类型的攻击。 信息可以在授权过程中、授权过程之后以及每次用户希望通过
   使用以下技术获得通知时提供/交换:
 
   o  用户同意书。
 
   o  通知消息(例如,电子邮件、短信等)。 请注意,通知可以是网络钓鱼媒介。 邮件应使
      类似网络钓鱼邮件无法从它们派生。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   o  活动/事件日志。
 
   o  用户自助应用程序或门户。
 
5.1.4.  凭据
 
   本节介绍用于保护所有类型的凭据免受未经授权的访问和滥用的对策。凭据是长期机密,例如
   客户端密钥和用户密码,以及所有类型的令牌(刷新和访问令牌)或授权"codes".
 
5.1.4.1.  实施凭据存储保护最佳实践
 
   管理员应采用行业最佳实践来保护凭据的存储(例如,请参阅 [OWASP])。 此类做法可包括
   但不限于以下内容。
 
5.1.4.1.1.  施标准系统安全手段
 
   服务器系统可能被锁定,因此攻击者无法访问敏感的配置文件和数据库。
 
5.1.4.1.2.  实施标准 SQL 注入对策
 
   如果查询客户端标识符或其他身份验证组件或与 SQL 数据库进行比较,则如果在提交到
   数据库之前未验证收到的参数,则可能发生注入攻击。
 
   o  确保服务器代码使用可能的最低数据库权限来减少可能攻击的"surface"。.
 
   o  避免使用串联输入进行动态 SQL。 如果可能,请使用静态 SQL。
 
   o  使用动态 SQL 时,使用绑定参数参数化查询。绑定参数消除了 SQL 注入的可能性。
 
   o  过滤并清理输入。 例如,如果标识符具有已知格式,请确保提供的值与标识符语法规则
      匹配。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
5.1.4.1.3.  凭据的明文存储
 
   授权服务器不应以明文形式存储凭据。典型的方法是存储哈希或加密凭据。如果凭据缺少
   合理的熵级别(因为它是用户密码),则额外的salt会强化存储,使脱机字典攻击更加困难。
 
   注意：一些身份验证协议要求授权服务器可以明文访问机密。如果服务器只能访问散列，则
   无法实现这些协议。在这些情况下，应该对凭据进行严格加密。
 
5.1.4.1.4.  凭据加密
 
   对于客户端应用程序,不安全地持久化客户端凭据很容易成为攻击者获取的目标。使用加密的
   持久性机制(如密钥库或数据库)存储客户端凭据。请注意,将客户端凭据直接编译到客户端
   代码中会使客户端应用程序容易受到扫描,如果客户端凭据随时间而变化,则难以管理。
 
5.1.4.1.5.  非对称加密的使用
 
   使用非对称加密将免除授权服务器管理凭据的义务。
 
5.1.4.2.  对密钥的在线攻击
 
5.1.4.2.1.  使用安全密码策略
 
   授权服务器可能决定强制实施复杂的用户密码策略,以增加用户密码的熵以阻止联机密码
   攻击。 请注意,复杂性过大会增加用户重复使用密码或将其写下来的可能性,或者不安全地
   存储密码。
 
5.1.4.2.2.  对密钥使用高熵
 
   当创建不打算由人类用户使用的密钥(例如，客户端密钥或令牌句柄)时，授权服务器应该
   包括合理水平的熵，以便减轻猜测攻击的风险。令牌长度应大于等于128，并由授权服务器
   生成的加密强随机或伪随机数序列(参见[RFC4086]了解当前最佳实践)构建。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
5.1.4.2.3.  锁定帐户
 
   通过锁定相应帐户,在一定数量的尝试失败后,可以缓解对密码的在线攻击。
 
   注意:此措施可能会被滥用来锁定合法的服务用户。
 
5.1.4.2.4.  Use Tar Pit
 
   授权服务器可能会对通过用户名/密码进行身份验证的失败尝试做出反应,为此会暂时锁定
   相应的帐户并将响应延迟一定持续时间。 此持续时间可能会随着失败的尝试次数而增加。
   目的是减慢攻击者对某个用户名的尝试。
 
   注意:这可能需要对授权服务器进行更复杂的、有状态的设计。
 
5.1.4.2.5.  使用验证码
 
   其理念是,通过要求人工交互,防止程序自动检查大量密码。
 
   注意:这对用户体验有负面影响。
 
5.1.5.  令牌(Access, Refresh, Code)
 
5.1.5.1.  限制令牌范围
 
   授权服务器可以决定减少或限制与令牌相关联的范围。此决定的依据超出范围；例如：
 
   o  特定于客户端的策略,例如,仅向公共客户端颁发功能较弱的令牌,
 
   o  特定于服务的策略,例如,它是一项非常敏感的服务,
 
   o  特定于资源所有者的设置,或
 
   o  此类政策和偏好的组合。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   授权服务器可能允许不同的作用域,具体取决于授予类型。 例如,通过与最终用户直接交互
   (授权"code")的最终用户授权可能被认为比通过授予类型"username"/"password"直接
   授权更可靠。 这意味着将减少以下威胁的影响:
 
   o  令牌泄漏
 
   o  向恶意软件颁发令牌
 
   o  意外颁发具有资源所有者凭据流的功能强大的令牌
 
5.1.5.2.  确定过期时间
 
   令牌通常在合理的持续时间后过期。 这补充并加强了其他安全措施(如签名),并减少了各种
   令牌泄漏的影响。根据与令牌泄漏相关的风险,令牌可能会在几分钟后过期(例如,对于付款
   交易),或持续数小时(例如,对联系人的读取访问)。
 
   过期时间由以下几个因素决定:
 
   o  与令牌泄漏相关的风险,
 
   o  基础访问授予的持续时间,
 
   o  在修改访问授权应生效之前的持续时间,以及
 
   o  攻击者猜测或生成有效令牌所需的时间。
 
5.1.5.3.  使用较短的过期时间
 
   令牌的短暂过期时间是抵御以下威胁的一种保护手段:
 
   o  重播
 
   o  令牌泄漏(较短的过期时间将减少影响)
 
   o  在线猜测(短暂的过期时间将减少成功的可能性)</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   注意:较短的令牌持续时间要求在授权服务器和资源服务器之间实现更精确的时钟同步。
   此外,较短的持续时间可能需要更多令牌刷新(访问令牌)或重复的最终用户授权过程
   (授权"code"和刷新令牌)。
 
5.1.5.4.  限制使用量或一次性使用次数
 
   授权服务器可能会限制可以使用特定令牌执行的请求或操作的数量。 此机制可用于缓解
   以下威胁:
 
   o  令牌的重播
 
   o  猜测
 
   例如,如果授权服务器观察到多个尝试兑换授权"code",则授权服务器可能希望撤销基于
   授权"code"授予的所有访问令牌,并拒绝当前请求。
 
   与授权"code"一样,访问令牌的操作数量可能有限。 这要么强制客户端应用程序重新进行
   身份验证并使用刷新令牌来获取新的访问令牌,要么强制客户端通过让用户参与重新授权
   访问令牌。
 
5.1.5.5.  将令牌绑定到特定资源服务器(用户)
 
   多服务环境中的授权服务器可以考虑向不同的资源服务器颁发具有不同内容的令牌,并在令牌
   中明确指示要向其发送令牌的目标服务器。 SAML 断言(请参阅[OASIS.saml-core-2.0-
   os])为此目的使用受众元素。此对策可用于以下情况:
 
   o  它减少了成功重播尝试的影响,因为令牌仅适用于单个资源服务器。
 
   o  它可以防止恶意资源服务器或客户端滥用令牌,因为令牌只能在该服务器上使用。 
      它被其他服务器拒绝。
 
   o  它减少了将有效令牌泄漏到仿冒资源服务器的影响。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
5.1.5.6.  使用端点地址作为令牌受众
 
   这可用于向资源服务器指示已使用节点 URL 获取令牌。 此措施将允许检测来自仿冒资源
   服务器的请求,因为此类令牌将包含该服务器的节点 URL。
 
5.1.5.7.  对受众和令牌使用显式定义的作用域
 
   部署可能只考虑使用具有显式定义作用域的令牌,其中每个作用域都与特定资源服务器相
   关联。此方法可用于缓解资源服务器或客户端使用令牌用于与预期用途不同的令牌的攻击。
 
5.1.5.8.  将令牌绑定到客户端 ID
 
   授权服务器可能会将令牌绑定到特定的客户端标识符。 应使用该令牌为每个请求验证此
   标识符。 此技术可用于
 
   o  检测令牌泄漏和
 
   o  防止令牌滥用。
 
   注意:验证客户端标识符可能需要目标服务器对客户端的标识符进行身份验证。此身份验证
   可以基于独立于令牌管理的密钥(例如,在授权服务器上预先注册的客户端 ID/密钥)或随
   令牌本身一起发送(例如,作为加密令牌内容的一部分)。
 
5.1.5.9.  签名自包含令牌
 
   应对自包含令牌进行签名,以便检测任何修改或生成虚假令牌的尝试(例如,基于哈希的消息
   身份验证代码或数字签名)。
 
5.1.5.10.  加密令牌内容
 
   出于保密原因或为了保护系统内部数据,可以对自包含令牌进行加密。 根据令牌格式,密钥
   (例如对称密钥)可能必须在服务器节点之间分配。分发方法应由令牌和使用的加密定义。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
5.1.5.11.  采用标准断言格式
 
   对于打算实现基于断言的令牌设计的服务提供商,强烈建议采用标准断言格式
   (如 SAML [OASIS.saml-core-2.0-os] 或 JavaScript Object Notation Web
   Token(JWT) [OAuth-JWT])。
 
5.1.6.  访问令牌
 
   应使用以下措施来保护访问令牌:
 
   o  将它们保存在瞬态内存中(仅由客户端应用程序访问)。
 
   o  使用安全传输 (TLS) 安全地传递令牌。
 
   o  确保客户端应用程序不与第三方共享令牌。
 
5.2.  授权服务器
 
   本节介绍与 OAuth 授权服务器终结点相关的注意事项。
 
5.2.1.  授权"codes"
 
5.2.1.1.  如果检测到滥用,则自动吊销派生令牌
 
   如果授权服务器观察到多次尝试兑换授权授予(例如,授权"codes"),则授权服务器可能
   需要撤销根据授权授予授予的所有令牌。
 
5.2.2.  刷新令牌
 
5.2.2.1.  限制发行刷新令牌
 
   授权服务器可以根据适当的策略决定不颁发刷新令牌。 由于刷新令牌是长期凭据,因此可能
   会被盗。 例如,如果授权服务器不信任客户端安全地存储此类令牌,则它可能拒绝向此类客户
   端颁发刷新令牌。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
5.2.2.2.  将刷新令牌绑定到 "client_id"
 
   授权服务器应将每个刷新令牌与向其发出令牌的客户端的标识符匹配。 授权服务器应检查
   每个刷新访问令牌的请求是否都具有相同的"client_id"。 如果可能(例如机密客户端),
   授权服务器应对相应的客户端进行身份验证。
 
   这是防止刷新令牌被盗或泄漏的对策。
 
   注意:此绑定应受到保护,防止未经授权的修改。
 
5.2.2.3.  刷新令牌旋转
 
   刷新令牌轮换旨在自动检测和防止尝试从不同的应用/设备并行使用相同的刷新令牌。 如果
   令牌从客户端被盗,随后被攻击者和合法客户端使用,则会发生这种情况。基本思想是随着
   每个刷新请求改变刷新令牌值,以便检测使用旧刷新令牌获取访问令牌的尝试。由于授权
   服务器无法确定攻击者或合法客户端是否正在尝试访问,因此,在此类访问尝试的情况下,
   将吊销有效的刷新令牌和与其关联的访问授权。
 
   OAuth规范支持这种措施,因为令牌的响应允许授权服务器返回新的刷新令牌,即使对于
   具有授予类型"refresh_token"的请求也是如此。
 
   注意：此措施可能会导致集群环境中出现问题，因为必须确保使用当前有效的刷新令牌。在
   这样的环境下，其他措施可能更合适。
 









5.2.2.4.  撤销刷新令牌
 
   授权服务器可能允许客户端或最终用户显式请求刷新令牌的失效。 
   [OAuth-REVOCATION] 中指定了撤销令牌的机制。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   这是针对:
 
   o  设备失窃,
 
   o  模拟资源所有者,或
 
   o  可疑客户端应用程序被入侵。
 
5.2.2.5.  设备标识
 
   授权服务器可能需要将身份验证凭据绑定到设备标识符。 国际移动站设备标识 [IMEI] 
   就是此类标识符的一个示例;还有特定于操作系统的标识符。 授权服务器在验证用户凭据时
   可以包含此类标识符,以便检测来自特定设备的令牌被盗。
 
   注意:任何实现都应考虑使用设备标识符的潜在隐私影响。
 
5.2.2.6.  X-FRAME-OPTIONS Header
 
   对于较新的浏览器,可以使用 X-FRAME-OPTIONS 标头在服务器端强制避免 iFrame
   (请参阅 [X-Frame-Options])。 此标头可以有两个值,"DENY"和"SAMEORIGIN",
   将分别阻止具有不同源的站点的任何框架或iFrame。 值"ALLOW-FROM"指定 iFrame 
   可能源自的受信任源的列表。
 
   这是针对以下威胁的对策:
 
   o  点击劫持攻击
 
5.2.3.  客户端身份验证和授权
 
   如第 3 节(安全功能)所述,客户端被识别、验证和授权用于多种目的,例如:
 
   o  整理对同一客户端的请求,
 
   o  向用户指示客户端由授权服务器识别,
 
   o  授权客户端访问授权服务器或资源服务器上的某些功能,以及
 
   o  将客户端标识符记录到日志文件以进行分析或统计。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   由于不同客户端类型的功能和特征不同,支持这些目标的方法也不同,本节将对此进行介绍。
   授权服务器提供商应了解特定客户端的安全策略和部署,并相应地调整其处理。 例如,一种
   方法可能是将所有客户端视为不太可信和不安全。 另一方面,服务提供商可以由管理员单独
   激活每个客户端安装,从而获得对软件包标识和安装客户端的环境安全性的信心。中间有
   几种方法。
 
5.2.3.1.  不要向具有不当安全策略的客户发布密钥
 
   授权服务器不应向无法保护密钥("public"客户端)的客户端颁发密钥。 这降低了服务器
   将客户端视为经过强身份验证的可能性。
 
   例如,创建由本机应用程序的所有安装共享的单个客户端 ID 和密钥的好处有限。 此类方案
   要求此密钥必须通过相应的分发渠道(例如应用程序市场)从开发人员传输到最终用户设备上
   的应用程序的所有安装。 已刻录到应用程序或关联资源包的源代码中的密钥不受反向工程
   保护。 第二,不能撤销这些密钥,因为这会立即使所有安装停止工作。此外,由于授权服务器
   不能真正信任客户端的标识符,因此向最终用户指示客户端的可信度是危险的。
 
   还有其他方法可以实现合理的安全级别,如以下各节所述。
 














5.2.3.2.  要求没有密钥的公共客户端的用户同意
 
   授权服务器不应允许公共客户端的自动授权。 授权服务器可能会颁发单个客户端 ID,但应
   要求最终用户批准所有授权。 对于没有密钥的客户端,这是针对以下威胁的对策:
 
   o  模拟公共客户端应用程序。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
5.2.3.3.  仅在与“redirect_uri”组合时发出“client_id”
 
   授权服务器可能会发出"client_id",并将"client_id"绑定到特定预配置的
   "redirect_uri"。 使用其他重定向 URI 的任何授权请求将自动被拒绝。 或者,授权
   服务器不应接受此类"client_id"的任何动态重定向 URI,而应始终重定向到已知预先配置
   的重定向 URI。  对于没有密钥的客户端,这是针对以下威胁的对策:
 
   o  跨站点脚本攻击
 
   o  模拟公共客户端应用程序
 
5.2.3.4.  发布特定于安装的客户端密钥
 
   授权服务器可能会向特定客户端的不同安装(即软件包)发出单独的客户端标识符和相应的
   密钥。 这种方法的效果是把其他"public"客户端变成"机密"客户端。
 
   对于 Web 应用程序,这可能意味着为安装软件包的每个网站创建一个"client_id"和
   "client_secret"。 因此,该特定站点的提供商可以在网站设置期间从授权服务器请求
   客户端 ID 和密钥。 这还允许验证该网站的某些属性,例如重定向 URI、网站 URL 和
   其他任何证明有用的内容。 网站提供商必须确保站点上的客户端机密的安全性。
 
   对于本机应用程序,事情更加复杂,因为任何设备上特定应用程序的每个副本都是不同的安装。
   在此方案中,特定于安装的机密需要获取"client_id"和"client_secret",或者
 
   1.  在从应用程序市场下载的过程中,或
 
   2.  在设备上安装期间。
 
   这两种方法都需要一个自动机制来颁发客户端 ID 和机密,目前 OAuth 尚未定义该机制。
 
   第一种方法将允许对应用程序的真实性实现一定程度的信任,而第二个选项仅允许对安装进行
   身份验证,而不允许验证客户端的属性。 但这至少有助于防止多次重播攻击。 此外,特定于
   安装的"client_id"和密钥允许一次有选择地吊销特定安装的所有刷新令牌。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 



 
5.2.3.5.  验证预注册 "redirect_uri"
 
   授权服务器应该要求所有客户端注册他们的“redirect_uri”，并且“redirect_uri”
   应该是[RFC6749]中定义的完整URI。执行此注册的方式超出了本文档的范围。根据核心
   规范，与相应的“client_id”一起发送到最终用户授权端点的每个实际重定向URI必须与
   注册的重定向URI匹配。在不匹配的情况下，授权服务器应假定入站GET请求由攻击者发送，
   并拒绝该请求。注意：授权服务器不应将用户代理重定向回此类授权请求的重定向URI。
   验证预先注册的“redirect_uri”是针对以下威胁的对策：
 
   o  授权"code"通过假冒网站泄漏:允许授权服务器在第一次重定向到最终用户授权节点
      后检测攻击尝试(第 4.4.1.7 节)。
 
   o  通过客户端重定向节点打开重定向控制器攻击(第 4.1.5 节)。
 
   o  通过授权服务器重定向节点打开重定向者网络钓鱼攻击(第 4.2.4 节)。
 
   此度量值的基本假设是,攻击者将需要使用另一个重定向 URI 才能访问授权"code"。
   部署可能会考虑攻击者使用欺骗攻击来规避此安全措施的可能性。
 
   注意:预注册客户端可能无法在某些部署(手动过程)中扩展,或者需要动态客户端注册(尚未
   指定)。 由于缺少动态客户端注册,预注册的"redirect_uri"仅适用于在开发/配置时
   绑定到某些部署的客户端。 一旦需要动态资源服务器发现,预先注册的"redirect_uri"
   可能不再可行。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
5.2.3.6.  撤销客户端密钥
 
   授权服务器可能会撤消客户端的密钥,以防止滥用泄露的密钥。
 
   注意:此措施将立即使颁发给相应客户端的任何授权"code"或刷新令牌无效。这可能无意中
   影响客户端标识符和在特定本机或 Web 应用程序的多个部署中使用的密钥。
 
   这是针对:
 
   o  滥用私人客户泄露的客户密钥
 
5.2.3.7.  使用强客户端身份验证(例如,客户端断言/客户端令牌)
 
   通过使用其他身份验证形式(如客户端断言 [OAuth-ASSERTIONS]),消除了分发
   "client_secret"的需要。 这可能需要使用客户端断言颁发者在其身份验证过程中指定
   安全私钥存储或其他补充身份验证系统。
 
5.2.4.  最终用户授权
 
   本节包括涉及最终用户的授权流的注意事项。
 
5.2.4.1.  自动处理重复授权需要客户端验证
 
   授权服务器不应自动处理未通过客户端机密或某些其他身份验证机制(如已签名的身份验证
   断言证书(第5.2.3.7节)或预先注册的重定向URI的验证(第5.2.3.5节)对客户端进行
   身份验证的重复授权。
 
5.2.4.2.  基于透明度的知情决定
 
   授权服务器应向最终用户清楚地解释授权过程中发生的情况以及后果。例如,用户应了解他
   要授予哪个客户端的访问权限。用户还应清楚服务器是否能够可靠地验证某些客户端属性
   (网站 URL、安全策略)。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
5.2.4.3.  最终用户验证客户端属性
 
   在授权过程中，通常会要求用户批准客户端的授权请求。这本身就是一种重要的安全机制，
   因为最终用户可以参与客户端属性的验证，例如授权服务器已知的客户端名称是否与最终
   用户正在使用的网站或应用程序的名称相匹配。在授权服务器无法对客户端进行身份验证的
   情况下，此措施特别有用。 这是针对:
 
   o  恶意应用程序
 
   o  伪装成另一个客户端的客户端应用程序
 
5.2.4.4.  授权"code" 绑定 "client_id"
 
   授权服务器应将每个授权"code"绑定到启动最终用户授权过程的相应客户端的 ID。 
   这项措施是针对:
 
   o  使用不同的客户端凭据重播授权"code",因为攻击者无法使用另一个"client_id"将
      授权"code"交换到令牌中
 
   o  在线猜测授权"codes"
 
   注意:应防止此绑定免受未经授权的修改(例如,使用受保护的内存和/或安全数据库)。
 
5.2.4.5.  授权"code" 绑定 "redirect_uri"
 
   授权服务器应该能够将每个授权"code"绑定到在最终用户授权过程中用作客户端重定向
   目标的实际重定向 URI。 当客户端尝试将相应的授权"code"交换访问令牌时,应验证此
   绑定。 此措施是防止授权"code" 通过假冒网站泄漏的对策,因为攻击者无法使用另一个
   重定向 URI 将授权"code"交换到令牌中。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
5.3.  客户端应用程序安全性
 
   本节讨论客户端应用程序的注意事项。
 
5.3.1.  不要将凭据存储在与软件包捆绑的代码或资源中
 
   由于客户端软件的副本数,创建单个客户端 ID 和由应用程序的所有安装共享的密钥的好处
   有限。 此类应用程序本身将被视为"公共"客户端,因为它不能假定能够保护客户端密钥。
   无法保护已刻录到应用程序或关联资源包的源代码中的密钥,无法防止反向工程。 第二,
   不能撤销这些密钥,因为这会立即使所有安装停止工作。 此外,由于授权服务器不能真正
   信任客户端的标识符,因此向最终用户指示客户端的可信度是危险的。
 
5.3.2.  使用标准 Web 服务器保护措施(用于配置文件和数据库)
 
   使用标准 Web 服务器保护和配置措施来保护服务器、数据库、配置文件和服务器的其他
   操作组件的完整性。
 
5.3.3.  将密钥存储在安全存储中。
 
   有不同方法在设备或服务器上安全地存储所有类型的机密(令牌、客户端密钥)。
 
   大多数多用户操作系统将不同系统用户的个人存储隔离。 此外,大多数现代智能手机操作
   系统甚至支持将特定于应用程序的数据存储在文件系统的单独区域,并保护数据不被其他
   应用程序访问。 此外,应用程序可以使用用户提供的密钥(如 PIN 或密码)来实现机密
   数据。
 
   另一个选项是将刷新令牌存储交换到受信任的后端服务器。 此选项又要求在客户端和后端
   服务器之间建立弹性身份验证机制。 注意:应用程序应确保机密数据即使在从安全存储读取
   后仍保密,这通常意味着将这些数据保存在应用程序的本地内存中。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
5.3.4.  利用设备锁定防止未经授权的设备访问
 
   在典型的现代手机上,有许多"设备锁定"选项可用于在设备被盗或放错位置时提供额外保护。
   其中包括 PIN、密码和其他生物识别功能,如"人脸识别"。 在它们提供的安全级别上,这些
   不相等。
 
5.3.5.  将"state"参数链接到用户代理session
 
   "state"参数用于链接客户端请求和防止 CSRF 攻击,例如,对重定向 URI 的攻击。 
   攻击者可以注入自己的授权"code"或访问令牌,这可能导致客户端使用与攻击者受保护资源
   关联的访问令牌,而不是受害者的访问令牌(例如,将受害者的银行帐户信息保存到由攻击者
   控制的受保护资源)。
 
   客户端应在重新进行授权时使用"state"请求参数向授权服务器发送将请求绑定到用户代理
   的身份验证状态的值(例如,用于验证用户代理的会话 Cookie 的哈希值)追求。从最终用户
   获得授权后,授权服务器将最终用户的用户代理重定向回客户端,其中包含"状态"参数中所需
   的绑定值。
 
   绑定值使客户端能够通过将绑定值与用户代理的身份验证状态匹配来验证请求的有效性。
 
5.4.  资源服务器
 
   以下部分详细介绍了资源服务器的安全注意事项。
 
5.4.1.  Authorization Headers
 
   HTTP 代理和服务器可识别并特别处理授权标头。 因此,使用此类标头将访问令牌发送到
   资源服务器可降低一般经过身份验证的请求(尤其是授权标头)泄漏或意外存储的可能性。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
5.4.2.  验证请求
 
   授权服务器可能会将令牌绑定到特定客户端标识符,并使资源服务器能够在资源访问时验证
   该关联。 这将要求资源服务器将请求的发起者验证为特定令牌的合法所有者。有几个选项
   可以实现此对策:
 
   o  授权服务器可以将客户端标识符与令牌关联(内部或自包含令牌的有效负载)。 然后,
      客户端在资源服务器的节点上使用基于客户端证书的 HTTP 身份验证来验证其标识,
      并且资源服务器使用令牌引用的名称验证名称。
 
   o  与上述选项相同,但客户端使用其私钥对资源服务器的请求进行签名(公钥要么包含在
      令牌中,要么随请求一起发送)。
 
   o  或者,授权服务器可能会发出令牌绑定密钥,客户端在密钥持有者证明中使用密钥验证
      客户端对令牌的使用。 资源服务器直接从授权服务器获取密钥,或者该密钥包含在令牌
      的加密部分中。 这样,资源服务器不会"知道"客户端,但能够验证授权服务器是否向该
      客户端颁发了令牌。
 
   已验证的请求是防止假冒资源服务器滥用令牌的对策。
 
5.4.3.  签名请求
 
   资源服务器可能决定仅接受已签名的请求,以替换传输级安全措施或补充此类措施。 每个
   签名的请求都应是唯一的标识,并且不应由资源服务器处理两次。 此对策有助于缓解:
 
   o  对消息的修改和
 
   o  重播尝试</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
5.5.  关于用户交互和用户安装应用的提示
 
   O  Auth 作为一种安全协议,其独特之处在于其流程通常涉及重要的用户交互,使最终用户
      成为安全模型的一部分。 这给防御上述一些威胁造成了一些重要困难。 其中一些观点
      已经提出,但值得在这里重复和强调。
 
   o  最终用户必须了解他们被要求批准的内容(请参阅第 5.2.4.2 节)。 用户通常无法
      理解对授权请求说"是"的后果,并且可能无法看到请求措辞的细微差异。 恶意软件会
      混淆用户,诱使用户批准几乎所有内容。
 
   o  最终用户设备容易出现软件泄露。 这是一个长期存在的问题,经常攻击 Web 浏览器和
      用户系统的其他部分。 但是,随着用户安装的"应用程序"的日益普及,受攻击或恶意的
      最终用户软件构成的威胁非常强烈,而且很难缓解。
 
   o  请注意,用户将要求安装和运行此类应用,并且受攻击或恶意应用可能会在数据流程中的
      多个点窃取凭据。 它们可以截获 OAuth 旨在保护的用户登录凭据。 他们可以请求的
      授权远远超出他们导致用户理解和批准的范围。 他们可以代表用户自动执行响应,隐藏
      整个过程。 这里没有提供任何解决方案,因为没有一个解决方案是已知的;这仍然位于
      更好的安全性和更好的可用性之间。
 
   o  通过限制用户安装的软件的使用来解决这些问题在某些有限的环境中可能是可行的,在
      这些情况下可用作对策。 这种限制在一般情况下并不实际,应当建立事后恢复机制。
 
   o  虽然最终用户大多无法正确审查他们加载到其设备上的应用程序,但部署授权服务器的
      用户可能拥有可处置的工具来缓解恶意客户端。 例如,运行良好的授权服务器必须仅向
      能够有效验证的最终用户断言客户端属性,显式指出无法验证的属性,并向最终用户指示
      与授予访问权限相关的风险到特定客户端。</pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
6.  Acknowledgements
 
   We would like to thank Stephen Farrell, Barry Leiba, Hui-Lan Lu,   Francisco Corella, Peifung E. Lam, Shane B. Weeden, Skylar Woodward,   Niv Steingarten, Tim Bray, and James H. Manger for their comments and   contributions.
 
7.  References
 
7.1.  Normative References
 
   [RFC6749]  Hardt, D., "The OAuth 2.0 Authorization Framework",              RFC 6749, October 2012.
 
   [RFC6750]  Jones, M. and D. Hardt, "The OAuth 2.0 Authorization              Framework: Bearer Token Usage", RFC 6750, October 2012.
 
7.2.  Informative References
 
   [Framebusting]
              Rydstedt, G., Bursztein, Boneh, D., and C. Jackson,
              "Busting Frame Busting: a Study of Clickjacking
              Vulnerabilities on Popular Sites", IEEE 3rd Web 2.0
              Security and Privacy Workshop, May 2010, <http: elie.im="" publication="" busting-frame-busting-a-study-of-="" clickjacking-vulnerabilities-on-popular-sites="">.

   [IMEI]     3GPP, "International Mobile station Equipment Identities
              (IMEI)", 3GPP TS 22.016 11.0.0, September 2012,
              <http: www.3gpp.org="" ftp="" specs="" html-info="" 22016.htm="">.

   [OASIS.saml-core-2.0-os]
              Cantor, S., Ed., Kemp, J., Ed., Philpott, R., Ed., and E.
              Maler, Ed., "Assertions and Protocols for the OASIS
              Security Assertion Markup Language (SAML) V2.0", OASIS
              Standard saml-core-2.0-os, March 2005,
              <http: docs.oasis-open.org="" security="" saml="" v2.0="" saml-core-2.0-os.pdf="">.

   [OASIS.sstc-saml-bindings-1.1]
              Maler, E., Ed., Mishra, P., Ed., and R. Philpott, Ed.,
              "Bindings and Profiles for the OASIS Security Assertion
              Markup Language (SAML) V1.1", September 2003,
              <http: www.oasis-open.org="" committees="" download.php="" 3405="" oasis-sstc-saml-bindings-1.1.pdf="">.</http:></http:></http:></http:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [OASIS.sstc-sec-analysis-response-01]
              Linn, J., Ed., and P. Mishra, Ed., "SSTC Response to
              "Security Analysis of the SAML Single Sign-on Browser/
              Artifact Profile"", January 2005,
              <http: www.oasis-open.org="" committees="" download.php="" 11191="" sstc-gross-sec-analysis-response-01.pdf="">.

   [OAuth-ASSERTIONS]
              Campbell, B., Mortimore, C., Jones, M., and Y. Goland,
              "Assertion Framework for OAuth 2.0", Work in Progress,
              December 2012.

   [OAuth-HTTP-MAC]
              Richer, J., Ed., Mills, W., Ed., and H. Tschofenig, Ed.,
              "OAuth 2.0 Message Authentication Code (MAC) Tokens", Work
              in Progress, November 2012.

   [OAuth-JWT]
              Jones, M., Bradley, J., and N. Sakimura, "JSON Web Token
              (JWT)", Work in Progress, December 2012.

   [OAuth-REVOCATION]
              Lodderstedt, T., Ed., Dronia, S., and M. Scurtescu, "Token
              Revocation", Work in Progress, November 2012.

   [OPENID]   "OpenID Foundation Home Page", <http: openid.net="">.

   [OWASP]    "Open Web Application Security Project Home Page",
              <https: www.owasp.org="">.

   [Portable-Contacts]
              Smarr, J., "Portable Contacts 1.0 Draft C", August 2008,
              <http: portablecontacts.net="">.

   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext
              Transfer Protocol -- HTTP/1.1", RFC 2616, June 1999.

   [RFC2818]  Rescorla, E., "HTTP Over TLS", RFC 2818, May 2000.

   [RFC4086]  Eastlake, D., Schiller, J., and S. Crocker, "Randomness
              Requirements for Security", BCP 106, RFC 4086, June 2005.

   [RFC4120]  Neuman, C., Yu, T., Hartman, S., and K. Raeburn, "The
              Kerberos Network Authentication Service (V5)", RFC 4120,
              July 2005.</http:></https:></http:></http:></pre>
<hr class="noprint" style="width: 96ex;" align="left"><!--NewPage--><pre style="height: 840px; white-space: pre-wrap;"> 

 
   [RFC4301]  Kent, S. and K. Seo, "Security Architecture for the
              Internet Protocol", RFC 4301, December 2005.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246, August 2008.

   [SSL-Latency]
              Sissel, J., Ed., "SSL handshake latency and HTTPS
              optimizations", June 2010.

   [Sec-Analysis]
              Gross, T., "Security Analysis of the SAML Single Sign-on
              Browser/Artifact Profile", 19th Annual Computer Security
              Applications Conference, Las Vegas, December 2003.

   [X-Frame-Options]
              Ross, D. and T. Gondrom, "HTTP Header X-Frame-Options",
              Work in Progress, October 2012.

   [iFrame]   World Wide Web Consortium, "Frames in HTML documents",
              W3C HTML 4.01, December 1999,
              <http: www.w3.org="" tr="" html4="" present="" frames.html#h-16.5="">.

Authors' Addresses

   Torsten Lodderstedt (editor)
   Deutsche Telekom AG

   EMail: torsten@lodderstedt.net


   Mark McGloin
   IBM

   EMail: mark.mcgloin@ie.ibm.com


   Phil Hunt
   Oracle Corporation

   EMail: phil.hunt@yahoo.com</http:></pre><br>
    <span class="noprint"><small><small>Html markup produced by rfcmarkup 1.129c, available from
      <a href="https://tools.ietf.org/tools/rfcmarkup/">https://tools.ietf.org/tools/rfcmarkup/</a>
    </small></small></span>
  </div>
